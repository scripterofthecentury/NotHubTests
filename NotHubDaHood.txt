local TargetURL = "https://raw.githubusercontent.com/anhchongyeuvo/kazama-vhuy/refs/heads/main/keysys"

if hookmetamethod then
    local old_namecall
    old_namecall = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        if method == "HttpGet" and self == game and tostring(args[1]) == TargetURL then
            return ""
        end
        return old_namecall(self, ...)
    end)
end

if hookfunction then
    local old_httpget
    old_httpget = hookfunction(game.HttpGet, function(self, url, ...)
        if tostring(url) == TargetURL then
            return ""
        end
        return old_httpget(self, url, ...)
    end)
end

local success, err = pcall(function()
loadstring(game:HttpGet('https://raw.githubusercontent.com/anhchongyeuvo/kazama-vhuy/refs/heads/main/keysys'))()
if not game:IsLoaded() then 
    game.Loaded:Wait()
end
if game.GameId ~= 17625359962 then

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait() and Players.LocalPlayer

print("Rivals Anticheat Disabler executed!")
local success, err = pcall(function()
    assert(getgc, "executor missing required function getgc")
    assert(debug and debug.info, "executor missing required function debug.info (somehow)")
    assert(hookfunction, "executor missing required function hookfunction")
    assert(getconnections, "executor missing required function getconnections")
    assert(newcclosure, "executor missing required function newcclosure")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local LogService = game:GetService("LogService")
    local ScriptContext = game:GetService("ScriptContext")
    task.spawn(function()
        local hooked = 0
        for _, v in pairs(getgc(true)) do
            if typeof(v) == "function" then
                local ok, src = pcall(function()
                    return debug.info(v, "s")
                end)
                if ok and type(src) == "string" and string.find(src, "AnalyticsPipelineController") then
                    hooked += 1
                    local oldfn
                    oldfn = hookfunction(v, newcclosure(function(...)
                        return wait(9e9)
                    end))
                end
            end
        end
        print("Hanged " .. hooked .. " functions")
    end)
    task.spawn(function()
        local ok, remote = pcall(function()
            return ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("AnalyticsPipeline"):WaitForChild("RemoteEvent")
        end)
        if ok and remote and remote.OnClientEvent then
            local hooked = 0
            for _, conn in pairs(getconnections(remote.OnClientEvent)) do
                if conn and conn.Function then
                    if pcall(function()
                        hookfunction(conn.Function, newcclosure(function(...)
                        end))
                    end) then 
                        hooked += 1
                    end
                end
            end
            print("Hooked " .. hooked .. " anticheat remotes")
        end
    end)
    task.spawn(function()
        local hooked = 0
        for _, conn in pairs(getconnections(LogService.MessageOut)) do
            if conn and conn.Function then
                if pcall(function()
                    hookfunction(conn.Function, newcclosure(function(...)
                    end))
                end) then
                    hooked += 1
                end
            end
        end
        print("Hooked " .. hooked .. " MessageOut connections")
    end)
    task.spawn(function()
        local hooked = 0
        for _, conn in ipairs(getconnections(ScriptContext.Error)) do
            if pcall(function()
                conn:Disable()
            end) then
                hooked += 1
            end
        end
        print("Hooked " .. hooked .. " error connections")
        pcall(function()
            hookfunction(ScriptContext.Error.Connect, newcclosure(function(...)
                return nil
            end))
        end)
    end)
    task.spawn(function()
        local KickNames = {
            "Kick",
            "kick"
        }
        for _, name in ipairs(KickNames) do
            local fn = LocalPlayer[name]
            if type(fn) == "function" then
                local oldkick
                oldkick = hookfunction(fn, newcclosure(function(self, ...)
                    if self == LocalPlayer then
                        return
                    end
                    return oldkick(self, ...)
                end))
            end
        end
    end)
end)
end
coroutine.wrap(function()
if not syn or not protectgui then
    getgenv().protectgui = function() end
end

task.spawn(function()
	local g = getinfo or debug.getinfo
	local d = false
	local h = {}

	local x, y

	setthreadidentity(2)

	for i, v in getgc(true) do
		if typeof(v) == "table" then
			local a = rawget(v, "Detected")
			local b = rawget(v, "Kill")
		
			if typeof(a) == "function" and not x then
				x = a
				local o; o = hookfunction(x, function(c, f, n)
					if c ~= "_" then
						if d then
						end
					end
					
					return true
				end)
				table.insert(h, x)
			end

			if rawget(v, "Variables") and rawget(v, "Process") and typeof(b) == "function" and not y then
				y = b
				local o; o = hookfunction(y, function(f)
					if d then
					end
				end)
				table.insert(h, y)
			end
		end
	end

	local o; o = hookfunction(getrenv().debug.info, newcclosure(function(...)
		local a, f = ...

		if x and a == x then
			if d then
				warn(`zins | adonis bypassed`)
			end

			return coroutine.yield(coroutine.running())
		end
		
		return o(...)
	end))

	setthreadidentity(7)
end)
local t = {}

game:GetService("RunService").Heartbeat:Connect(function()
    for _, c in ipairs(getconnections(game:GetService("LogService").MessageOut)) do
        if not table.find(t, c) then
            t[#t+1] = c
            local u = pcall(getupvalues, c.Function) and getupvalues(c.Function) or {}
            if #u >= 9 and type(u[9]) == "table" and type(u[9][1]) == "function" then
                pcall(setupvalue, u[9][1], 14, function() return function(x)
                    if type(x) == "table" then for i = 1, 4 do
                        if type(x[i]) == "userdata" and x[i].Disconnect then pcall(x[i].Disconnect, x[i]) end
                    end end
                end end)
                pcall(setupvalue, u[9][1], 1, function() task.wait(200) end)
                local o = u[9][1]
                pcall(hookfunction, u[9][1], function() return {} end)
            end
        end
    end
end)

local success, err = pcall(function()
    local gamerawmetatable = getrawmetatable(game)
    setreadonly(gamerawmetatable, false)

    old__namecall1 = gamerawmetatable.__namecall
    gamerawmetatable.__namecall = newcclosure(function(self, ...)
        local args = {...}
        local remoteName = tostring(args[1])

        local blockedRemotes = {
            ["TeleportDetect"] = true,
            ["CHECKER_1"] = true,
            ["CHECKER"] = true,
            ["GUI_CHECK"] = true,
            ["OneMoreTime"] = true,
            ["checkingSPEED"] = true,
            ["BANREMOTE"] = true,
            ["PERMAIDBAN"] = true,
            ["KICKREMOTE"] = true,
            ["BR_KICKPC"] = true,
            ["BR_KICKMOBILE"] = true
        }

        if blockedRemotes[remoteName] then
            return
        end

        return old__namecall1(self, ...)
    end)
end)

if not success then
    warn("[Anti-RemoteBlock] Executor not support hook metatable (__namecall). Skipped.")
end
warn("[+] NotHub : anticheat bypassed.")
end)()
local repo = 'https://raw.githubusercontent.com/anhchongyeuvo/kazama-vhuy/refs/heads/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local Options = Library.Options
local Toggles = Library.Toggles

Library.ShowToggleFrameInKeybinds = true
Library.ShowCustomCursor = true
Library.NotifySide = "Right"
local TextChatService = game:GetService("TextChatService")
local isDaHood = (game.PlaceId == 2788229376)
local chatWindow = TextChatService:FindFirstChild("ChatWindowConfiguration")
local ChatEnabled = true
if ChatEnabled and chatWindow then
    chatWindow.Enabled = true -- Bật lại chat window
end
local Camera = workspace.CurrentCamera
local Window = Library:CreateWindow({
    Title = 'NotHub | gg/Vsnz2wfjP5',
    Center = false,
    AutoShow = true,
    Resizable = true,
    ShowCustomCursor = true,
    UnlockMouseWhileOpen = true,
    NotifySide = "Left",
    TabPadding = 8,
    MenuFadeTime = 0.2
})
local Tabs = {
    Main = Window:AddTab('Main'),
    Visual = Window:AddTab('Visual'),
    Character = Window:AddTab('Character'),
    Misc = Window:AddTab('Misc'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}
local previousTargetHealth = {}
local TargetAimActive = false
local BuyingActive = false
local AutoArmorActive = false
local AutoLoadoutActive = false
local BuyingSingleActive = false
local BuyingAmmoActive = false
getgenv().Matcha = {}
local matchacc = {
    TargetAim = {
        Enabled = false,
        Target = "None",
        AutoSelect = false,
        AutoFire = false,
        Strafe = false,
        ToggleStrafe = false,
        VisualizeStrafe = false,
        VisualizeStrafeInlineColor = Color3.fromRGB(255, 255, 255),
        VisualizeStrafeOutlineColor = Color3.fromRGB(255, 255, 255),
        LineStrafe = false,
        StrafeMethod = "Randomize",
        StrafePrediction = 0.1,
        Highlight = false,
        HighlightFillColor = Color3.fromRGB(255, 255, 255),
        HighlightOutlineColor = Color3.fromRGB(255, 255, 255),
        Tracer = false,
        TracerPosition = "Mouse",
        TracerFillColor = Color3.fromRGB(255, 255, 255),
        TracerOutlineColor = Color3.fromRGB(0, 0, 0),
        LookAt = false,
        SpectateTarget = false,
        VoidResolver = false,
        AutoStomp = false,
    },
    HitEffects = {
        HitSounds = false,
        HitSoundID = "rbxassetid://6534947588",
        HitSoundVolume = 5,
        HitNotifications = false,
        HitNotificationsTime = 3,
	    HitChams = {
		    Enabled = false,
		    Color = Color3.fromRGB(255, 255, 255),
		    Lifetime = 3,
		    Transparency = 0.7,
		    Material = "Neon"
		},
		HitEffect = {
		    Enabled = false,
		    Type = "",
		    Color = Color3.fromRGB(255, 255, 255), 
		},
    },
    Checks = {
        Wall = false,
        Forcefield = false,
        Alive = false,
        Team = false,
    },
    KillAura = {
        Enabled = false,
        Active = false,
        Range = 250,
        Silent = false,
        Visualize = false,
        StompAura = false,
        Whitelist = {},
    },
    AutoKillAll = {
	    Enabled = false,
	    CurrentTargetIndex = 1,
	    Targets = {},
	},
    RapidFire = {
        Enabled = false,
    },
    Wallbang = {
        Enabled = false,
    },
    HitboxExpander = {
        Enabled = false,
        Visualize = false,
        Color = Color3.fromRGB(255, 255, 255),
        OutlineColor = Color3.fromRGB(255, 255, 255),
        FillTransparency = 0.5,
        OutlineTransparency = 0.3,
        Size = 15,
    },
    AutoKill = {
        Enabled = false,
        Target = nil,
        Spectate = false,
        AutoKillDesync = true,
    },
    Movement = {
        WalkSpeedEnabled = false,
        WalkSpeed = 16,  -- Default Roblox walkspeed
        JumpPowerEnabled = false,
        JumpPower = 50,  -- Default Roblox jumppower
    },
}

local desync_setback = Instance.new("Part")
desync_setback.Name = "DesyncSetback"
desync_setback.Size = Vector3.new(2, 2, 1)
desync_setback.CanCollide = false
desync_setback.Anchored = true
desync_setback.Transparency = 1
desync_setback.Parent = workspace

local BodyClone = game:GetObjects("rbxassetid://8246626421")[1]
BodyClone.Parent = workspace
BodyClone.Humanoid:Destroy()
BodyClone.Head.Face:Destroy()
for _, v in pairs(BodyClone:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("MeshPart") then
        v.CanCollide = false
        v.Transparency = 1
    end
end
BodyClone.HumanoidRootPart.Transparency = 1
BodyClone.HumanoidRootPart.Velocity = Vector3.zero
BodyClone.HumanoidRootPart.CFrame = CFrame.new(9999, 9999, 9999)

local BodyCloneHighlight = Instance.new("Highlight")
BodyCloneHighlight.Enabled = false
BodyCloneHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
BodyCloneHighlight.FillColor = Color3.fromRGB(0, 255, 0)
BodyCloneHighlight.OutlineColor = Color3.fromRGB(255, 255, 255)
BodyCloneHighlight.FillTransparency = 0.3
BodyCloneHighlight.OutlineTransparency = 0
BodyCloneHighlight.Adornee = BodyClone
BodyCloneHighlight.Parent = BodyClone

local GlowLight = Instance.new("PointLight")
GlowLight.Color = Color3.fromRGB(255, 255, 255)
GlowLight.Brightness = 4
GlowLight.Range = 30
GlowLight.Parent = BodyClone.HumanoidRootPart

-- Desync Line
local DesyncLine = Drawing.new("Line")
DesyncLine.Thickness = 1
DesyncLine.Color = Color3.fromRGB(0, 255, 0)
DesyncLine.Visible = false
DesyncLine.Transparency = 1

-- Tracer for TargetAim
local tracerOutline = Drawing.new("Line")
tracerOutline.Visible = false
tracerOutline.Color = matchacc.TargetAim.TracerOutlineColor
tracerOutline.Thickness = 4

local tracer = Drawing.new("Line")
tracer.Visible = false
tracer.Color = matchacc.TargetAim.TracerFillColor
tracer.Thickness = 2

-- KillAura Tracer Part
local ka_tracer = Instance.new("Part")
ka_tracer.Size = Vector3.new(0.2, 0.2, 0.2)
ka_tracer.Material = Enum.Material.Neon
ka_tracer.Color = Color3.fromRGB(255, 255, 255)
ka_tracer.Transparency = 1
ka_tracer.Anchored = true
ka_tracer.CanCollide = false
ka_tracer.Parent = workspace
local HitChamDebounce = {}
local TweenService = game:GetService("TweenService")
local utility = {}
utility.clone_character = function(player, transparency, color, material, delete_hrp)
    if not player or not player.Character then return end
    delete_hrp = delete_hrp == nil and true or delete_hrp

    player.Character.Archivable = true
    local clone = player.Character:Clone()
    player.Character.Archivable = false

    clone.Parent = workspace
    clone.Name = "HitCham_"

    for _, part in ipairs(clone:GetChildren()) do
        if part:IsA("MeshPart") or part:IsA("Part") then
            part.Anchored = true
            part.CanCollide = false
            part.Material = Enum.Material[material or "Neon"]
            part.Color = color
            part.Transparency = transparency

            -- Xóa face
            if part.Name == "Head" then
                local face = part:FindFirstChild("face")
                if face then face:Destroy() end
            end
        elseif part.Name ~= "HumanoidRootPart" or delete_hrp then
            part:Destroy()
        end
    end

    -- Xóa Humanoid + script
    if clone:FindFirstChild("Humanoid") then
        clone.Humanoid:Destroy()
    end
    for _, v in ipairs(clone:GetDescendants()) do
        if v:IsA("Script") or v:IsA("LocalScript") or v:IsA("Animator") then
            v:Destroy()
        end
    end

    -- Highlight siêu chất (bắt buộc để nhìn đẹp)
    local highlight = Instance.new("Highlight")
    highlight.Adornee = clone
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.FillColor = color
    highlight.FillTransparency = math.max(0, transparency - 0.3)
    highlight.OutlineColor = Color3.new(1,1,1)
    highlight.OutlineTransparency = 0
    highlight.Parent = clone

    return clone
end

local function createHitChamWithFade(plr)
    if not plr or not plr.Character or not matchacc.HitEffects.HitChams.Enabled then return end
    local now = tick()
    if HitChamDebounce[plr] and (now - HitChamDebounce[plr]) < 0.1 then return end
    HitChamDebounce[plr] = now

    plr.Character.Archivable = true
    local clone = plr.Character:Clone()
    plr.Character.Archivable = false
    clone.Parent = workspace
    clone.Name = "HitCham_"..plr.Name

    -- Xóa rác
    if clone:FindFirstChild("Humanoid") then clone.Humanoid:Destroy() end
    for _, v in pairs(clone:GetDescendants()) do
        if v:IsA("Script") or v:IsA("LocalScript") or v:IsA("Animator") or v.Name == "face" then
            v:Destroy()
        elseif v:IsA("BasePart") or v:IsA("MeshPart") then
            v.Anchored = true
            v.CanCollide = false
            v.Material = Enum.Material[matchacc.HitEffects.HitChams.Material]
            v.Color = matchacc.HitEffects.HitChams.Color
            v.Transparency = matchacc.HitEffects.HitChams.Transparency
        end
    end

    -- Highlight
    local hl = Instance.new("Highlight", clone)
    hl.FillColor = matchacc.HitEffects.HitChams.Color
    hl.FillTransparency = matchacc.HitEffects.HitChams.Transparency - 0.2
    hl.OutlineTransparency = 0
    hl.OutlineColor = Color3.new(1,1,1)

    -- Fade out siêu mượt
    local tweenInfo = TweenInfo.new(
        matchacc.HitEffects.HitChams.Lifetime,
        Enum.EasingStyle.Sine,
        Enum.EasingDirection.InOut,
        0, true, 0
    )
    for _, part in pairs(clone:GetDescendants()) do
        if part:IsA("BasePart") or part:IsA("MeshPart") then
            local tween = TweenService:Create(part, tweenInfo, {Transparency = 1})
            tween:Play()
        end
    end
    if hl then
        local hlTween = TweenService:Create(hl, tweenInfo, {FillTransparency = 1, OutlineTransparency = 1})
        hlTween:Play()
    end

    task.delay(matchacc.HitEffects.HitChams.Lifetime * 2, function()
        if clone and clone.Parent then clone:Destroy() end
    end)
end
-- ==================== FULL HIT EFFECT SETUP - ĐẸP NHƯ NEVERLOSE / RISE ====================
-- Dán nguyên đoạn này vào cuối file NotHub (trước end) - Không cần chỉnh gì nữa

-- Table lưu tất cả Hit Effect Types
local HitEffects = {
    ["None"] = nil,
    ["Skibidi RedRizz"] = true,
    ["Nova"] = true,
    ["Crescent Slash"] = true,
    ["Cosmic Explosion"] = true,
    ["Coom"] = true,
    ["Slash"] = true,
    ["Atomic Slash"] = true,
    ["Thunder"] = true,
    ["Electric"] = true,
    ["Circle"] = true,
    ["Shock3"] = true,
    ["Aura"] = true,
    ["IDK"] = true,
    ["Swirl"] = true,
    ["AuraBurst"] = true,
}

-- Tạo container lưu effects (chạy 1 lần)
if not workspace:FindFirstChild("MatchaHitEffects") then
    local container = Instance.new("Folder")
    container.Name = "MatchaHitEffects"
    container.Parent = workspace

    -- ====== Skibidi RedRizz ======
    local skibidiPart = Instance.new("Part")
    skibidiPart.Name = "Skibidi RedRizz"
    skibidiPart.Parent = container
    local skibidiAtt = Instance.new("Attachment", skibidiPart)
    skibidiAtt.Name = "HitEffectAttachment"

    local MainColor = Color3.fromRGB(143, 48, 167)
    local emitter = Instance.new('ParticleEmitter')
    emitter.Name = "emitter"
    emitter.LightEmission = 3
    emitter.Transparency = NumberSequence.new(0)
    emitter.Color = ColorSequence.new(MainColor)
    emitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(1, 6, 1.2)}
    emitter.Rotation = NumberRange.new(0)
    emitter.RotSpeed = NumberRange.new(0)
    emitter.Enabled = false
    emitter.Rate = 50
    emitter.Lifetime = NumberRange.new(0.25)
    emitter.Speed = NumberRange.new(0.1)
    emitter.Squash = NumberSequence.new(0)
    emitter.ZOffset = 1
    emitter.Texture = "rbxassetid://2916153928"
    emitter.Orientation = Enum.ParticleOrientation.VelocityParallel
    emitter.Shape = 'Box'
    emitter.ShapeInOut = 'Outward'
    emitter.ShapeStyle = 'Volume'
    emitter.Parent = skibidiAtt

    local skum = Instance.new('ParticleEmitter')
    skum.Name = "skum"
    skum.LightEmission = 3
    skum.Transparency = NumberSequence.new(0)
    skum.Color = ColorSequence.new(MainColor)
    skum.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(1, 6, 1.2)}
    skum.Rotation = NumberRange.new(0)
    skum.RotSpeed = NumberRange.new(0)
    skum.Enabled = false
    skum.Rate = 50
    skum.Lifetime = NumberRange.new(0.25)
    skum.Speed = NumberRange.new(0.1)
    skum.Squash = NumberSequence.new(0)
    skum.ZOffset = 1
    skum.Texture = "rbxassetid://1084991215"
    skum.Orientation = Enum.ParticleOrientation.VelocityParallel
    skum.Shape = 'Box'
    skum.ShapeInOut = 'Outward'
    skum.ShapeStyle = 'Volume'
    skum.Parent = skibidiAtt

    local Shards = Instance.new("ParticleEmitter")
    Shards.Name = "Shards"
    Shards.Lifetime = NumberRange.new(0.19, 0.7)
    Shards.SpreadAngle = Vector2.new(-90, 90)
    Shards.Color = ColorSequence.new(Color3.fromRGB(108, 184, 255))
    Shards.Drag = 10
    Shards.VelocitySpread = -90
    Shards.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5705521, 0.4125001), NumberSequenceKeypoint.new(1, -0.9375)})
    Shards.Speed = NumberRange.new(97.7530136, 146.9970093)
    Shards.Brightness = 4
    Shards.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.284774, 1.2389833, 0.1534118), NumberSequenceKeypoint.new(1, 0)})
    Shards.Enabled = false
    Shards.Acceleration = Vector3.new(0, -56.961341857910156, 0)
    Shards.ZOffset = 0.5705321
    Shards.Rate = 50
    Shards.Texture = "rbxassetid://8030734851"
    Shards.Rotation = NumberRange.new(90, 90)
    Shards.Orientation = Enum.ParticleOrientation.VelocityParallel
    Shards.Parent = skibidiAtt

    local ShardsDark = Instance.new("ParticleEmitter")
    ShardsDark.Name = "ShardsDark"
    ShardsDark.Lifetime = NumberRange.new(0.19, 0.35)
    ShardsDark.SpreadAngle = Vector2.new(-90, 90)
    ShardsDark.Color = ColorSequence.new(Color3.fromRGB(108, 184, 255))
    ShardsDark.Drag = 10
    ShardsDark.VelocitySpread = -90
    ShardsDark.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5705521, 0.4125001), NumberSequenceKeypoint.new(1, -0.9375)})
    ShardsDark.Speed = NumberRange.new(97.7530136, 146.9970093)
    ShardsDark.Brightness = 4
    ShardsDark.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.290774, 0.6734411, 0.1534118), NumberSequenceKeypoint.new(1, 0)})
    ShardsDark.Enabled = false
    ShardsDark.ZOffset = 0.5705321
    ShardsDark.Rate = 50
    ShardsDark.Texture = "rbxassetid://8030734851"
    ShardsDark.Rotation = NumberRange.new(90, 90)
    ShardsDark.Orientation = Enum.ParticleOrientation.VelocityParallel
    ShardsDark.Parent = skibidiAtt

    local large_shard = Instance.new("ParticleEmitter")
    large_shard.Name = "large_shard"
    large_shard.Lifetime = NumberRange.new(0.19, 0.28)
    large_shard.SpreadAngle = Vector2.new(-90, 90)
    large_shard.Color = ColorSequence.new(Color3.fromRGB(108, 184, 255))
    large_shard.Drag = 10
    large_shard.VelocitySpread = -90
    large_shard.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5705521, 0.4125001), NumberSequenceKeypoint.new(1, -0.9375)})
    large_shard.Speed = NumberRange.new(97.7530136, 146.9970093)
    large_shard.Brightness = 4
    large_shard.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.260774, 3.515605, 0.1534118), NumberSequenceKeypoint.new(1, 0)})
    large_shard.Enabled = false
    large_shard.ZOffset = 0.5705321
    large_shard.Rate = 50
    large_shard.Texture = "rbxassetid://8030734851"
    large_shard.Rotation = NumberRange.new(90, 90)
    large_shard.Orientation = Enum.ParticleOrientation.VelocityParallel
    large_shard.Parent = skibidiAtt

    local out_Specs = Instance.new("ParticleEmitter")
    out_Specs.Name = "out_Specs"
    out_Specs.Lifetime = NumberRange.new(0.19, 1)
    out_Specs.SpreadAngle = Vector2.new(44, -1000)
    out_Specs.Color = ColorSequence.new(Color3.fromRGB(98, 174, 255))
    out_Specs.Drag = 10
    out_Specs.VelocitySpread = 44
    out_Specs.Speed = NumberRange.new(36.7492523, 146.9970093)
    out_Specs.Brightness = 7
    out_Specs.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.244774, 0.5469525, 0.1433053), NumberSequenceKeypoint.new(1, 0)})
    out_Specs.Enabled = false
    out_Specs.Acceleration = Vector3.new(0, -3.215559720993042, 0)
    out_Specs.Rate = 50
    out_Specs.Texture = "rbxassetid://8030760338"
    out_Specs.EmissionDirection = Enum.NormalId.Right
    out_Specs.Parent = skibidiAtt

    local Effect = Instance.new("ParticleEmitter")
    Effect.Name = "Effect"
    Effect.Lifetime = NumberRange.new(0.4, 0.7)
    Effect.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
    Effect.SpreadAngle = Vector2.new(360, -360)
    Effect.LockedToPart = true
    Effect.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1070999, 0.19375), NumberSequenceKeypoint.new(0.7761194, 0.88125), NumberSequenceKeypoint.new(1, 1)})
    Effect.LightEmission = 1
    Effect.Color = ColorSequence.new(Color3.fromRGB(92, 161, 252))
    Effect.Drag = 1
    Effect.VelocitySpread = 360
    Effect.Speed = NumberRange.new(0.0036749, 0.0036749)
    Effect.Brightness = 2.0999999
    Effect.Size = NumberSequence.new(6.9680691, 9.9213123)
    Effect.Enabled = false
    Effect.ZOffset = 0.4777403
    Effect.Rate = 50
    Effect.Texture = "rbxassetid://9484012464"
    Effect.RotSpeed = NumberRange.new(-150, -150)
    Effect.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    Effect.Rotation = NumberRange.new(50, 50)
    Effect.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
    Effect.Parent = skibidiAtt

    local Crescents = Instance.new("ParticleEmitter")
    Crescents.Name = "Crescents"
    Crescents.Lifetime = NumberRange.new(0.19, 0.38)
    Crescents.SpreadAngle = Vector2.new(-360, 360)
    Crescents.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1932907, 0), NumberSequenceKeypoint.new(0.778754, 0), NumberSequenceKeypoint.new(1, 1)})
    Crescents.LightEmission = 1
    Crescents.Color = ColorSequence.new(Color3.fromRGB(92, 161, 252))
    Crescents.VelocitySpread = -360
    Crescents.Speed = NumberRange.new(0.0826858, 0.0826858)
    Crescents.Brightness = 20
    Crescents.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.398774, 8.8026266, 2.2834616), NumberSequenceKeypoint.new(1, 11.477972, 1.860431)})
    Crescents.Enabled = false
    Crescents.ZOffset = 0.4542207
    Crescents.Rate = 50
    Crescents.Texture = "rbxassetid://12509373457"
    Crescents.RotSpeed = NumberRange.new(800, 1000)
    Crescents.Rotation = NumberRange.new(-360, 360)
    Crescents.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
    Crescents.Parent = skibidiAtt

    -- ====== Crescent Slash ======
    local crescentPart = Instance.new("Part")
    crescentPart.Name = "Crescent Slash"
    crescentPart.Parent = container
    local crescentAtt = Instance.new("Attachment", crescentPart)
    crescentAtt.Name = "HitEffectAttachment"

    local Glow = Instance.new("ParticleEmitter", crescentAtt)
    Glow.Name = "Glow"
    Glow.Lifetime = NumberRange.new(0.16, 0.16)
    Glow.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1421725, 0.6182796), NumberSequenceKeypoint.new(1, 1)})
    Glow.Color = ColorSequence.new(Color3.fromRGB(91, 177, 252))
    Glow.Speed = NumberRange.new(0, 0)
    Glow.Brightness = 5
    Glow.Size = NumberSequence.new(9.1873131, 16.5032349)
    Glow.Enabled = false
    Glow.ZOffset = -0.0565939
    Glow.Rate = 50
    Glow.Texture = "rbxassetid://8708637750"

    local Gradient1 = Instance.new("ParticleEmitter", crescentAtt)
    Gradient1.Name = "Gradient1"
    Gradient1.Lifetime = NumberRange.new(0.3, 0.3)
    Gradient1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.15, 0.3), NumberSequenceKeypoint.new(1, 1)})
    Gradient1.Color = ColorSequence.new(Color3.fromRGB(115, 201, 255))
    Gradient1.Speed = NumberRange.new(0, 0)
    Gradient1.Brightness = 6
    Gradient1.Size = NumberSequence.new(0, 11.6261358)
    Gradient1.Enabled = false
    Gradient1.ZOffset = 0.9187313
    Gradient1.Rate = 50
    Gradient1.Texture = "rbxassetid://8196169974"

    local Shards = Instance.new("ParticleEmitter", crescentAtt)
    Shards.Name = "Shards"
    Shards.Lifetime = NumberRange.new(0.19, 0.7)
    Shards.SpreadAngle = Vector2.new(-90, 90)
    Shards.Color = ColorSequence.new(Color3.fromRGB(108, 184, 255))
    Shards.Drag = 10
    Shards.VelocitySpread = -90
    Shards.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5705521, 0.4125001), NumberSequenceKeypoint.new(1, -0.9375)})
    Shards.Speed = NumberRange.new(97.7530136, 146.9970093)
    Shards.Brightness = 4
    Shards.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.284774, 1.2389833, 0.1534118), NumberSequenceKeypoint.new(1, 0)})
    Shards.Enabled = false
    Shards.Acceleration = Vector3.new(0, -56.961341857910156, 0)
    Shards.ZOffset = 0.5705321
    Shards.Rate = 50
    Shards.Texture = "rbxassetid://8030734851"
    Shards.Rotation = NumberRange.new(90, 90)
    Shards.Orientation = Enum.ParticleOrientation.VelocityParallel

    local ShardsDark = Instance.new("ParticleEmitter", crescentAtt)
    ShardsDark.Name = "ShardsDark"
    ShardsDark.Lifetime = NumberRange.new(0.19, 0.35)
    ShardsDark.SpreadAngle = Vector2.new(-90, 90)
    ShardsDark.Color = ColorSequence.new(Color3.fromRGB(108, 184, 255))
    ShardsDark.Drag = 10
    ShardsDark.VelocitySpread = -90
    ShardsDark.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5705521, 0.4125001), NumberSequenceKeypoint.new(1, -0.9375)})
    ShardsDark.Speed = NumberRange.new(97.7530136, 146.9970093)
    ShardsDark.Brightness = 4
    ShardsDark.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.290774, 0.6734411, 0.1534118), NumberSequenceKeypoint.new(1, 0)})
    ShardsDark.Enabled = false
    ShardsDark.ZOffset = 0.5705321
    ShardsDark.Rate = 50
    ShardsDark.Texture = "rbxassetid://8030734851"
    ShardsDark.Rotation = NumberRange.new(90, 90)
    ShardsDark.Orientation = Enum.ParticleOrientation.VelocityParallel

    local Specs = Instance.new("ParticleEmitter", crescentAtt)
    Specs.Name = "Specs"
    Specs.Lifetime = NumberRange.new(0.33, 1.4)
    Specs.SpreadAngle = Vector2.new(360, -1000)
    Specs.Color = ColorSequence.new(Color3.fromRGB(98, 174, 255))
    Specs.Drag = 10
    Specs.VelocitySpread = 360
    Specs.Speed = NumberRange.new(36.7492523, 146.9970093)
    Specs.Brightness = 7
    Specs.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.200774, 2.0311937, 0.4363973), NumberSequenceKeypoint.new(1, 0)})
    Specs.Enabled = false
    Specs.Acceleration = Vector3.new(0, 36.74925231933594, 0)
    Specs.Rate = 50
    Specs.Texture = "rbxassetid://8030760338"
    Specs.EmissionDirection = Enum.NormalId.Right

    local Specs1 = Instance.new("ParticleEmitter", crescentAtt)
    Specs1.Name = "Specs"
    Specs1.Lifetime = NumberRange.new(0.33, 1.75)
    Specs1.SpreadAngle = Vector2.new(90, -90)
    Specs1.Color = ColorSequence.new(Color3.fromRGB(106, 171, 255))
    Specs1.Drag = 9
    Specs1.VelocitySpread = 90
    Specs1.Speed = NumberRange.new(42.2616425, 73.4985046)
    Specs1.Brightness = 6
    Specs1.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.210774, 0.3978962, 0.1855686), NumberSequenceKeypoint.new(1, 0)})
    Specs1.Enabled = false
    Specs1.Acceleration = Vector3.new(0, -20.21208953857422, 0)
    Specs1.ZOffset = 0.5144895
    Specs1.Rate = 50
    Specs1.Texture = "rbxassetid://8030760338"

    local Specs2 = Instance.new("ParticleEmitter", crescentAtt)
    Specs2.Name = "Specs"
    Specs2.Lifetime = NumberRange.new(0.19, 1.2)
    Specs2.SpreadAngle = Vector2.new(360, -1000)
    Specs2.Color = ColorSequence.new(Color3.fromRGB(98, 174, 255))
    Specs2.Drag = 10
    Specs2.VelocitySpread = 360
    Specs2.Speed = NumberRange.new(36.7492523, 146.9970093)
    Specs2.Brightness = 7
    Specs2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.200774, 2.0311937, 0.4363973), NumberSequenceKeypoint.new(1, 0)})
    Specs2.Enabled = false
    Specs2.Acceleration = Vector3.new(0, 36.74925231933594, 0)
    Specs2.Rate = 50
    Specs2.Texture = "rbxassetid://8030760338"
    Specs2.EmissionDirection = Enum.NormalId.Right

    local Specs21 = Instance.new("ParticleEmitter", crescentAtt)
    Specs21.Name = "Specs2"
    Specs21.Lifetime = NumberRange.new(0.19, 1.35)
    Specs21.SpreadAngle = Vector2.new(90, -90)
    Specs21.Color = ColorSequence.new(Color3.fromRGB(106, 171, 255))
    Specs21.Drag = 12
    Specs21.VelocitySpread = 90
    Specs21.Speed = NumberRange.new(42.2616425, 73.4985046)
    Specs21.Brightness = 6
    Specs21.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.216774, 0.5721694, 0.1855686), NumberSequenceKeypoint.new(1, 0)})
    Specs21.Enabled = false
    Specs21.Acceleration = Vector3.new(0, -20.21208953857422, 0)
    Specs21.ZOffset = 0.5144895
    Specs21.Rate = 50
    Specs21.Texture = "rbxassetid://8030760338"

    local ddddddddddddddddddd = Instance.new("ParticleEmitter", crescentAtt)
    ddddddddddddddddddd.Name = "ddddddddddddddddddd"
    ddddddddddddddddddd.Lifetime = NumberRange.new(0.19, 0.37)
    ddddddddddddddddddd.SpreadAngle = Vector2.new(90, -90)
    ddddddddddddddddddd.LockedToPart = true
    ddddddddddddddddddd.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.6429392, 0), NumberSequenceKeypoint.new(1, 0)})
    ddddddddddddddddddd.LightEmission = 1
    ddddddddddddddddddd.Color = ColorSequence.new(Color3.fromRGB(90, 184, 255), Color3.fromRGB(165, 251, 255))
    ddddddddddddddddddd.Drag = 6
    ddddddddddddddddddd.TimeScale = 0.7
    ddddddddddddddddddd.VelocitySpread = 90
    ddddddddddddddddddd.Speed = NumberRange.new(81.5833435, 110.2477646)
    ddddddddddddddddddd.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.410774, 0.6711507, 0.3356177), NumberSequenceKeypoint.new(1, 0)})
    ddddddddddddddddddd.Enabled = false
    ddddddddddddddddddd.Acceleration = Vector3.new(0, -81.58334350585938, 0)
    ddddddddddddddddddd.ZOffset = 0.8345273
    ddddddddddddddddddd.Rate = 50
    ddddddddddddddddddd.Texture = "rbxassetid://1053546634"
    ddddddddddddddddddd.RotSpeed = NumberRange.new(-444, 166)
    ddddddddddddddddddd.Rotation = NumberRange.new(-360, 360)

    local large_shard = Instance.new("ParticleEmitter", crescentAtt)
    large_shard.Name = "large_shard"
    large_shard.Lifetime = NumberRange.new(0.19, 0.28)
    large_shard.SpreadAngle = Vector2.new(-90, 90)
    large_shard.Color = ColorSequence.new(Color3.fromRGB(108, 184, 255))
    large_shard.Drag = 10
    large_shard.VelocitySpread = -90
    large_shard.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5705521, 0.4125001), NumberSequenceKeypoint.new(1, -0.9375)})
    large_shard.Speed = NumberRange.new(97.7530136, 146.9970093)
    large_shard.Brightness = 4
    large_shard.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.260774, 3.515605, 0.1534118), NumberSequenceKeypoint.new(1, 0)})
    large_shard.Enabled = false
    large_shard.ZOffset = 0.5705321
    large_shard.Rate = 50
    large_shard.Texture = "rbxassetid://8030734851"
    large_shard.Rotation = NumberRange.new(90, 90)
    large_shard.Orientation = Enum.ParticleOrientation.VelocityParallel

    local out_Specs = Instance.new("ParticleEmitter", crescentAtt)
    out_Specs.Name = "out_Specs"
    out_Specs.Lifetime = NumberRange.new(0.19, 1)
    out_Specs.SpreadAngle = Vector2.new(44, -1000)
    out_Specs.Color = ColorSequence.new(Color3.fromRGB(98, 174, 255))
    out_Specs.Drag = 10
    out_Specs.VelocitySpread = 44
    out_Specs.Speed = NumberRange.new(36.7492523, 146.9970093)
    out_Specs.Brightness = 7
    out_Specs.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.244774, 0.5469525, 0.1433053), NumberSequenceKeypoint.new(1, 0)})
    out_Specs.Enabled = false
    out_Specs.Acceleration = Vector3.new(0, -3.215559720993042, 0)
    out_Specs.Rate = 50
    out_Specs.Texture = "rbxassetid://8030760338"
    out_Specs.EmissionDirection = Enum.NormalId.Right

    local Effect = Instance.new("ParticleEmitter", crescentAtt)
    Effect.Name = "Effect"
    Effect.Lifetime = NumberRange.new(0.4, 0.7)
    Effect.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
    Effect.SpreadAngle = Vector2.new(360, -360)
    Effect.LockedToPart = true
    Effect.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1070999, 0.19375), NumberSequenceKeypoint.new(0.7761194, 0.88125), NumberSequenceKeypoint.new(1, 1)})
    Effect.LightEmission = 1
    Effect.Color = ColorSequence.new(Color3.fromRGB(92, 161, 252))
    Effect.Drag = 1
    Effect.VelocitySpread = 360
    Effect.Speed = NumberRange.new(0.0036749, 0.0036749)
    Effect.Brightness = 2.0999999
    Effect.Size = NumberSequence.new(6.9680691, 9.9213123)
    Effect.Enabled = false
    Effect.ZOffset = 0.4777403
    Effect.Rate = 50
    Effect.Texture = "rbxassetid://9484012464"
    Effect.RotSpeed = NumberRange.new(-150, -150)
    Effect.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    Effect.Rotation = NumberRange.new(50, 50)
    Effect.Orientation = Enum.ParticleOrientation.VelocityPerpendicular

    local Crescents = Instance.new("ParticleEmitter", crescentAtt)
    Crescents.Name = "Crescents"
    Crescents.Lifetime = NumberRange.new(0.19, 0.38)
    Crescents.SpreadAngle = Vector2.new(-360, 360)
    Crescents.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1932907, 0), NumberSequenceKeypoint.new(0.778754, 0), NumberSequenceKeypoint.new(1, 1)})
    Crescents.LightEmission = 1
    Crescents.Color = ColorSequence.new(Color3.fromRGB(92, 161, 252))
    Crescents.VelocitySpread = -360
    Crescents.Speed = NumberRange.new(0.0826858, 0.0826858)
    Crescents.Brightness = 20
    Crescents.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.398774, 8.8026266, 2.2834616), NumberSequenceKeypoint.new(1, 11.477972, 1.860431)})
    Crescents.Enabled = false
    Crescents.ZOffset = 0.4542207
    Crescents.Rate = 50
    Crescents.Texture = "rbxassetid://12509373457"
    Crescents.RotSpeed = NumberRange.new(800, 1000)
    Crescents.Rotation = NumberRange.new(-360, 360)
    Crescents.Orientation = Enum.ParticleOrientation.VelocityPerpendicular

    HitEffects["Crescent Slash"] = crescentAtt

    -- ====== Cosmic Explosion ======
    local cosmicPart = Instance.new("Part")
    cosmicPart.Name = "Cosmic Explosion"
    cosmicPart.Parent = container
    local cosmicAtt = Instance.new("Attachment", cosmicPart)
    cosmicAtt.Name = "HitEffectAttachment"

    local Glow = Instance.new("ParticleEmitter", cosmicAtt)
    Glow.Name = "Glow"
    Glow.Lifetime = NumberRange.new(0.16, 0.16)
    Glow.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1421725, 0.6182796), NumberSequenceKeypoint.new(1, 1)})
    Glow.Color = ColorSequence.new(Color3.fromRGB(173, 82, 252))
    Glow.Speed = NumberRange.new(0, 0)
    Glow.Brightness = 5
    Glow.Size = NumberSequence.new(9.1873131, 16.5032349)
    Glow.Enabled = false
    Glow.ZOffset = -0.0565939
    Glow.Rate = 50
    Glow.Texture = "rbxassetid://8708637750"

    local Effect = Instance.new("ParticleEmitter", cosmicAtt)
    Effect.Name = "Effect"
    Effect.Lifetime = NumberRange.new(0.4, 0.7)
    Effect.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
    Effect.SpreadAngle = Vector2.new(360, -360)
    Effect.LockedToPart = true
    Effect.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1070999, 0.19375), NumberSequenceKeypoint.new(0.7761194, 0.88125), NumberSequenceKeypoint.new(1, 1)})
    Effect.LightEmission = 1
    Effect.Color = ColorSequence.new(Color3.fromRGB(173, 82, 252))
    Effect.Drag = 1
    Effect.VelocitySpread = 360
    Effect.Speed = NumberRange.new(0.0036749, 0.0036749)
    Effect.Brightness = 2.0999999
    Effect.Size = NumberSequence.new(6.9680691, 9.9213123)
    Effect.Enabled = false
    Effect.ZOffset = 0.4777403
    Effect.Rate = 50
    Effect.Texture = "rbxassetid://9484012464"
    Effect.RotSpeed = NumberRange.new(-150, -150)
    Effect.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    Effect.Rotation = NumberRange.new(50, 50)
    Effect.Orientation = Enum.ParticleOrientation.VelocityPerpendicular

    local Gradient1 = Instance.new("ParticleEmitter", cosmicAtt)
    Gradient1.Name = "Gradient1"
    Gradient1.Lifetime = NumberRange.new(0.3, 0.3)
    Gradient1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.15, 0.3), NumberSequenceKeypoint.new(1, 1)})
    Gradient1.Color = ColorSequence.new(Color3.fromRGB(173, 82, 252))
    Gradient1.Speed = NumberRange.new(0, 0)
    Gradient1.Brightness = 6
    Gradient1.Size = NumberSequence.new(0, 11.6261358)
    Gradient1.Enabled = false
    Gradient1.ZOffset = 0.9187313
    Gradient1.Rate = 50
    Gradient1.Texture = "rbxassetid://8196169974"

    local Shards = Instance.new("ParticleEmitter", cosmicAtt)
    Shards.Name = "Shards"
    Shards.Lifetime = NumberRange.new(0.19, 0.7)
    Shards.SpreadAngle = Vector2.new(-90, 90)
    Shards.Color = ColorSequence.new(Color3.fromRGB(173, 82, 252))
    Shards.Drag = 10
    Shards.VelocitySpread = -90
    Shards.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5705521, 0.4125001), NumberSequenceKeypoint.new(1, -0.9375)})
    Shards.Speed = NumberRange.new(97.7530136, 146.9970093)
    Shards.Brightness = 4
    Shards.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.284774, 1.2389833, 0.1534118), NumberSequenceKeypoint.new(1, 0)})
    Shards.Enabled = false
    Shards.Acceleration = Vector3.new(0, -56.961341857910156, 0)
    Shards.ZOffset = 0.5705321
    Shards.Rate = 50
    Shards.Texture = "rbxassetid://8030734851"
    Shards.Rotation = NumberRange.new(90, 90)
    Shards.Orientation = Enum.ParticleOrientation.VelocityParallel

    local Crescents = Instance.new("ParticleEmitter", cosmicAtt)
    Crescents.Name = "Crescents"
    Crescents.Lifetime = NumberRange.new(0.19, 0.38)
    Crescents.SpreadAngle = Vector2.new(-360, 360)
    Crescents.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1932907, 0), NumberSequenceKeypoint.new(0.778754, 0), NumberSequenceKeypoint.new(1, 1)})
    Crescents.LightEmission = 10
    Crescents.Color = ColorSequence.new(Color3.fromRGB(160, 96, 255))
    Crescents.VelocitySpread = -360
    Crescents.Speed = NumberRange.new(0.0826858, 0.0826858)
    Crescents.Brightness = 4
    Crescents.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.398774, 8.8026266, 2.2834616), NumberSequenceKeypoint.new(1, 11.477972, 1.860431)})
    Crescents.Enabled = false
    Crescents.ZOffset = 0.4542207
    Crescents.Rate = 50
    Crescents.Texture = "rbxassetid://12509373457"
    Crescents.RotSpeed = NumberRange.new(800, 1000)
    Crescents.Rotation = NumberRange.new(-360, 360)
    Crescents.Orientation = Enum.ParticleOrientation.VelocityPerpendicular

    local ParticleEmitter2 = Instance.new("ParticleEmitter", cosmicAtt)
    ParticleEmitter2.Name = "ParticleEmitter2"
    ParticleEmitter2.FlipbookFramerate = NumberRange.new(20, 20)
    ParticleEmitter2.Lifetime = NumberRange.new(0.19, 0.38)
    ParticleEmitter2.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
    ParticleEmitter2.SpreadAngle = Vector2.new(360, 360)
    ParticleEmitter2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.209842, 0.5), NumberSequenceKeypoint.new(0.503842, 0.263333), NumberSequenceKeypoint.new(0.799842, 0.5), NumberSequenceKeypoint.new(1, 1)})
    ParticleEmitter2.LightEmission = 1
    ParticleEmitter2.Color = ColorSequence.new(Color3.fromRGB(173, 82, 252))
    ParticleEmitter2.VelocitySpread = 360
    ParticleEmitter2.Speed = NumberRange.new(0.0161231, 0.0161231)
    ParticleEmitter2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 4.3125), NumberSequenceKeypoint.new(0.3985056, 7.9375), NumberSequenceKeypoint.new(1, 10)})
    ParticleEmitter2.Enabled = false
    ParticleEmitter2.ZOffset = 0.15
    ParticleEmitter2.Rate = 100
    ParticleEmitter2.Texture = "http://www.roblox.com/asset/?id=12394566430"
    ParticleEmitter2.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    ParticleEmitter2.Rotation = NumberRange.new(39, 999)
    ParticleEmitter2.Orientation = Enum.ParticleOrientation.VelocityParallel

    HitEffects["Cosmic Explosion"] = cosmicAtt

    -- ====== Coom ======
    local coomPart = Instance.new("Part")
    coomPart.Name = "Coom"
    coomPart.Parent = container
    local coomAtt = Instance.new("Attachment", coomPart)
    coomAtt.Name = "HitEffectAttachment"

    local Foam = Instance.new("ParticleEmitter", coomAtt)
    Foam.Name = "Foam"
    Foam.LightInfluence = 0.5
    Foam.Lifetime = NumberRange.new(1, 1)
    Foam.SpreadAngle = Vector2.new(360, -360)
    Foam.VelocitySpread = 360
    Foam.Squash = NumberSequence.new(1)
    Foam.Speed = NumberRange.new(20, 20)
    Foam.Brightness = 2.5
    Foam.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.1016692, 0.6508875, 0.6508875), NumberSequenceKeypoint.new(0.6494689, 1.4201183, 0.4127519), NumberSequenceKeypoint.new(1, 0)})
    Foam.Enabled = false
    Foam.Acceleration = Vector3.new(0, -66.04029846191406, 0)
    Foam.Rate = 100
    Foam.Texture = "rbxassetid://8297030850"
    Foam.Rotation = NumberRange.new(-90, -90)
    Foam.Orientation = Enum.ParticleOrientation.VelocityParallel

    HitEffects["Coom"] = coomAtt

    -- ====== Slash ======
    local slashPart = Instance.new("Part")
    slashPart.Name = "Slash"
    slashPart.Parent = container
    local slashAtt = Instance.new("Attachment", slashPart)
    slashAtt.Name = "HitEffectAttachment"

    local Crescents = Instance.new("ParticleEmitter", slashAtt)
    Crescents.Name = "Crescents"
    Crescents.Lifetime = NumberRange.new(0.19, 0.38)
    Crescents.SpreadAngle = Vector2.new(-360, 360)
    Crescents.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1932907, 0), NumberSequenceKeypoint.new(0.778754, 0), NumberSequenceKeypoint.new(1, 1)})
    Crescents.LightEmission = 10
    Crescents.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.fromRGB(160, 96, 255)), ColorSequenceKeypoint.new(0.3160622, Color3.fromRGB(160, 96, 255)), ColorSequenceKeypoint.new(0.5146805, Color3.fromRGB(154, 82, 255)), ColorSequenceKeypoint.new(1, Color3.fromRGB(160, 96, 255))})
    Crescents.VelocitySpread = -360
    Crescents.Speed = NumberRange.new(0.0826858, 0.0826858)
    Crescents.Brightness = 4
    Crescents.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.398774, 8.8026266, 2.2834616), NumberSequenceKeypoint.new(1, 11.477972, 1.860431)})
    Crescents.Enabled = false
    Crescents.ZOffset = 0.4542207
    Crescents.Rate = 50
    Crescents.Texture = "rbxassetid://12509373457"
    Crescents.RotSpeed = NumberRange.new(800, 1000)
    Crescents.Rotation = NumberRange.new(-360, 360)
    Crescents.Orientation = Enum.ParticleOrientation.VelocityPerpendicular

    HitEffects["Slash"] = slashAtt

    -- ====== Atomic Slash ======
    local atomicPart = Instance.new("Part")
    atomicPart.Name = "Atomic Slash"
    atomicPart.Parent = container
    local atomicAtt = Instance.new("Attachment", atomicPart)
    atomicAtt.Name = "HitEffectAttachment"

    local Crescents = Instance.new("ParticleEmitter", atomicAtt)
    Crescents.Name = "Crescents"
    Crescents.Lifetime = NumberRange.new(0.19, 0.38)
    Crescents.SpreadAngle = Vector2.new(-360, 360)
    Crescents.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1932907, 0), NumberSequenceKeypoint.new(0.778754, 0), NumberSequenceKeypoint.new(1, 1)})
    Crescents.LightEmission = 10
    Crescents.Color = ColorSequence.new(Color3.fromRGB(160, 96, 255))
    Crescents.VelocitySpread = -360
    Crescents.Speed = NumberRange.new(0.0826858, 0.0826858)
    Crescents.Brightness = 4
    Crescents.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.398774, 8.8026266, 2.2834616), NumberSequenceKeypoint.new(1, 11.477972, 1.860431)})
    Crescents.Enabled = false
    Crescents.ZOffset = 0.4542207
    Crescents.Rate = 50
    Crescents.Texture = "rbxassetid://12509373457"
    Crescents.RotSpeed = NumberRange.new(800, 1000)
    Crescents.Rotation = NumberRange.new(-360, 360)
    Crescents.Orientation = Enum.ParticleOrientation.VelocityPerpendicular

    local Glow = Instance.new("ParticleEmitter", atomicAtt)
    Glow.Name = "Glow"
    Glow.Lifetime = NumberRange.new(0.16, 0.16)
    Glow.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1421725, 0.6182796), NumberSequenceKeypoint.new(1, 1)})
    Glow.Color = ColorSequence.new(Color3.fromRGB(173, 82, 252))
    Glow.Speed = NumberRange.new(0, 0)
    Glow.Brightness = 5
    Glow.Size = NumberSequence.new(9.1873131, 16.5032349)
    Glow.Enabled = false
    Glow.ZOffset = -0.0565939
    Glow.Rate = 50
    Glow.Texture = "rbxassetid://8708637750"

    local Effect = Instance.new("ParticleEmitter", atomicAtt)
    Effect.Name = "Effect"
    Effect.Lifetime = NumberRange.new(0.4, 0.7)
    Effect.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
    Effect.SpreadAngle = Vector2.new(360, -360)
    Effect.LockedToPart = true
    Effect.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1070999, 0.19375), NumberSequenceKeypoint.new(0.7761194, 0.88125), NumberSequenceKeypoint.new(1, 1)})
    Effect.LightEmission = 1
    Effect.Color = ColorSequence.new(Color3.fromRGB(173, 82, 252))
    Effect.Drag = 1
    Effect.VelocitySpread = 360
    Effect.Speed = NumberRange.new(0.0036749, 0.0036749)
    Effect.Brightness = 2.0999999
    Effect.Size = NumberSequence.new(6.9680691, 9.9213123)
    Effect.Enabled = false
    Effect.ZOffset = 0.4777403
    Effect.Rate = 50
    Effect.Texture = "rbxassetid://9484012464"
    Effect.RotSpeed = NumberRange.new(-150, -150)
    Effect.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    Effect.Rotation = NumberRange.new(50, 50)
    Effect.Orientation = Enum.ParticleOrientation.VelocityPerpendicular

    local Gradient1 = Instance.new("ParticleEmitter", atomicAtt)
    Gradient1.Name = "Gradient1"
    Gradient1.Lifetime = NumberRange.new(0.3, 0.3)
    Gradient1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.15, 0.3), NumberSequenceKeypoint.new(1, 1)})
    Gradient1.Color = ColorSequence.new(Color3.fromRGB(173, 82, 252))
    Gradient1.Speed = NumberRange.new(0, 0)
    Gradient1.Brightness = 6
    Gradient1.Size = NumberSequence.new(0, 11.6261358)
    Gradient1.Enabled = false
    Gradient1.ZOffset = 0.9187313
    Gradient1.Rate = 50
    Gradient1.Texture = "rbxassetid://8196169974"

    local Shards = Instance.new("ParticleEmitter", atomicAtt)
    Shards.Name = "Shards"
    Shards.Lifetime = NumberRange.new(0.19, 0.7)
    Shards.SpreadAngle = Vector2.new(-90, 90)
    Shards.Color = ColorSequence.new(Color3.fromRGB(179, 145, 253))
    Shards.Drag = 10
    Shards.VelocitySpread = -90
    Shards.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5705521, 0.4125001), NumberSequenceKeypoint.new(1, -0.9375)})
    Shards.Speed = NumberRange.new(97.7530136, 146.9970093)
    Shards.Brightness = 4
    Shards.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.284774, 1.2389833, 0.1534118), NumberSequenceKeypoint.new(1, 0)})
    Shards.Enabled = false
    Shards.Acceleration = Vector3.new(0, -56.961341857910156, 0)
    Shards.ZOffset = 0.5705321
    Shards.Rate = 50
    Shards.Texture = "rbxassetid://8030734851"
    Shards.Rotation = NumberRange.new(90, 90)
    Shards.Orientation = Enum.ParticleOrientation.VelocityParallel

    HitEffects["Atomic Slash"] = atomicAtt

    -- ====== Thunder ======
    local thunderPart = Instance.new("Part")
    thunderPart.Name = "Thunder"
    thunderPart.Parent = container
    local thunderAtt = Instance.new("Attachment", thunderPart)
    thunderAtt.Name = "HitEffectAttachment"

    local RESIDUE = Instance.new("ParticleEmitter", thunderAtt)
    RESIDUE.Name = "RESIDUE"
    RESIDUE.Acceleration = Vector3.new(0, -25, 0)
    RESIDUE.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 105, 170)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 105, 170))
    }
    RESIDUE.Drag = 2
    RESIDUE.Lifetime = NumberRange.new(0.25, 0.5)
    RESIDUE.LightEmission = 1
    RESIDUE.Orientation = Enum.ParticleOrientation.VelocityParallel
    RESIDUE.Rate = 100
    RESIDUE.Rotation = NumberRange.new(90, 90)
    RESIDUE.Size = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 2),
        NumberSequenceKeypoint.new(1, 0)
    }
    RESIDUE.Speed = NumberRange.new(25, 50)
    RESIDUE.SpreadAngle = Vector2.new(-90, 90)
    RESIDUE.Squash = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(1, 0)
    }
    RESIDUE.Texture = "rbxassetid://4509687978"
    RESIDUE.Transparency = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.25, 1),
        NumberSequenceKeypoint.new(1, 1)
    }
    RESIDUE.Enabled = false

    local ELECTRIC = Instance.new("ParticleEmitter", thunderAtt)
    ELECTRIC.Name = "ELECTRIC"
    ELECTRIC.Brightness = 3
    ELECTRIC.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 134, 199)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 134, 199))
    }
    ELECTRIC.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid8x8
    ELECTRIC.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    ELECTRIC.Lifetime = NumberRange.new(0.5, 1)
    ELECTRIC.LightEmission = 2
    ELECTRIC.Orientation = Enum.ParticleOrientation.FacingCameraWorldUp
    ELECTRIC.Rate = 12
    ELECTRIC.Size = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 25),
        NumberSequenceKeypoint.new(1, 0)
    }
    ELECTRIC.Speed = NumberRange.new(0, 0)
    ELECTRIC.SpreadAngle = Vector2.new(-360, 360)
    ELECTRIC.Texture = "rbxassetid://10547286472"
    ELECTRIC.Transparency = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.25, 1),
        NumberSequenceKeypoint.new(1, 1)
    }
    ELECTRIC.Enabled = false

    local SMOKE = Instance.new("ParticleEmitter", thunderAtt)
    SMOKE.Name = "SMOKE"
    SMOKE.Acceleration = Vector3.new(0, 5, 1)
    SMOKE.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0.196078, 0.196078, 0.196078)),
        ColorSequenceKeypoint.new(1, Color3.new(0.196078, 0.196078, 0.196078))
    })
    SMOKE.Drag = 1
    SMOKE.FlipbookFramerate = NumberRange.new(25, 25)
    SMOKE.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid8x8
    SMOKE.LightInfluence = 1
    SMOKE.Rate = 10
    SMOKE.RotSpeed = NumberRange.new(-15, 15)
    SMOKE.Rotation = NumberRange.new(-360, 360)
    SMOKE.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 4, 0),
        NumberSequenceKeypoint.new(1, 8, 2)
    })
    SMOKE.Speed = NumberRange.new(1, 1)
    SMOKE.Texture = "rbxassetid://8073306083"
    SMOKE.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1, 0),
        NumberSequenceKeypoint.new(0.5, 0.75, 0),
        NumberSequenceKeypoint.new(1, 1, 0)
    })
    SMOKE.Enabled = false

    HitEffects["Thunder"] = thunderAtt

    -- ====== Electric ======
    local electricPart = Instance.new("Part")
    electricPart.Name = "Electric"
    electricPart.Parent = container
    local electricAtt = Instance.new("Attachment", electricPart)
    electricAtt.Name = "HitEffectAttachment"

    local ELECTRIC1 = Instance.new('ParticleEmitter', electricAtt)
    ELECTRIC1.Name = "ELECTRIC1"
    ELECTRIC1.Brightness = 5
    ELECTRIC1.Color = ColorSequence.new(Color3.fromRGB(0, 134, 199))
    ELECTRIC1.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid8x8
    ELECTRIC1.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    ELECTRIC1.Lifetime = NumberRange.new(1)
    ELECTRIC1.LightEmission = 1
    ELECTRIC1.Rate = 5
    ELECTRIC1.Size = NumberSequence.new(2)
    ELECTRIC1.Speed = NumberRange.new(0)
    ELECTRIC1.SpreadAngle = Vector2.new(-360, 360)
    ELECTRIC1.Texture = "http://www.roblox.com/asset/?id=12390063093"
    ELECTRIC1.Transparency = NumberSequence.new(0, 1)
    ELECTRIC1.Enabled = false

    local ELECTRIC2 = Instance.new('ParticleEmitter', electricAtt)
    ELECTRIC2.Name = "ELECTRIC2"
    ELECTRIC2.Color = ColorSequence.new(Color3.fromRGB(0, 134, 199))
    ELECTRIC2.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid8x8
    ELECTRIC2.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    ELECTRIC2.Lifetime = NumberRange.new(0.25, 0.5)
    ELECTRIC2.LightEmission = 1
    ELECTRIC2.Rate = 25
    ELECTRIC2.Rotation = NumberRange.new(-360, 360)
    ELECTRIC2.Size = NumberSequence.new(2)
    ELECTRIC2.Speed = NumberRange.new(0)
    ELECTRIC2.SpreadAngle = Vector2.new(-360, 360)
    ELECTRIC2.Texture = "http://www.roblox.com/asset/?id=12390081661"
    ELECTRIC2.Transparency = NumberSequence.new(0, 1)
    ELECTRIC2.Enabled = false

    local ELECTRIC3 = Instance.new('ParticleEmitter', electricAtt)
    ELECTRIC3.Name = "ELECTRIC3"
    ELECTRIC3.Color = ColorSequence.new(Color3.fromRGB(0, 134, 199))
    ELECTRIC3.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid8x8
    ELECTRIC3.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    ELECTRIC3.Lifetime = NumberRange.new(0.25, 0.5)
    ELECTRIC3.LightEmission = 1
    ELECTRIC3.Rate = 25
    ELECTRIC3.Rotation = NumberRange.new(-360, 360)
    ELECTRIC3.Size = NumberSequence.new(2)
    ELECTRIC3.Speed = NumberRange.new(0)
    ELECTRIC3.SpreadAngle = Vector2.new(-360, 360)
    ELECTRIC3.Texture = "http://www.roblox.com/asset/?id=12390081661"
    ELECTRIC3.Transparency = NumberSequence.new(0, 1)
    ELECTRIC3.Enabled = false

    local Wave1 = Instance.new('ParticleEmitter', electricAtt)
    Wave1.Name = "Wave1"
    Wave1.Brightness = 10
    Wave1.Color = ColorSequence.new(Color3.fromRGB(0, 170, 255))
    Wave1.Lifetime = NumberRange.new(1)
    Wave1.LightEmission = 0.4
    Wave1.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
    Wave1.Rate = 10
    Wave1.RotSpeed = NumberRange.new(200, 400)
    Wave1.Rotation = NumberRange.new(-180, 180)
    Wave1.Size = NumberSequence.new(3)
    Wave1.Speed = NumberRange.new(1, 3)
    Wave1.SpreadAngle = Vector2.new(10, -10)
    Wave1.Texture = "rbxassetid://8047533775"
    Wave1.Transparency = NumberSequence.new(0, 1)
    Wave1.Enabled = false

    local ELECTRIC4 = Instance.new('ParticleEmitter', electricAtt)
    ELECTRIC4.Name = "ELECTRIC4"
    ELECTRIC4.Color = ColorSequence.new(Color3.fromRGB(0, 134, 199))
    ELECTRIC4.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid8x8
    ELECTRIC4.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    ELECTRIC4.Lifetime = NumberRange.new(0.25, 0.5)
    ELECTRIC4.LightEmission = 1
    ELECTRIC4.Rate = 25
    ELECTRIC4.Rotation = NumberRange.new(-360, 360)
    ELECTRIC4.Size = NumberSequence.new(2)
    ELECTRIC4.Speed = NumberRange.new(0)
    ELECTRIC4.SpreadAngle = Vector2.new(-360, 360)
    ELECTRIC4.Texture = "http://www.roblox.com/asset/?id=12390081661"
    ELECTRIC4.Transparency = NumberSequence.new(0, 1)
    ELECTRIC4.Enabled = false

    HitEffects["Electric"] = electricAtt

    -- ====== Circle ======
    local circlePart = Instance.new("Part")
    circlePart.Name = "Circle"
    circlePart.Parent = container
    local circleAtt = Instance.new("Attachment", circlePart)
    circleAtt.Name = "HitEffectAttachment"

    local Circle = Instance.new("ParticleEmitter", circleAtt)
    Circle.Name = "Circle"
    Circle.Brightness = 9.335
    Circle.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0.6, 0.894118, 1)),
        ColorSequenceKeypoint.new(1, Color3.new(0.472546, 0.227451, 0.858824))
    })
    Circle.Lifetime = NumberRange.new(0.3, 0.3)
    Circle.LightEmission = 1
    Circle.Rate = 4
    Circle.RotSpeed = NumberRange.new(4, 4)
    Circle.Rotation = NumberRange.new(-360, 360)
    Circle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Inward
    Circle.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 5.8125)
    })
    Circle.Speed = NumberRange.new(0, 0)
    Circle.Texture = "rbxassetid://8096254696"
    Circle.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(1, 0)
    })
    Circle.Enabled = false

    local Center2 = Instance.new("ParticleEmitter", circleAtt)
    Center2.Name = "Center2"
    Center2.Brightness = 9.335
    Center2.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0.6, 0.894118, 1)),
        ColorSequenceKeypoint.new(1, Color3.new(0.472546, 0.227451, 0.858824))
    })
    Center2.Lifetime = NumberRange.new(0.2, 0.2)
    Center2.LightEmission = 1
    Center2.Rate = 1
    Center2.RotSpeed = NumberRange.new(4, 4)
    Center2.Rotation = NumberRange.new(-360, 360)
    Center2.ShapeInOut = Enum.ParticleEmitterShapeInOut.Inward
    Center2.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 2.4375),
        NumberSequenceKeypoint.new(1, 5.88)
    })
    Center2.Speed = NumberRange.new(0, 0)
    Center2.Texture = "rbxassetid://8096224517"
    Center2.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(1, 0)
    })
    Center2.Enabled = false

    local Circle2 = Instance.new("ParticleEmitter", circleAtt)
    Circle2.Name = "Circle"
    Circle2.Brightness = 9.335
    Circle2.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0.6, 0.894118, 1)),
        ColorSequenceKeypoint.new(1, Color3.new(0.472546, 0.227451, 0.858824))
    })
    Circle2.Lifetime = NumberRange.new(0.3, 0.3)
    Circle2.LightEmission = 1
    Circle2.Rate = 4
    Circle2.RotSpeed = NumberRange.new(4, 4)
    Circle2.Rotation = NumberRange.new(-360, 360)
    Circle2.ShapeInOut = Enum.ParticleEmitterShapeInOut.Inward
    Circle2.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.600223, 5.75),
        NumberSequenceKeypoint.new(1, 5.8125)
    })
    Circle2.Speed = NumberRange.new(0, 0)
    Circle2.Texture = "rbxassetid://8096254696"
    Circle2.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(0.518931, 0),
        NumberSequenceKeypoint.new(0.699332, 0),
        NumberSequenceKeypoint.new(1, 0)
    })
    Circle2.Enabled = false

    local Beams = Instance.new("ParticleEmitter", circleAtt)
    Beams.Name = "Beams"
    Beams.Brightness = 9.335
    Beams.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0.6, 0.894118, 1)),
        ColorSequenceKeypoint.new(1, Color3.new(0.472546, 0.227451, 0.858824))
    })
    Beams.Lifetime = NumberRange.new(0.15, 0.15)
    Beams.LightEmission = 1
    Beams.Rate = 4
    Beams.RotSpeed = NumberRange.new(4, 4)
    Beams.Rotation = NumberRange.new(-360, 360)
    Beams.ShapeInOut = Enum.ParticleEmitterShapeInOut.Inward
    Beams.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.598552, 5.0625),
        NumberSequenceKeypoint.new(1, 10)
    })
    Beams.Speed = NumberRange.new(0, 0)
    Beams.Texture = "rbxassetid://8096273877"
    Beams.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(0.518931, 0),
        NumberSequenceKeypoint.new(0.699332, 0),
        NumberSequenceKeypoint.new(1, 0)
    })
    Beams.Enabled = false

    local HITPE = Instance.new("ParticleEmitter", circleAtt)
    HITPE.Name = "HITPE"
    HITPE.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(1, 0.666667, 1)),
        ColorSequenceKeypoint.new(1, Color3.new(1, 0.666667, 1))
    })
    HITPE.Drag = 5
    HITPE.Lifetime = NumberRange.new(0.3, 0.3)
    HITPE.LightEmission = 1
    HITPE.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
    HITPE.Rate = 30
    HITPE.RotSpeed = NumberRange.new(-720, 720)
    HITPE.Rotation = NumberRange.new(-720, 720)
    HITPE.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(1, 4)
    })
    HITPE.Speed = NumberRange.new(0, 1)
    HITPE.SpreadAngle = Vector2.new(180, 180)
    HITPE.Texture = "http://www.roblox.com/asset/?id=7015983157"
    HITPE.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 1)
    })
    HITPE.ZOffset = 1
    HITPE.Enabled = false

    local ParticleEmitter = Instance.new("ParticleEmitter", circleAtt)
    ParticleEmitter.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(1, 0.980392, 0.670588)),
        ColorSequenceKeypoint.new(1, Color3.new(1, 0.980392, 0.670588))
    })
    ParticleEmitter.Lifetime = NumberRange.new(0.128, 0.128)
    ParticleEmitter.LightEmission = 1
    ParticleEmitter.Rate = 5
    ParticleEmitter.Rotation = NumberRange.new(-360, 360)
    ParticleEmitter.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 5.75)
    })
    ParticleEmitter.Speed = NumberRange.new(0, 0)
    ParticleEmitter.Texture = "http://www.roblox.com/asset/?id=7016047535"
    ParticleEmitter.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.629005, 0.83125),
        NumberSequenceKeypoint.new(1, 1)
    })
    ParticleEmitter.ZOffset = 1.5
    ParticleEmitter.Enabled = false

    local ParticleEmitter33 = Instance.new("ParticleEmitter", circleAtt)
    ParticleEmitter33.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(1, 0.980392, 0.670588)),
        ColorSequenceKeypoint.new(1, Color3.new(1, 0.980392, 0.670588))
    })
    ParticleEmitter33.Lifetime = NumberRange.new(0.128, 0.128)
    ParticleEmitter33.LightEmission = 1
    ParticleEmitter33.Rate = 5
    ParticleEmitter33.Rotation = NumberRange.new(-360, 360)
    ParticleEmitter33.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 5.75)
    })
    ParticleEmitter33.Speed = NumberRange.new(0, 0)
    ParticleEmitter33.Texture = "http://www.roblox.com/asset/?id=7016047535"
    ParticleEmitter33.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.629005, 0.83125),
        NumberSequenceKeypoint.new(1, 1)
    })
    ParticleEmitter33.ZOffset = 1.5
    ParticleEmitter33.Enabled = false

    HitEffects["Circle"] = circleAtt

    -- ====== Shock3 ======
    local shock3Part = Instance.new("Part")
    shock3Part.Name = "Shock3"
    shock3Part.Parent = container
    local shock3Att = Instance.new("Attachment", shock3Part)
    shock3Att.Name = "HitEffectAttachment"

    local Shock3 = Instance.new('ParticleEmitter', shock3Att)
    Shock3.Name = "Shock3"
    Shock3.Brightness = 2
    Shock3.Color = ColorSequence.new(Color3.fromRGB(0, 193, 85), Color3.fromRGB(0, 193, 85))
    Shock3.Enabled = false
    Shock3.Lifetime = NumberRange.new(0.3, 0.5)
    Shock3.LightEmission = 1
    Shock3.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
    Shock3.Rate = 7
    Shock3.RotSpeed = NumberRange.new(-50, 50)
    Shock3.Rotation = NumberRange.new(0, 360)
    Shock3.Size = NumberSequence.new(0, 0, 0, 0.2, 5, 0, 0.5, 8, 0, 1, 10, 0)
    Shock3.Speed = NumberRange.new(0.001, 0.001)
    Shock3.SpreadAngle = Vector2.new(180, 180)
    Shock3.Texture = "rbxassetid://9533206597"
    Shock3.Transparency = NumberSequence.new(0, 0, 0, 1, 1, 0)

    local Shock4 = Instance.new('ParticleEmitter', shock3Att)
    Shock4.Name = "Shock4"
    Shock4.Brightness = 2
    Shock4.Color = ColorSequence.new(Color3.fromRGB(0, 193, 85), Color3.fromRGB(0, 193, 85))
    Shock4.Enabled = false
    Shock4.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
    Shock4.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    Shock4.Lifetime = NumberRange.new(0.3, 0.5)
    Shock4.LightEmission = 1
    Shock4.Rate = 7
    Shock4.RotSpeed = NumberRange.new(-10, 10)
    Shock4.Rotation = NumberRange.new(0, 360)
    Shock4.Size = NumberSequence.new(0, 20, 0, 1, 20, 0)
    Shock4.Speed = NumberRange.new(0, 0)
    Shock4.Texture = "rbxassetid://10198434999"
    Shock4.Transparency = NumberSequence.new(0, 0, 0, 0.5, 0.2, 0, 1, 1, 0)

    local Shock5 = Instance.new('ParticleEmitter', shock3Att)
    Shock5.Name = "Shock5"
    Shock5.Brightness = 2
    Shock5.Color = ColorSequence.new(Color3.fromRGB(0, 193, 85), Color3.fromRGB(0, 193, 85))
    Shock5.Enabled = false
    Shock5.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    Shock5.Lifetime = NumberRange.new(0.3, 0.5)
    Shock5.LightEmission = 1
    Shock5.Rate = 7
    Shock5.RotSpeed = NumberRange.new(-50, 50)
    Shock5.Rotation = NumberRange.new(0, 360)
    Shock5.Size = NumberSequence.new(0, 10, 0, 0.5, 2, 0, 1, 0, 0)
    Shock5.Speed = NumberRange.new(0, 0)
    Shock5.Texture = "rbxassetid://7216849703"
    Shock5.ZOffset = 1

    HitEffects["Shock3"] = shock3Att

    -- ====== Aura ======
    local auraPart = Instance.new("Part")
    auraPart.Name = "Aura"
    auraPart.Parent = container
    local auraAtt = Instance.new("Attachment", auraPart)
    auraAtt.Name = "HitEffectAttachment"

    local SPIKES = Instance.new("ParticleEmitter", auraAtt)
    SPIKES.Name = "SPIKES"
    SPIKES.Acceleration = Vector3.new(0, 100, 0)
    SPIKES.Color = ColorSequence.new(Color3.new(0, 1, 0), Color3.new(0, 1, 0))
    SPIKES.Drag = 3
    SPIKES.EmissionDirection = Enum.NormalId.Right
    SPIKES.Lifetime = NumberRange.new(0.25, 0.5)
    SPIKES.LightEmission = 1
    SPIKES.Orientation = Enum.ParticleOrientation.VelocityParallel
    SPIKES.Rate = 100
    SPIKES.Rotation = NumberRange.new(-90, -90)
    SPIKES.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 2, 0),
        NumberSequenceKeypoint.new(0.25, 3, 0.25),
        NumberSequenceKeypoint.new(0.653846, 2.0625, 0.164957),
        NumberSequenceKeypoint.new(1, 0, 0)
    })
    SPIKES.Speed = NumberRange.new(10, 25)
    SPIKES.SpreadAngle = Vector2.new(0, 180)
    SPIKES.Squash = NumberSequence.new({
        NumberSequenceKeypoint.new(0, -0.25),
        NumberSequenceKeypoint.new(1, 0.5),
        NumberSequenceKeypoint.new(1, 0.25)
    })
    SPIKES.Texture = "rbxassetid://7451697448"
    SPIKES.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(0.25, 0),
        NumberSequenceKeypoint.new(1, 1)
    })
    SPIKES.Enabled = false

    local SPECKS = Instance.new("ParticleEmitter", auraAtt)
    SPECKS.Name = "SPECKS"
    SPECKS.Acceleration = Vector3.new(0, -25, 0)
    SPECKS.Brightness = 2
    SPECKS.Color = ColorSequence.new(Color3.new(0, 1, 0), Color3.new(0, 1, 0))
    SPECKS.Drag = 5
    SPECKS.Lifetime = NumberRange.new(0.375, 0.625)
    SPECKS.LightEmission = 1
    SPECKS.Rate = 100
    SPECKS.RotSpeed = NumberRange.new(-45, 45)
    SPECKS.Rotation = NumberRange.new(-360, 360)
    SPECKS.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.25),
        NumberSequenceKeypoint.new(1, 0)
    })
    SPECKS.Speed = NumberRange.new(25, 50)
    SPECKS.SpreadAngle = Vector2.new(45, 45)
    SPECKS.Squash = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 1)
    })
    SPECKS.Texture = "rbxassetid://4509687978"
    SPECKS.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(0.25, 0.2),
        NumberSequenceKeypoint.new(1, 1)
    })
    SPECKS.Enabled = false

    local GLOW = Instance.new("ParticleEmitter", auraAtt)
    GLOW.Name = "GLOW"
    GLOW.Acceleration = Vector3.new(0, 5, 0)
    GLOW.Color = ColorSequence.new(Color3.new(0, 1, 0), Color3.new(0, 1, 0))
    GLOW.Lifetime = NumberRange.new(0.5, 1)
    GLOW.LightEmission = 1
    GLOW.Rate = 50
    GLOW.Rotation = NumberRange.new(-360, 360)
    GLOW.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 8),
        NumberSequenceKeypoint.new(1, 3)
    })
    GLOW.Speed = NumberRange.new(10, 25)
    GLOW.Texture = "rbxassetid://4509687978"
    GLOW.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(0.5, 0.95),
        NumberSequenceKeypoint.new(1, 1)
    })
    GLOW.ZOffset = -1
    GLOW.Enabled = false

    HitEffects["Aura"] = auraAtt

    -- ====== IDK ======
    local idkPart = Instance.new("Part")
    idkPart.Name = "IDK"
    idkPart.Parent = container
    local idkAtt = Instance.new("Attachment", idkPart)
    idkAtt.Name = "HitEffectAttachment"

    local Traces = Instance.new("ParticleEmitter", idkAtt)
    Traces.Name = "Traces"
    Traces.Brightness = 4.89
    Traces.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(1, Color3.new(0.219608, 0.792157, 1))
    })
    Traces.Lifetime = NumberRange.new(0.2, 0.2)
    Traces.LightEmission = 1
    Traces.Orientation = Enum.ParticleOrientation.VelocityParallel
    Traces.Rate = 30
    Traces.Rotation = NumberRange.new(-90, -90)
    Traces.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 5.375)
    })
    Traces.Speed = NumberRange.new(50, 50)
    Traces.SpreadAngle = Vector2.new(-360, 360)
    Traces.Squash = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.4),
        NumberSequenceKeypoint.new(1, 0.4)
    })
    Traces.Texture = "rbxassetid://8099322194"
    Traces.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(1, 0)
    })
    Traces.Enabled = false

    HitEffects["IDK"] = idkAtt

    -- ====== Swirl ======
    local swirlPart = Instance.new("Part")
    swirlPart.Name = "Swirl"
    swirlPart.Parent = container
    local swirlAtt = Instance.new("Attachment", swirlPart)
    swirlAtt.Name = "HitEffectAttachment"

    local swirl = Instance.new("ParticleEmitter", swirlAtt)
    swirl.Name = "swirl"
    swirl.Color = ColorSequence.new(Color3.fromRGB(66, 60, 255), Color3.fromRGB(66, 60, 255))
    swirl.Lifetime = NumberRange.new(2, 2)
    swirl.LightEmission = 1
    swirl.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
    swirl.Rate = 150
    swirl.RotSpeed = NumberRange.new(200, 200)
    swirl.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 7),
        NumberSequenceKeypoint.new(1, 7)
    })
    swirl.Speed = NumberRange.new(0.01, 0.01)
    swirl.SpreadAngle = Vector2.new(-360, 360)
    swirl.Squash = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.163934, 1),
        NumberSequenceKeypoint.new(1, 0)
    })
    swirl.Texture = "rbxassetid://10558425570"
    swirl.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.500623, 0.5),
        NumberSequenceKeypoint.new(1, 1)
    })
    swirl.ZOffset = -1
    swirl.Enabled = false

    HitEffects["Swirl"] = swirlAtt

    -- ====== AuraBurst ======
    local auraBurstPart = Instance.new("Part")
    auraBurstPart.Name = "AuraBurst"
    auraBurstPart.Parent = container
    local auraBurstAtt = Instance.new("Attachment", auraBurstPart)
    auraBurstAtt.Name = "HitEffectAttachment"

    local auraburst2 = Instance.new("ParticleEmitter", auraBurstAtt)
    auraburst2.Name = "auraburst2"
    auraburst2.Brightness = 25
    auraburst2.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 0))
    })
    auraburst2.EmissionDirection = Enum.NormalId.Top
    auraburst2.Enabled = false
    auraburst2.FlipbookFramerate = NumberRange.new(289.311, 289.311)
    auraburst2.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
    auraburst2.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    auraburst2.Lifetime = NumberRange.new(0.500, 0.500)
    auraburst2.LightEmission = 1
    auraburst2.LightInfluence = 0.15
    auraburst2.Orientation = Enum.ParticleOrientation.VelocityParallel
    auraburst2.Rate = 6.615
    auraburst2.Rotation = NumberRange.new(360, 360)
    auraburst2.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 8.7832),
        NumberSequenceKeypoint.new(1, 8.7832)
    })
    auraburst2.Speed = NumberRange.new(0.00973265, 0.00973265)
    auraburst2.Squash = NumberSequence.new({
        NumberSequenceKeypoint.new(0, -0.5),
        NumberSequenceKeypoint.new(1, -0.5)
    })
    auraburst2.Texture = "rbxassetid://17282066926"
    auraburst2.ZOffset = -1

    HitEffects["AuraBurst"] = auraBurstAtt
end

local function playHitEffect(plr)
    if not plr or not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then return end
    if not matchacc.HitEffects.HitEffect.Enabled then return end

    local effectTypes = matchacc.HitEffects.HitEffect.Type
    if type(effectTypes) ~= "table" then
        effectTypes = {effectTypes}
    end

    for _, effectName in ipairs(effectTypes) do
        if effectName == "None" or not HitEffects[effectName] then continue end

        local hrp = plr.Character.HumanoidRootPart
        local template = workspace:FindFirstChild("MatchaHitEffects"):FindFirstChild(effectName)
        if not template then continue end

        local clonedAtt = template.HitEffectAttachment:Clone()
        clonedAtt.Parent = hrp
        for _, emitter in pairs(clonedAtt:GetChildren()) do
            if emitter:IsA("ParticleEmitter") then
                emitter.Enabled = true
                -- Cập nhật màu cho multi keypoints
                local originalColor = emitter.Color
                local newKeypoints = {}
                for _, keypoint in ipairs(originalColor.Keypoints) do
                    table.insert(newKeypoints, ColorSequenceKeypoint.new(keypoint.Time, matchacc.HitEffects.HitEffect.Color))
                end
                emitter.Color = ColorSequence.new(newKeypoints)

                emitter:Emit(emitter.Rate or 1)  -- Emit với Rate nếu có, fallback 1
            end
        end
        task.delay(2, function()
            if clonedAtt and clonedAtt.Parent then clonedAtt:Destroy() end
        end)
    end
end
local players = game:GetService("Players")
local Players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local UserInputService = game:GetService("UserInputService")
local possibleRemotes = { "MAINEVENT", "MainEvent", "Remote", "Packages", "MainRemotes", "Bullets" }
local function getMainRemote()
    if ReplicatedStorage:FindFirstChild("MainEvent") then return ReplicatedStorage.MainEvent end
    if ReplicatedStorage:FindFirstChild("MAINEVENT") then return ReplicatedStorage.MAINEVENT end
    if ReplicatedStorage:FindFirstChild("Remote") then return ReplicatedStorage.Remote end
    if ReplicatedStorage:FindFirstChild("Bullets") then return ReplicatedStorage.Bullets end
    -- MainRemotes.MainRemoteEvent
    local mainRemotes = ReplicatedStorage:FindFirstChild("MainRemotes")
    if mainRemotes and mainRemotes:FindFirstChild("MainRemoteEvent") then return mainRemotes.MainRemoteEvent end
    -- Packages.Knit.Services.ToolService.RE.UpdateAim
    local packages = ReplicatedStorage:FindFirstChild("Packages")
    if packages then
        local knit = packages:FindFirstChild("Knit")
        if knit and knit:FindFirstChild("Services") then
            local toolService = knit.Services:FindFirstChild("ToolService")
            if toolService and toolService:FindFirstChild("RE") then
                local re = toolService.RE
                if re:FindFirstChild("UpdateAim") then return re.UpdateAim end
            end
        end
    end
    -- fallback: không tìm thấy
    return nil
end

local MainEvent = getMainRemote()
local previousPositions = {}
local customVelocities = {}
local lastTarget = nil
local t = 0
local M1Down = false
local lastHealth = nil
local ka_lastHealth = {}
local hitsounds = {
    ["Bubble"] = "rbxassetid://6534947588",
    ["Lazer"] = "rbxassetid://130791043",
    ["Pick"] = "rbxassetid://1347140027",
    ["Pop"] = "rbxassetid://198598793",
    ["Rust"] = "rbxassetid://1255040462",
    ["Sans"] = "rbxassetid://3188795283",
    ["Fart"] = "rbxassetid://130833677",
    ["Big"] = "rbxassetid://5332005053",
    ["Vine"] = "rbxassetid://5332680810",
    ["UwU"] = "rbxassetid://8679659744",
    ["Bruh"] = "rbxassetid://4578740568",
    ["Skeet"] = "rbxassetid://5633695679",
    ["Neverlose"] = "rbxassetid://6534948092",
    ["Fatality"] = "rbxassetid://6534947869",
    ["Bonk"] = "rbxassetid://5766898159",
    ["Minecraft"] = "rbxassetid://5869422451",
    ["Gamesense"] = "rbxassetid://4817809188",
    ["RIFK7"] = "rbxassetid://9102080552",
    ["Bamboo"] = "rbxassetid://3769434519",
    ["Crowbar"] = "rbxassetid://546410481",
    ["Weeb"] = "rbxassetid://6442965016",
    ["Beep"] = "rbxassetid://8177256015",
    ["Bambi"] = "rbxassetid://8437203821",
    ["Stone"] = "rbxassetid://3581383408",
    ["Old Fatality"] = "rbxassetid://6607142036",
    ["Click"] = "rbxassetid://8053704437",
    ["Ding"] = "rbxassetid://7149516994",
    ["Snow"] = "rbxassetid://6455527632",
    ["Laser"] = "rbxassetid://7837461331",
    ["Mario"] = "rbxassetid://2815207981",
    ["Steve"] = "rbxassetid://4965083997",
    ["Call of Duty"] = "rbxassetid://5952120301",
    ["Bat"] = "rbxassetid://3333907347",
    ["TF2 Critical"] = "rbxassetid://296102734",
    ["Saber"] = "rbxassetid://8415678813",
    ["Baimware"] = "rbxassetid://3124331820",
    ["Osu"] = "rbxassetid://7149255551",
    ["TF2"] = "rbxassetid://2868331684",
    ["Slime"] = "rbxassetid://6916371803",
    ["Among Us"] = "rbxassetid://5700183626",
    ["One"] = "rbxassetid://7380502345"
}

local function isAlive(plr)
    if not plr or not plr.Character then return false end
    local hum = plr.Character:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then
        return false
    end

    local be = plr.Character:FindFirstChild("BodyEffects")
    if be then
        local ko = be:FindFirstChild("K.O")
        local grabbed = be:FindFirstChild("GRABBING_CONSTRAINT")
        if (ko and ko.Value) or (grabbed and grabbed.Value) then
            return false
        end
    end

    return true
end
local function isAlive2(plr)
    if not plr or not plr.Character then return false end
    local hum = plr.Character:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then
        return false
    end

    return true
end
local function KnockCheck(plr)
    if plr and plr.Character and plr.Character:FindFirstChild("BodyEffects") then
        local ko = plr.Character.BodyEffects:FindFirstChild("K.O")
        return ko and ko.Value or false
    end
    return false
end

local function GetClosestCharacter()
    local closestDist = math.huge
    local closestPlayer = nil
    local isMobile = UserInputService.TouchEnabled and not UserInputService.MouseEnabled
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in pairs(players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("Head") then
            if matchacc.Checks.Team and player.Team == localPlayer.Team then continue end
            if matchacc.Checks.Forcefield and player.Character:FindFirstChild("ForceField") then continue end
            if matchacc.Checks.Alive and not isAlive(player) then continue end

            local headPos, onScreen = Camera:WorldToViewportPoint(player.Character.Head.Position)
            local dist = (Vector2.new(headPos.X, headPos.Y) - mousePos).Magnitude if isMobile then dist = (player.Character.Head.Position - localPlayer.Character.Head.Position).Magnitude end

            if onScreen and dist < closestDist then
                if matchacc.Checks.Wall then
                    local ray = Ray.new(Camera.CFrame.Position, player.Character.Head.Position - Camera.CFrame.Position)
                    local hit = workspace:FindPartOnRayWithIgnoreList(ray, {localPlayer.Character})
                    if hit and hit:IsDescendantOf(player.Character) then
                        closestDist = dist
                        closestPlayer = player
                    end
                else
                    closestDist = dist
                    closestPlayer = player
                end
            end
        end
    end
    return closestPlayer
end

local function createHitSound()
    local sound = Instance.new("Sound")
    sound.Parent = localPlayer.Character.HumanoidRootPart
    sound.SoundId = matchacc.HitEffects.HitSoundID
    sound.Volume = matchacc.HitEffects.HitSoundVolume
    sound:Play()
    sound.Ended:Connect(function()
        sound:Destroy()
    end)
end

local function SetRigTransparency(clone, trans)
    for _, v in pairs(clone:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("MeshPart") then
            v.Transparency = trans
        end
    end
end

local function SetRigCollisionFalse(clone)
    for _, v in pairs(clone:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("MeshPart") then
            v.CanCollide = false
        end
    end
end

local function SetRigColor(clone, color)
    for _, v in pairs(clone:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("MeshPart") then
            v.Color = color
        end
    end
end

local MainTabBox = Tabs.Main:AddLeftTabbox()
local TargetAimTab = MainTabBox:AddTab('Target aim')
local ChecksTab = MainTabBox:AddTab('Checks')

TargetAimTab:AddToggle('TargetAimEnabled', {
    Text = 'Enabled',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.Enabled = Value
        if not Value then
            matchacc.TargetAim.Target = "None"
            tracer.Visible = false
            tracerOutline.Visible = false
            for _, player in pairs(players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("Highlight") and player.Character.Highlight.FillColor == matchacc.TargetAim.HighlightFillColor then
                    player.Character.Highlight:Destroy()
                end
            end
            SetRigTransparency(BodyClone, 1)
            DesyncLine.Visible = false
            BodyCloneHighlight.Enabled = false
            Camera.CameraSubject = localPlayer.Character.Humanoid
        end
    end
}):AddKeyPicker('TargetAimKey', {
    Default = 'Q',
    Text = 'Target Aim',
    Mode = 'Toggle',
    Callback = function(Value)
        if not matchacc.TargetAim.Enabled then return end
        if Value then
            local target = GetClosestCharacter()
            if target then
                matchacc.TargetAim.Target = target.Name
            else
                matchacc.TargetAim.Target = "None"
            end
        else
            matchacc.TargetAim.Target = "None"
            tracer.Visible = false
            tracerOutline.Visible = false
            for _, player in pairs(players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("Highlight") and player.Character.Highlight.FillColor == matchacc.TargetAim.HighlightFillColor then
                    player.Character.Highlight:Destroy()
                end
            end
            SetRigTransparency(BodyClone, 1)
            DesyncLine.Visible = false
            BodyCloneHighlight.Enabled = false
        end
    end
})

TargetAimTab:AddToggle('AutoSelect', {
    Text = 'Auto Select',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.AutoSelect = Value
        if Value then
            RunService:BindToRenderStep("AutoSelect", 1, function()
                local target = GetClosestCharacter()
                if lastTarget and lastTarget ~= target and lastTarget.Character then
                    local highlight = lastTarget.Character:FindFirstChild("Highlight")
                    if highlight then
                        highlight:Destroy()
                    end
                    tracer.Visible = false
                    tracerOutline.Visible = false
                end
                if target then
                    matchacc.TargetAim.Target = target.Name
                else
                    matchacc.TargetAim.Target = "None"
                end
                lastTarget = target
            end)
        else
            RunService:UnbindFromRenderStep("AutoSelect")
            if lastTarget and lastTarget.Character then
                local highlight = lastTarget.Character:FindFirstChild("Highlight")
                if highlight then
                    highlight:Destroy()
                end
                tracer.Visible = false
                tracerOutline.Visible = false
            end
            lastTarget = nil
            for _, player in pairs(players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("Highlight") and player.Character.Highlight.FillColor == matchacc.TargetAim.HighlightFillColor then
                    player.Character.Highlight:Destroy()
                end
            end
        end
    end
})

TargetAimTab:AddToggle('AutoFire', {
    Text = 'Auto Fire',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.AutoFire = Value
    end
})

TargetAimTab:AddToggle('Highlight', {
    Text = 'Highlight',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.Highlight = Value
        for _, player in pairs(players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("Highlight") and player.Character.Highlight.FillColor == matchacc.TargetAim.HighlightFillColor then
                player.Character.Highlight:Destroy()
            end
        end
    end
}):AddColorPicker('HighlightFill', {
    Default = matchacc.TargetAim.HighlightFillColor,
    Title = 'Fill Color',
    Callback = function(Value)
        matchacc.TargetAim.HighlightFillColor = Value
    end
}):AddColorPicker('HighlightOutline', {
    Default = matchacc.TargetAim.HighlightOutlineColor,
    Title = 'Outline Color',
    Callback = function(Value)
        matchacc.TargetAim.HighlightOutlineColor = Value
    end
})

TargetAimTab:AddToggle('Tracer', {
    Text = 'Tracer',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.Tracer = Value
        tracer.Visible = false
        tracerOutline.Visible = false
    end
}):AddColorPicker('TracerFill', {
    Default = matchacc.TargetAim.TracerFillColor,
    Title = 'Fill Color',
    Callback = function(Value)
        matchacc.TargetAim.TracerFillColor = Value
        tracer.Color = Value
    end
}):AddColorPicker('TracerOutline', {
    Default = matchacc.TargetAim.TracerOutlineColor,
    Title = 'Outline Color',
    Callback = function(Value)
        matchacc.TargetAim.TracerOutlineColor = Value
        tracerOutline.Color = Value
    end
})

TargetAimTab:AddDropdown('TracerPosition', {
    Values = {'Mouse', 'Tool'},
    Default = 1,
    Multi = false,
    Text = 'Tracer Position',
    Callback = function(Value)
        matchacc.TargetAim.TracerPosition = Value
    end
})

TargetAimTab:AddToggle('LookAt', {
    Text = 'Look At',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.LookAt = Value
    end
})

TargetAimTab:AddToggle('ToggleStrafe', {
    Text = 'Toggle Strafe',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.ToggleStrafe = Value
    end
}):AddKeyPicker('StrafeKey', {
    Default = 'Z',
    Text = 'Strafe',
    Mode = 'Toggle',
    Callback = function(Value)
        if matchacc.TargetAim.ToggleStrafe then
            matchacc.TargetAim.Strafe = Value
            if Value then
                Library:Notify("Strafe: ON", 2)
            else
                Library:Notify("Strafe: OFF", 2)
            end
        end
    end
})

TargetAimTab:AddToggle('VisualizeStrafe', {
    Text = 'Visualize Strafe',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.VisualizeStrafe = Value
    end
}):AddColorPicker('VisInline', {
    Default = matchacc.TargetAim.VisualizeStrafeInlineColor,
    Title = 'Inline Color',
    Callback = function(Value)
        matchacc.TargetAim.VisualizeStrafeInlineColor = Value
        BodyCloneHighlight.FillColor = Value
    end
}):AddColorPicker('VisOutline', {
    Default = matchacc.TargetAim.VisualizeStrafeOutlineColor,
    Title = 'Outline Color',
    Callback = function(Value)
        matchacc.TargetAim.VisualizeStrafeOutlineColor = Value
        BodyCloneHighlight.OutlineColor = Value
    end
})

TargetAimTab:AddToggle('LineStrafe', {
    Text = 'Line Strafe',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.LineStrafe = Value
    end
})

TargetAimTab:AddDropdown('StrafeMethod', {
    Values = {'Orbit', 'Randomize'},
    Default = 2,
    Multi = false,
    Text = 'Strafe Method',
    Callback = function(Value)
        matchacc.TargetAim.StrafeMethod = Value
    end
})

TargetAimTab:AddSlider('StrafePrediction', {
    Text = 'Strafe Prediction',
    Default = 0.1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        matchacc.TargetAim.StrafePrediction = Value
    end
})

TargetAimTab:AddToggle('AutoStomp', {
    Text = 'Auto Stomp',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.AutoStomp = Value
    end
})

TargetAimTab:AddToggle('VoidResolver', {
    Text = 'Void Resolver',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.VoidResolver = Value
    end
})

local targetAimSpectateConnection
TargetAimTab:AddToggle('SpectateTarget', {
    Text = 'Spectate Target',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.SpectateTarget = Value
        if Value then
            if matchacc.TargetAim.Target == "None" then
                Library:Notify("NotHub - please select a target before using 'Spectate Target'.", 3)
                Toggles.SpectateTarget.Value = false
                matchacc.TargetAim.SpectateTarget = false
                return
            end
            targetAimSpectateConnection = RunService.Heartbeat:Connect(function()
                local currentTargetName = matchacc.TargetAim.Target
                if currentTargetName == "None" then
                    workspace.CurrentCamera.CameraSubject = localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid")
                    if targetAimSpectateConnection then
                        targetAimSpectateConnection:Disconnect()
                        targetAimSpectateConnection = nil
                    end
                    Toggles.SpectateTarget.Value = false
                    matchacc.TargetAim.SpectateTarget = false
                    return
                end
                local t = game.Players:FindFirstChild(currentTargetName)
                if t and t.Character and t.Character:FindFirstChild("Humanoid") and t.Character.Humanoid.Health > 0 then
                    workspace.CurrentCamera.CameraSubject = t.Character.Humanoid
                else
                    workspace.CurrentCamera.CameraSubject = localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid")
                    if targetAimSpectateConnection then
                        targetAimSpectateConnection:Disconnect()
                        targetAimSpectateConnection = nil
                    end
                    Toggles.SpectateTarget.Value = false
                    matchacc.TargetAim.SpectateTarget = false
                end
            end)
        else
            if targetAimSpectateConnection then
                targetAimSpectateConnection:Disconnect()
                targetAimSpectateConnection = nil
            end
            workspace.CurrentCamera.CameraSubject = localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid")
        end
    end
}):AddKeyPicker('SpectateKey', {
    Default = 'none',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Spectate Target',
    Callback = function(Value)
        Toggles.SpectateTarget.Value = Value
    end
})
--local ChatGroup = Tabs.Main:AddLeftGroupbox('lol ez')
local PlayersGroup = Tabs.Main:AddLeftGroupbox('Players')

PlayersGroup:AddDropdown('AutoKillTarget', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Multi = false,
    Text = 'Target',
    Searchable = true,
    Callback = function(Value)
        matchacc.AutoKill.Target = Value
    end
})
PlayersGroup:AddButton('Teleport to Target', function()
    if not matchacc.AutoKill.Target or matchacc.AutoKill.Target == "" then
        Library:Notify("NotHub - No target selected!", 3)
        return
    end

    local targetPlayer = Players:FindFirstChild(matchacc.AutoKill.Target)
    if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        Library:Notify("NotHub - Target not found or no character!", 3)
        return
    end

    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        Library:Notify("NotHub - Your character not loaded!", 3)
        return
    end

    hrp.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, -3) -- đứng sau lưng target 3 stud
    Library:Notify("Teleported to " .. matchacc.AutoKill.Target, 2)
end)
PlayersGroup:AddToggle('AutoKillEnabled', {
    Text = 'Enabled',
    Default = false,
    Callback = function(Value)
        matchacc.AutoKill.Enabled = Value
    end
}):AddKeyPicker('AutoKillKey', {
    Default = 'none',
    Text = 'Auto Kill',
    Mode = 'Toggle',
    Callback = function(Value)
        matchacc.AutoKill.Enabled = Value
    end
})

local autoKillSpectateConnection
PlayersGroup:AddToggle('AutoKillSpectate', {
    Text = 'Spectate',
    Default = false,
    Callback = function(Value)
        matchacc.AutoKill.Spectate = Value
        if Value then
            if not matchacc.AutoKill.Target then
                Library:Notify("NotHub - please select a target before using 'Spectate'.", 3)
                Toggles.AutoKillSpectate.Value = false
                matchacc.AutoKill.Spectate = false
                return
            end
            autoKillSpectateConnection = RunService.Heartbeat:Connect(function()
                local currentTargetName = matchacc.AutoKill.Target
                if not currentTargetName then
                    workspace.CurrentCamera.CameraSubject = localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid")
                    if autoKillSpectateConnection then
                        autoKillSpectateConnection:Disconnect()
                        autoKillSpectateConnection = nil
                    end
                    Toggles.AutoKillSpectate.Value = false
                    matchacc.AutoKill.Spectate = false
                    return
                end
                local t = game.Players:FindFirstChild(currentTargetName)
                if t and t.Character and t.Character:FindFirstChild("Humanoid") and t.Character.Humanoid.Health > 0 then
                    workspace.CurrentCamera.CameraSubject = t.Character.Humanoid
                else
                    workspace.CurrentCamera.CameraSubject = localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid")
                    if autoKillSpectateConnection then
                        autoKillSpectateConnection:Disconnect()
                        autoKillSpectateConnection = nil
                    end
                    Toggles.AutoKillSpectate.Value = false
                    matchacc.AutoKill.Spectate = false
                end
            end)
        else
            if autoKillSpectateConnection then
                autoKillSpectateConnection:Disconnect()
                autoKillSpectateConnection = nil
            end
            workspace.CurrentCamera.CameraSubject = localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid")
        end
    end
})
Players.PlayerAdded:Connect(function(plr)
    if plr.Name == matchacc.AutoKill.Target and matchacc.AutoKill.Spectate then
        plr.CharacterAdded:Wait()
        task.wait(0.5) -- đợi character load đầy đủ
        if matchacc.AutoKill.Spectate then
		    local targetPlr = Players:FindFirstChild(matchacc.AutoKill.Target)
		    if not targetPlr then return end
		    if targetPlr.Character and targetPlr.Character:FindFirstChild("Humanoid") and targetPlr.Character.Humanoid.Health > 0 then
		        workspace.CurrentCamera.CameraSubject = targetPlr.Character.Humanoid
		    end
        end
    end
end)
PlayersGroup:AddToggle('AutoKillDesync', {
    Text = 'Desync for autokill',
    Default = true,
    Callback = function(Value)
        matchacc.AutoKill.AutoKillDesync = Value
    end
})

local function getValidTargets()
    local targets = {}
    for _, player in pairs(players:GetPlayers()) do
        if player ~= localPlayer then
            if matchacc.Checks.Team and player.Team == localPlayer.Team then continue end
            if matchacc.Checks.Forcefield and player.Character:FindFirstChild("ForceField") then continue end
            table.insert(targets, player.Name)
        end
    end
    return targets
end

local autoKillAllConnection
PlayersGroup:AddToggle('AutoKillAllEnabled', {
    Text = 'Auto Kill All',
    Default = false,
    Callback = function(Value)
        matchacc.AutoKillAll.Enabled = Value
        if Value then
            matchacc.AutoKillAll.Targets = getValidTargets()
            matchacc.AutoKillAll.CurrentTargetIndex = 1
            if #matchacc.AutoKillAll.Targets > 0 then
                matchacc.AutoKill.Target = matchacc.AutoKillAll.Targets[matchacc.AutoKillAll.CurrentTargetIndex]
            end
            autoKillAllConnection = RunService.Heartbeat:Connect(function()
                if not matchacc.AutoKillAll.Enabled then return end
                local currentTarget = game.Players:FindFirstChild(matchacc.AutoKill.Target)
                if not currentTarget or not isAlive(currentTarget) then
                    matchacc.AutoKillAll.CurrentTargetIndex = matchacc.AutoKillAll.CurrentTargetIndex + 1
                    if matchacc.AutoKillAll.CurrentTargetIndex > #matchacc.AutoKillAll.Targets then
                        matchacc.AutoKillAll.Targets = getValidTargets()
                        matchacc.AutoKillAll.CurrentTargetIndex = 1
                    end
                    if #matchacc.AutoKillAll.Targets > 0 then
                        matchacc.AutoKill.Target = matchacc.AutoKillAll.Targets[matchacc.AutoKillAll.CurrentTargetIndex]
                    else
                        matchacc.AutoKillAll.Enabled = false
                    end
                end
            end)
        else
            if autoKillAllConnection then
                autoKillAllConnection:Disconnect()
                autoKillAllConnection = nil
            end
            matchacc.AutoKill.Target = nil
        end
    end
}):AddKeyPicker('AutoKillAllKey', {
    Default = 'none',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Auto Kill All',
    Callback = function(Value)
        Toggles.AutoKillAllEnabled.Value = Value
    end
})
local HitEffectsGroup = Tabs.Main:AddLeftGroupbox('Hit Effects')
HitEffectsGroup:AddToggle('HitChamsEnabled', {
    Text = 'Hit Chams',
    Default = false,
    Callback = function(Value)
        matchacc.HitEffects.HitChams.Enabled = Value
    end
}):AddColorPicker('HitChamsColor', {
    Default = matchacc.HitEffects.HitChams.Color,
    Title = 'Hit Chams Color',
    Callback = function(Value)
        matchacc.HitEffects.HitChams.Color = Value
    end
})

HitEffectsGroup:AddSlider('HitChamsLifetime', {
    Text = 'Hit Chams Lifetime (sec)',
    Min = 1,
    Max = 10,
    Default = matchacc.HitEffects.HitChams.Lifetime,
    Rounding = 1,
    Callback = function(Value)
        matchacc.HitEffects.HitChams.Lifetime = Value
    end
})

HitEffectsGroup:AddSlider('HitChamsTransparency', {
    Text = 'Hit Chams Transparency',
    Min = 0,
    Max = 1,
    Default = matchacc.HitEffects.HitChams.Transparency,
    Rounding = 2,
    Callback = function(Value)
        matchacc.HitEffects.HitChams.Transparency = Value
    end
})

HitEffectsGroup:AddDropdown('HitChamsMaterial', {
    Values = {'Neon', 'ForceField'},
    Default = matchacc.HitEffects.HitChams.Material == "Neon" and 1 or 2,
    Multi = false,
    Text = 'Hit Chams Material',
    Callback = function(Value)
        matchacc.HitEffects.HitChams.Material = Value
    end
})
HitEffectsGroup:AddToggle('HitEffectEnabled', {
    Text = 'Hit Effect',
    Default = false,
    Callback = function(Value)
        matchacc.HitEffects.HitEffect.Enabled = Value
    end
}):AddColorPicker('HitEffectColor', {
    Default = matchacc.HitEffects.HitEffect.Color,
    Title = 'Effect Color',
    Callback = function(Value)
        matchacc.HitEffects.HitEffect.Color = Value
    end
})

HitEffectsGroup:AddDropdown('HitEffectType', {
    Values = {"None", "Skibidi RedRizz", "Nova", "Crescent Slash", "Cosmic Explosion", "Coom", "Slash", "Atomic Slash", "Thunder", "Electric", "Circle", "Shock3", "Aura", "IDK", "Swirl", "AuraBurst"},
    Default = 0,
    Multi = true,
    Text = 'Effect Type',
    Callback = function(Value)
        matchacc.HitEffects.HitEffect.Type = Value
    end
})
local TweenService = game:GetService("TweenService")
local RaycastParams = RaycastParams.new()
RaycastParams.FilterType = Enum.RaycastFilterType.Blacklist
RaycastParams.IgnoreWater = true

-- Settings
local font = Enum.Font.SourceSansBold
local baseSize = 40
local distance = 10000
local animationDuration = 3 
local fadeDuration = 1 
local maxOffset = 20 

local isDamageNumbersEnabled = false  
local damageColor = Color3.fromRGB(255, 255, 255)

-- Previous health of the nearest player
local previousHealth = {}

-- Function to check if a player is behind a wall
local function isPlayerVisible(player)
	if not player.Character or not player.Character:FindFirstChild("Head") then return false end
	local head = player.Character.Head
	local origin = Camera.CFrame.Position
	local direction = (head.Position - origin).Unit * (head.Position - origin).Magnitude
	RaycastParams.FilterDescendantsInstances = {Players.LocalPlayer.Character}
	local result = workspace:Raycast(origin, direction, RaycastParams)
	return not result or result.Instance:IsDescendantOf(player.Character)
end

-- Function to get the player nearest to the cursor with visibility check
local function getNearestToCursor()
	local mouseLocation = UserInputService:GetMouseLocation()
	local nearestPlayer
	local shortestDistance = math.huge

	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
			local head = player.Character.Head
			local screenPosition, onScreen = Camera:WorldToViewportPoint(head.Position)
			if onScreen then
				local distanceToCursor = (Vector2.new(screenPosition.X, screenPosition.Y) - mouseLocation).Magnitude
				if distanceToCursor < shortestDistance then
					shortestDistance = distanceToCursor
					nearestPlayer = player
				end
			end
		end
	end
	return nearestPlayer
end

-- Function to create damage number display
local function createDamageDisplay(player, damageAmount)
	if not isDamageNumbersEnabled then return end

	local head = player.Character and player.Character:FindFirstChild("Head")
	if head then
		local damageContainer = head:FindFirstChild("DamageContainer")
		if not damageContainer then
			damageContainer = Instance.new("BillboardGui")
			damageContainer.Name = "DamageContainer"
			damageContainer.Parent = head
			damageContainer.Adornee = head
			damageContainer.Size = UDim2.new(0, 100, 0, 50)
			damageContainer.StudsOffset = Vector3.new(0, 2, 0)
			damageContainer.AlwaysOnTop = true
			damageContainer.MaxDistance = distance
			damageContainer.Enabled = true
		end

		-- Create the new damage number label
		local textLabel = Instance.new("TextLabel")
		textLabel.Parent = damageContainer
		textLabel.Text = tostring(damageAmount)
		textLabel.TextColor3 = damageColor
		textLabel.TextSize = baseSize + (damageAmount / 10) -- Scale size based on damage
		textLabel.Font = font
		textLabel.BackgroundTransparency = 1
		textLabel.Size = UDim2.new(1, 0, 0, baseSize)
		textLabel.TextStrokeTransparency = 0.4
		textLabel.Position = UDim2.new(0.5, -50 + math.random(-maxOffset, maxOffset), 0, math.random(-maxOffset, maxOffset)) -- Random offset

		-- Target position for the damage number to slowly move upwards
		local targetPosition = UDim2.new(0.5, -50, 0, -100) -- Final position for all damage numbers

		-- Create the upward movement tween
		local moveUpTween = TweenService:Create(
			textLabel, 
			TweenInfo.new(animationDuration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), 
			{Position = targetPosition}
		)

		-- Create the fade-out tween
		local fadeOutTween = TweenService:Create(
			textLabel,
			TweenInfo.new(fadeDuration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
			{TextTransparency = 1, TextStrokeTransparency = 1} -- Fade both text and stroke
		)

		-- Play the move-up tween
		moveUpTween:Play()

		-- Once the move-up animation is completed, start fading out
		moveUpTween.Completed:Connect(function()
			fadeOutTween:Play()

			-- Destroy the label after the fade-out is complete
			fadeOutTween.Completed:Connect(function()
				textLabel:Destroy()
			end)
		end)
	end
end

-- Function to check and display damage numbers for the nearest player
local function checkNearestPlayerDamage()
	local nearestPlayer = getNearestToCursor()

	if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChildOfClass("Humanoid") then
		local humanoid = nearestPlayer.Character:FindFirstChildOfClass("Humanoid")
		local currentHealth = humanoid.Health

		-- Get the previous health of the player, or set it to their current health if not tracked
		local prevHealth = previousHealth[nearestPlayer.UserId] or currentHealth

		if currentHealth < prevHealth then
		    createDamageDisplay(nearestPlayer, math.floor(prevHealth - currentHealth))
		    if (matchacc.TargetAim.Enabled and matchacc.TargetAim.Target == nearestPlayer.Name) 
		        or (matchacc.AutoKill.Enabled and matchacc.AutoKill.Target == nearestPlayer.Name) then
		        createHitCham(nearestPlayer)
		    end
		end

		-- Update the player's previous health
		previousHealth[nearestPlayer.UserId] = currentHealth
	end
end

-- Run every frame to check the nearest player's health
RunService.RenderStepped:Connect(checkNearestPlayerDamage)
HitEffectsGroup:AddToggle('DamageNumbersEnabled', {
    Text = 'Damage Numbers',
    Default = false,
    Callback = function(Value)
        isDamageNumbersEnabled = Value
    end
}):AddColorPicker('DamageColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Damage Color',
    Callback = function(Value)
        damageColor = Value
    end
})

HitEffectsGroup:AddToggle('HitNotifications', {
    Text = 'Hit Notifications',
    Default = false,
    Callback = function(Value)
        matchacc.HitEffects.HitNotifications = Value
    end
})

HitEffectsGroup:AddSlider('NotifyTime', {
    Text = 'Notify Time',
    Default = 3,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Callback = function(Value)
        matchacc.HitEffects.HitNotificationsTime = Value
    end
})

HitEffectsGroup:AddToggle('HitSounds', {
    Text = 'Hit Sounds',
    Default = false,
    Callback = function(Value)
        matchacc.HitEffects.HitSounds = Value
    end
})

HitEffectsGroup:AddDropdown('HitSoundSelect', {
    Values = {"Bubble", "Lazer", "Pick", "Pop", "Rust", "Sans", "Fart", "Big", "Vine", "UwU", "Bruh", "Skeet", "Neverlose", "Fatality", "Bonk", "Minecraft", "Gamesense", "RIFK7", "Bamboo", "Crowbar", "Weeb", "Beep", "Bambi", "Stone", "Old Fatality", "Click", "Ding", "Snow", "Laser", "Mario", "Steve", "Call of Duty", "Bat", "TF2 Critical", "Saber", "Baimware", "Osu", "TF2", "Slime", "Among Us", "One"},
    Default = "Neverlose",
    Multi = false,
    Text = 'Hit Sound',
    Callback = function(Value)
        matchacc.HitEffects.HitSoundID = hitsounds[Value]
    end
})

HitEffectsGroup:AddSlider('HitSoundVolume', {
    Text = 'Volume',
    Default = 5,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Callback = function(Value)
        matchacc.HitEffects.HitSoundVolume = Value
    end
})

ChecksTab:AddToggle('CheckWall', {
    Text = 'Check Wall',
    Default = false,
    Callback = function(Value)
        matchacc.Checks.Wall = Value
    end
})

ChecksTab:AddToggle('CheckForcefield', {
    Text = 'Check Forcefield',
    Default = false,
    Callback = function(Value)
        matchacc.Checks.Forcefield = Value
    end
})

ChecksTab:AddToggle('CheckAlive', {
    Text = 'Check Alive',
    Default = false,
    Callback = function(Value)
        matchacc.Checks.Alive = Value
    end
})

ChecksTab:AddToggle('CheckTeam', {
    Text = 'Check Team',
    Default = false,
    Callback = function(Value)
        matchacc.Checks.Team = Value
    end
})

local KillAuraGroup = Tabs.Main:AddRightGroupbox('Kill Aura')

KillAuraGroup:AddToggle('KillAuraEnabled', {
    Text = 'Enabled',
    Default = false,
    Callback = function(Value)
        matchacc.KillAura.Enabled = Value
        if not Value then
            matchacc.KillAura.Active = false
            ka_tracer.Transparency = 1
        end
    end
}):AddKeyPicker('KillAuraKey', {
    Default = 'K',
    Text = 'Kill Aura',
    Mode = 'Toggle',
    Callback = function(Value)
        if matchacc.KillAura.Enabled then
            matchacc.KillAura.Active = Value
        end
    end
})

KillAuraGroup:AddSlider('KillAuraRange', {
    Text = 'Range',
    Default = 250,
    Min = 10,
    Max = 250,
    Rounding = 0,
    Callback = function(Value)
        matchacc.KillAura.Range = Value
    end
})

KillAuraGroup:AddToggle('KillAuraSilent', {
    Text = 'Silent',
    Default = false,
    Callback = function(Value)
        matchacc.KillAura.Silent = Value
    end
})

KillAuraGroup:AddToggle('KillAuraVisualize', {
    Text = 'Visualize',
    Default = false,
    Callback = function(Value)
        matchacc.KillAura.Visualize = Value
    end
}):AddColorPicker('KAVisColor', {
    Default = Color3.new(1, 0, 0),
    Title = 'Visualizer Color',
    Callback = function(Value)
        ka_tracer.Color = Value
    end
})

KillAuraGroup:AddDropdown('KAWhitelist', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Multi = true,
    Searchable = true,
    Text = 'Whitelist',
    Callback = function(Value)
        matchacc.KillAura.Whitelist = Value
    end
})

KillAuraGroup:AddToggle('StompAura', {
    Text = 'Stomp Aura',
    Default = false,
    Callback = function(Value)
        matchacc.KillAura.StompAura = Value
    end
})
local GunModsGroup = Tabs.Main:AddRightGroupbox('Gun Mods')
matchacc.EquipAllGuns = {
    Enabled = false,
}

-- Globals (sau các global vars khác)
local EquipAllConnection = nil
local lastEquipTime = 0
local EquipAllConnection
local EquipAddedConnection

-- Function equipAllGuns đã sửa
local function equipAllGuns()
    local char = localPlayer.Character
    local backpack = localPlayer.Backpack
    if not char or not backpack then return end
    for _, tool in ipairs(backpack:GetChildren()) do
        if tool:IsA("Tool") and tool:FindFirstChild("Ammo") then
            tool.Parent = char
        end
    end
end

local function setupEquipAll()
    local char = localPlayer.Character
    local backpack = localPlayer.Backpack
    if not char or not backpack or not matchacc.EquipAllGuns.Enabled then return end
    
    equipAllGuns()
    
    if EquipAllConnection then
        EquipAllConnection:Disconnect()
        EquipAllConnection = nil
    end
    EquipAllConnection = char.ChildRemoved:Connect(function(child)
        if matchacc.EquipAllGuns.Enabled and child:IsA("Tool") and child:FindFirstChild("Ammo") and (tick() - lastEquipTime) >= 0.5 then
            lastEquipTime = tick()
            task.spawn(function()
                task.wait(0.1)
                equipAllGuns()
            end)
        end
    end)
    
    if EquipAddedConnection then
        EquipAddedConnection:Disconnect()
        EquipAddedConnection = nil
    end
    EquipAddedConnection = backpack.ChildAdded:Connect(function(child)
        if matchacc.EquipAllGuns.Enabled and child:IsA("Tool") and child:FindFirstChild("Ammo") then
            child.Parent = char
        end
    end)
end

-- Character respawn
localPlayer.CharacterAdded:Connect(function()
    task.wait(5)
    if matchacc.EquipAllGuns.Enabled then
        setupEquipAll()
    end
end)

-- Thêm vào GunModsGroup (sau Wallbang)
GunModsGroup:AddToggle('EquipAllGunsEnabled', {
    Text = 'Equip All Guns',
    Default = false,
    Callback = function(Value)
        matchacc.EquipAllGuns.Enabled = Value
        if Value then
            setupEquipAll()
        else
            if EquipAllConnection then
                EquipAllConnection:Disconnect()
                EquipAllConnection = nil
            end
        end
    end
}):AddKeyPicker('EquipAllGunsKey', {
    Default = 'none',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Equip All Guns'
})
GunModsGroup:AddToggle('RapidFireEnabled', {
    Text = 'Rapid Fire',
    Default = false,
    Callback = function(Value)
        matchacc.RapidFire.Enabled = Value
        if not getnamecallmethod then
            Library:Notify("Your executor does not support this feature.", 3)
        end
    end
})

GunModsGroup:AddToggle('WallbangEnabled', {
    Text = 'Wallbang',
    Default = false,
    Callback = function(Value)
        matchacc.Wallbang.Enabled = Value
        if getnamecallmethod then
            local Handler = game:FindService("ReplicatedStorage").MainModule
            local Module = require(Handler)
            if Value == true and workspace:FindFirstChild("Vehicles") then
                Module.Ignored = {workspace:WaitForChild("Vehicles"), workspace:WaitForChild("MAP"), workspace:WaitForChild("Ignored")}
            else
                if workspace:FindFirstChild("Vehicles") then
                    Module.Ignored = {workspace:WaitForChild("Vehicles"), workspace:WaitForChild("Ignored")}
                end
            end
        else
            Library:Notify("Your executor does not support this feature.", 3)
        end
    end
})
getgenv().RemoveShootAnimationsEnabled = false
getgenv().ShootAnimationIds = {
    ["rbxassetid://2807049953"] = true, 
    ["rbxassetid://2809413000"] = true, 
    ["rbxassetid://2809419094"] = true,  
    ["rbxassetid://507768375"] = true,
    ["rbxassetid://507755388"] = true,
    ["rbxassetid://2807049953"] = true,
    ["rbxassetid://2877910736"] = true 
}

getgenv().StopAnimationTracks = function(character)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
            if getgenv().ShootAnimationIds[track.Animation.AnimationId] then
                track:Stop()
            end
        end
    end
end

getgenv().MonitorCharacter = function(character)
    character.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("AnimationTrack") and getgenv().RemoveShootAnimationsEnabled then
            if getgenv().ShootAnimationIds[descendant.Animation.AnimationId] then
                descendant:Stop()
            end
        end
    end)
end

getgenv().MonitorPlayers = function()
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        local character = player.Character or player.CharacterAdded:Wait()
        getgenv().StopAnimationTracks(character)
        getgenv().MonitorCharacter(character)

        player.CharacterAdded:Connect(function(newCharacter)
            getgenv().StopAnimationTracks(newCharacter)
            getgenv().MonitorCharacter(newCharacter)
        end)
    end

    game:GetService("Players").PlayerAdded:Connect(function(player)
        player.CharacterAdded:Connect(function(character)
            getgenv().StopAnimationTracks(character)
            getgenv().MonitorCharacter(character)
        end)
    end)
end

getgenv().MonitorAnimations = function()
    game:GetService("RunService").RenderStepped:Connect(function()
        if getgenv().RemoveShootAnimationsEnabled then
            for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
                local character = player.Character
                if character then
                    getgenv().StopAnimationTracks(character)
                end
            end
        end
    end)
end

GunModsGroup:AddToggle("AntiflingToggle", {
    Text = "remove shoot animations",
    Default = false,
    Callback = function(enabled)
        getgenv().RemoveShootAnimationsEnabled = enabled
        if enabled then
            getgenv().MonitorPlayers()
            task.spawn(getgenv().MonitorAnimations)
        end
    end
})



local HitboxGroup = Tabs.Main:AddRightGroupbox('Hitbox Expander')

HitboxGroup:AddToggle('HitboxEnabled', {
    Text = 'Enabled',
    Default = false,
    Callback = function(Value)
        matchacc.HitboxExpander.Enabled = Value
    end
})

HitboxGroup:AddToggle('HitboxVisualize', {
    Text = 'Visualize',
    Default = false,
    Callback = function(Value)
        matchacc.HitboxExpander.Visualize = Value
    end
}):AddColorPicker('HitboxColor', {
    Default = matchacc.HitboxExpander.Color,
    Title = 'Fill Color',
    Callback = function(Value)
        matchacc.HitboxExpander.Color = Value
    end
}):AddColorPicker('HitboxOutline', {
    Default = matchacc.HitboxExpander.OutlineColor,
    Title = 'Outline Color',
    Callback = function(Value)
        matchacc.HitboxExpander.OutlineColor = Value
    end
})

HitboxGroup:AddSlider('HitboxFillTrans', {
    Text = 'Fill Transparency',
    Default = 0.5,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        matchacc.HitboxExpander.FillTransparency = Value
    end
})

HitboxGroup:AddSlider('HitboxOutlineTrans', {
    Text = 'Outline Transparency',
    Default = 0.3,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        matchacc.HitboxExpander.OutlineTransparency = Value
    end
})

HitboxGroup:AddSlider('HitboxSize', {
    Text = 'Size',
    Default = 15,
    Min = 1,
    Max = 37,
    Rounding = 0,
    Callback = function(Value)
        matchacc.HitboxExpander.Size = Value
    end
})

getgenv().Matcha.Legit = {
    Aimlock = false,
    HitPart = "Head",
    Smoothing = false,
    SmoothingAmount = 0.1,
    SilentAim = false,  -- Mới: Toggle cho Silent Aim
    SilentAimMethod = "Rival",  -- Mới: Default method
    Prediction = 0.1,
    JumpOffset = 0,
    Offset = true,
    SilentFOV = 100,
    SilentFOVEnabled = false,
}
local LegitBox = Tabs.Main:AddRightTabbox()
local AimlockBox = LegitBox:AddTab('Aimlock')
local SilentBox = LegitBox:AddTab('SilentAim')
SilentBox:AddToggle('SilentAimEnabled', {
    Text = 'Silent Aim',
    Default = false,
    Callback = function(Value)
        getgenv().Matcha.Legit.SilentAim = Value
    end
})

SilentBox:AddDropdown('SilentAimMethod', {
    Values = {'Rival', 'Flick'},
    Default = 0,
    Multi = false,
    Text = 'Silent Aim Method',
    Callback = function(Value)
        getgenv().Matcha.Legit.SilentAimMethod = Value
    end
})
SilentBox:AddToggle('SilentAimEnabled', {
    Text = 'Silent Fov Enabled',
    Default = false,
    Callback = function(Value)
        getgenv().Matcha.Legit.SilentFOVEnabled = Value
    end
})
SilentBox:AddSlider('SilentFOV', {
    Text = 'Silent Aim FOV',
    Default = 100,
    Min = 10,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        getgenv().Matcha.Legit.SilentFOV = Value
    end
})
AimlockBox:AddToggle('AimlockEnabled', {
    Text = 'Aimlock',
    Default = false,
    Callback = function(Value)
        getgenv().Matcha.Legit.Aimlock = Value
    end
})
AimlockBox:AddDropdown('HitPart', {
    Values = {'Head', 'UpperTorso', 'HumanoidRootPart'},
    Default = 1,
    Multi = false,
    Text = 'Hit Part',
    Callback = function(Value)
        getgenv().Matcha.Legit.HitPart = Value
    end
})
AimlockBox:AddToggle('SmoothingEnabled', {
    Text = 'Smoothing',
    Default = false,
    Callback = function(Value)
        getgenv().Matcha.Legit.Smoothing = Value
    end
})
AimlockBox:AddSlider('SmoothingAmount', {
    Text = 'Smoothing Amount',
    Default = 0.1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        getgenv().Matcha.Legit.SmoothingAmount = Value
    end
})
AimlockBox:AddSlider('Prediction', {
    Text = 'Prediction',
    Default = 0.1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        getgenv().Matcha.Legit.Prediction = Value
    end
})
AimlockBox:AddSlider('JumpOffset', {
    Text = 'Jump Offset',
    Default = 0,
    Min = -10,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        getgenv().Matcha.Legit.JumpOffset = Value
    end
})
local camera = workspace.CurrentCamera
if game.GameId ~= 17625359962 then
local function isLobbyVisible()
    return localPlayer.PlayerGui.MainGui.MainFrame.Lobby.Currency.Visible == true
end
local function getClosestPlayerToMouse()  -- Hàm closest player từ code Rival
    local closestPlayer = nil
    local shortestDistance = getgenv().Matcha.Legit.SilentFOVEnabled and getgenv().Matcha.Legit.SilentFOV or 9999
    local mousePosition = UserInputService:GetMouseLocation()

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local head = player.Character.Head
            local headPosition, onScreen = Camera:WorldToViewportPoint(head.Position)
	        if not isAlive(player) then continue end

	        if not isPlayerVisible(player) then continue end
            if onScreen then
                local screenPosition = Vector2.new(headPosition.X, headPosition.Y)
                local distance = (screenPosition - mousePosition).Magnitude

                if distance < shortestDistance then
                    closestPlayer = player
                    shortestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end
local isLeftMouseDown = false
local autoClickConnection = nil
local function autoClick()
    if autoClickConnection then
        autoClickConnection:Disconnect()
    end
    autoClickConnection = RunService.Heartbeat:Connect(function()
        if isLeftMouseDown then
            if not isLobbyVisible() then
                mouse1click()
            end
        else
            autoClickConnection:Disconnect()
        end
    end)
end
UserInputService.InputBegan:Connect(function(input, isProcessed)
    if input.UserInputType == Enum.UserInputType.MouseButton1 and not isProcessed then
        if not isLeftMouseDown then
            isLeftMouseDown = true
            autoClick()
        end
    end
end)
UserInputService.InputEnded:Connect(function(input, isProcessed)
    if input.UserInputType == Enum.UserInputType.MouseButton1 and not isProcessed then
        isLeftMouseDown = false
    end
end)
local function lockCameraToHead(targetPlayer)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
        local head = targetPlayer.Character.Head
        local headPosition = Camera:WorldToViewportPoint(head.Position)
        if headPosition.Z > 0 then
            local cameraPosition = Camera.CFrame.Position
            Camera.CFrame = CFrame.new(cameraPosition, head.Position)
        end
    end
end

-- RunService cho Rival (chạy khi method là Rival)
RunService.Heartbeat:Connect(function()
    if getgenv().Matcha.Legit.SilentAim and getgenv().Matcha.Legit.SilentAimMethod == "Rival" and not isLobbyVisible() then
        local targetPlayer = getClosestPlayerToMouse()  -- Closest player
        if targetPlayer then
            lockCameraToHead(targetPlayer)
        end
    end
end)
end
spawn(function()
    local BulletHandler = nil
    local OldFire = nil

    local function get_closest_target(range)
        local closest_part, closest_distance = nil, range
        local mousePos = UserInputService:GetMouseLocation()

        for _, player in pairs(players:GetPlayers()) do
            if player == localPlayer or not player.Character or not player.Character:FindFirstChild("Head") then continue end
            local hum = player.Character:FindFirstChildOfClass("Humanoid")
	        if not isAlive(player) then continue end
	        if not isPlayerVisible(player) then continue end
            local headPos, onScreen = Camera:WorldToViewportPoint(player.Character.Head.Position)
            if not onScreen then continue end

            local dist = (Vector2.new(headPos.X, headPos.Y) - mousePos).Magnitude
            if dist < closest_distance then
                closest_distance = dist
                closest_part = player.Character.Head
            end
        end
        return closest_part
    end

    RunService.Heartbeat:Connect(function()
        if not getgenv().Matcha.Legit.SilentAim or getgenv().Matcha.Legit.SilentAimMethod ~= "Flick" then
            if BulletHandler and OldFire then
                BulletHandler.Fire = OldFire
                BulletHandler = nil
                OldFire = nil
            end
            return
        end

        if not BulletHandler then
            local success, mod = pcall(function()
                return require(ReplicatedStorage:FindFirstChild("ModuleScripts", true):FindFirstChild("GunModules", true).BulletHandler)
            end)
            if not success then
                -- gc fallback cực mạnh cho Rivals
                for _, v in pairs(getgc(true)) do
                    if typeof(v) == "table" and rawget(v, "Fire") and typeof(rawget(v, "Fire")) == "function" then
                        BulletHandler = v
                        break
                    end
                end
            else
                BulletHandler = mod
            end

            if BulletHandler and BulletHandler.Fire then
                OldFire = BulletHandler.Fire
                BulletHandler.Fire = newcclosure(function(data, ...)
                    if not getgenv().Matcha.Legit.SilentAim then
                        return OldFire(data, ...)
                    end

                    local closest = get_closest_target(getgenv().Matcha.Legit.SilentFOVEnabled and getgenv().Matcha.Legit.SilentFOV or 9999)

                    if closest then
                        local pred = 0
                        local predictedPos = closest.Position + (closest.Velocity * pred)

                        data.Direction = (predictedPos - data.Origin).Unit
                        data.Force = data.Force * 1000
                    end

                    return OldFire(data, ...)
                end)
            end
        end
    end)
end)
local function updateCamlock()
    local targetName = matchacc.TargetAim.Target
    if not getgenv().Matcha.Legit.Aimlock then return end

    local target = players:FindFirstChild(targetName)
    if not target or not target.Character then
        return
    end

    local part = target.Character:FindFirstChild(getgenv().Matcha.Legit.HitPart)
    if not part or not isAlive(target) or not isPlayerVisible(target) then
        return
    end

    local pos = part.Position + (part.AssemblyLinearVelocity * (getgenv().Matcha.Legit.Prediction or 0))
    if getgenv().Matcha.Legit.Offset and target.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
        pos = pos + Vector3.new(0, getgenv().Matcha.Legit.JumpOffset or 0, 0)
    end

    local goal = CFrame.new(Camera.CFrame.Position, pos)
    if getgenv().Matcha.Legit.Smoothing then
        Camera.CFrame = Camera.CFrame:Lerp(goal, getgenv().Matcha.Legit.SmoothingAmount)
    else
        Camera.CFrame = goal
    end
end
RunService.RenderStepped:Connect(function()
    if getgenv().Matcha.Legit.Aimlock then
        updateCamlock()
    end
end)
local ChinaHatGroup = Tabs.Visual:AddRightGroupbox('China Hat')
getgenv().ChinaHatSettings = {
    enabled = false, 
    hatColor = Color3.fromRGB(255, 255, 255), 
    lightColor = Color3.fromRGB(255, 255, 255), 
    lightBrightness = 0, 
    lightRange = 12, 
    scale = Vector3.new(1.7, 1.1, 1.7), 
}

-- Thêm Cone.Name = "ChinaHat" vào function CreateHat để dễ find và destroy
local function CreateHat(Character)
    local Head = Character:FindFirstChild("Head")
    if not Head then return end
    local Cone = Instance.new("Part")
    Cone.Name = "ChinaHat"  -- Thêm name để dễ quản lý
    Cone.Size = Vector3.new(1, 1, 1)
    Cone.BrickColor = BrickColor.new("Hot pink")
    Cone.Material = Enum.Material.Neon
    Cone.Transparency = 0.2
    Cone.Anchored = false
    Cone.CanCollide = false
    Cone.Color = getgenv().ChinaHatSettings.hatColor
    local Mesh = Instance.new("SpecialMesh")
    Mesh.MeshType = Enum.MeshType.FileMesh
    Mesh.MeshId = "rbxassetid://1033714"
    Mesh.Scale = getgenv().ChinaHatSettings.scale
    Mesh.Parent = Cone
    local Weld = Instance.new("Weld")
    Weld.Part0 = Head
    Weld.Part1 = Cone
    Weld.C0 = CFrame.new(0, 0.9, 0)
    Weld.Parent = Cone
    local Light = Instance.new("PointLight")
    Light.Color = getgenv().ChinaHatSettings.lightColor
    Light.Brightness = getgenv().ChinaHatSettings.lightBrightness
    Light.Range = getgenv().ChinaHatSettings.lightRange
    Light.Shadows = true
    Light.Parent = Cone
    Cone.Parent = Character
end

local function OnCharacterAdded(Character)
    if getgenv().ChinaHatSettings.enabled then
        CreateHat(Character)
    end
end

-- Kết nối sự kiện CharacterAdded
localPlayer.CharacterAdded:Connect(OnCharacterAdded)

-- Nếu character đã tồn tại, áp dụng ngay
if localPlayer.Character then
    task.wait(2)
    OnCharacterAdded(localPlayer.Character)
end

ChinaHatGroup:AddToggle('ChinaHatEnabled', {
    Text = "China Hat ESP",
    Default = getgenv().ChinaHatSettings.enabled,
    Callback = function(state)
        getgenv().ChinaHatSettings.enabled = state
        if state then
            if localPlayer.Character then
                OnCharacterAdded(localPlayer.Character)
            end
        else
            if localPlayer.Character then
                local hat = localPlayer.Character:FindFirstChild("ChinaHat")
                if hat then
                    hat:Destroy()
                end
            end
        end
    end
}):AddColorPicker('ChinaHatColor', {
    Default = getgenv().ChinaHatSettings.hatColor,
    Title = "Hat Color",
    Callback = function(color)
        getgenv().ChinaHatSettings.hatColor = color
        -- Realtime update: destroy và recreate nếu enabled
        if getgenv().ChinaHatSettings.enabled and localPlayer.Character then
            local hat = localPlayer.Character:FindFirstChild("ChinaHat")
            if hat then hat:Destroy() end
            CreateHat(localPlayer.Character)
        end
    end
}):AddColorPicker('ChinaLightColor', {
    Default = getgenv().ChinaHatSettings.lightColor,
    Title = "Light Color",
    Callback = function(color)
        getgenv().ChinaHatSettings.lightColor = color
        if getgenv().ChinaHatSettings.enabled and localPlayer.Character then
            local hat = localPlayer.Character:FindFirstChild("ChinaHat")
            if hat then hat:Destroy() end
            CreateHat(localPlayer.Character)
        end
    end
})

ChinaHatGroup:AddSlider('ChinaLightBrightness', {
    Text = "Light Brightness",
    Min = 0,
    Max = 10,
    Default = getgenv().ChinaHatSettings.lightBrightness,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        getgenv().ChinaHatSettings.lightBrightness = value
        if getgenv().ChinaHatSettings.enabled and localPlayer.Character then
            local hat = localPlayer.Character:FindFirstChild("ChinaHat")
            if hat then hat:Destroy() end
            CreateHat(localPlayer.Character)
        end
    end
})

ChinaHatGroup:AddSlider('ChinaLightRange', {
    Text = "Light Range",
    Min = 0,
    Max = 50,
    Default = getgenv().ChinaHatSettings.lightRange,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        getgenv().ChinaHatSettings.lightRange = value
        if getgenv().ChinaHatSettings.enabled and localPlayer.Character then
            local hat = localPlayer.Character:FindFirstChild("ChinaHat")
            if hat then hat:Destroy() end
            CreateHat(localPlayer.Character)
        end
    end
})

ChinaHatGroup:AddSlider('ChinaHatScaleX', {
    Text = "Hat Scale X",
    Min = 0.5,
    Max = 3,
    Default = getgenv().ChinaHatSettings.scale.X,
    Rounding = 2,
    Compact = false,
    Callback = function(value)
        getgenv().ChinaHatSettings.scale = Vector3.new(value, getgenv().ChinaHatSettings.scale.Y, getgenv().ChinaHatSettings.scale.Z)
        if getgenv().ChinaHatSettings.enabled and localPlayer.Character then
            local hat = localPlayer.Character:FindFirstChild("ChinaHat")
            if hat then hat:Destroy() end
            CreateHat(localPlayer.Character)
        end
    end
})

ChinaHatGroup:AddSlider('ChinaHatScaleY', {
    Text = "Hat Scale Y",
    Min = 0.5,
    Max = 3,
    Default = getgenv().ChinaHatSettings.scale.Y,
    Rounding = 2,
    Compact = false,
    Callback = function(value)
        getgenv().ChinaHatSettings.scale = Vector3.new(getgenv().ChinaHatSettings.scale.X, value, getgenv().ChinaHatSettings.scale.Z)
        if getgenv().ChinaHatSettings.enabled and localPlayer.Character then
            local hat = localPlayer.Character:FindFirstChild("ChinaHat")
            if hat then hat:Destroy() end
            CreateHat(localPlayer.Character)
        end
    end
})

ChinaHatGroup:AddSlider('ChinaHatScaleZ', {
    Text = "Hat Scale Z",
    Min = 0.5,
    Max = 3,
    Default = getgenv().ChinaHatSettings.scale.Z,
    Rounding = 2,
    Compact = false,
    Callback = function(value)
        getgenv().ChinaHatSettings.scale = Vector3.new(getgenv().ChinaHatSettings.scale.X, getgenv().ChinaHatSettings.scale.Y, value)
        if getgenv().ChinaHatSettings.enabled and localPlayer.Character then
            local hat = localPlayer.Character:FindFirstChild("ChinaHat")
            if hat then hat:Destroy() end
            CreateHat(localPlayer.Character)
        end
    end
})
local ESPGroup = Tabs.Visual:AddLeftGroupbox('ESP')

getgenv().esp = {
    players = {},
    enabled = false,
    fading = false,
    espfadespeed = 5,
    box = false,
    boxcolor = Color3.fromRGB(255,255,255),
    boxoutline = Color3.fromRGB(0,0,0),
    boxtransparency = 0,
    boxoutlinetransparency = 0,
    health = false,
    healthcolor = Color3.fromRGB(0,255,0),
    healthoutline = Color3.fromRGB(0,0,0),
    healthtransparency = 0,
    healthoutlinetransparency = 0,
    chams = false,
    chamscolor = Color3.fromRGB(204,255,255),
    chamsoutline = Color3.fromRGB(0,0,0),
    chamstransparencyinline = 0.5,
    chamstransparencyoutline = 0.5,
    name = false,
    namecolor = Color3.fromRGB(255,255,255),
    nameoutline = Color3.fromRGB(0,0,0),
    nametransparency = 0,
    healthbartext = false,
    healthbartextcolor = Color3.fromRGB(255,255,255),
    healthbartextoutline = Color3.fromRGB(0,0,0),
    healthbartexttransparency = 0,
    renderdistance = 10000
}
local LPH_JIT_ULTRA = LPH_JIT_ULTRA or function(...) return ... end
spawn(LPH_JIT_ULTRA(function()
    while task.wait() do
        for i, v in next, players:GetPlayers() do
            if v ~= localPlayer and isAlive2(v) then
                local drawingInstances = esp.players[v]
                if not drawingInstances then continue end
                if esp.enabled then
                    local character = v.Character
                    local _, onscreen = Camera:WorldToScreenPoint(character.HumanoidRootPart.Position)
                    local distfromchar = (Camera.CFrame.Position - v.Character.HumanoidRootPart.Position).Magnitude
                    if esp.renderdistance < distfromchar then
                        drawingInstances.Box.Visible = false
                        drawingInstances.BoxOutline.Visible = false
                        drawingInstances.Health.Visible = false
                        drawingInstances.HealthOutline.Visible = false
                        drawingInstances.Cham.Parent = nil
                        drawingInstances.Name.Visible = false
                        drawingInstances.HealthText.Visible = false
                    elseif not isAlive(v) then
                        drawingInstances.Box.Visible = false
                        drawingInstances.BoxOutline.Visible = false
                        drawingInstances.Health.Visible = false
                        drawingInstances.HealthOutline.Visible = false
                        drawingInstances.Cham.Parent = nil
                        drawingInstances.Name.Visible = false
                        drawingInstances.HealthText.Visible = false
                    else
                        if onscreen then
                            local charhum2D = Camera:WorldToViewportPoint(character.HumanoidRootPart.Position)
                            local charSize = (Camera:WorldToViewportPoint(character.HumanoidRootPart.Position - Vector3.new(0, 3, 0)).Y - Camera:WorldToViewportPoint(character.HumanoidRootPart.Position + Vector3.new(0, 2.6, 0)).Y) / 2
                            local boxSize = Vector2.new(math.floor(charSize * 1.1), math.floor(charSize * 1.9))
                            local boxPosition = Vector2.new(math.floor(charhum2D.X - charSize * 1.1 / 2), math.floor(charhum2D.Y - charSize * 1.6 / 2))
                            if esp.box then
                                drawingInstances.Box.Size = boxSize
                                drawingInstances.Box.Position = boxPosition
                                drawingInstances.Box.Visible = true
                                drawingInstances.Box.Color = esp.boxcolor
                                drawingInstances.BoxOutline.Size = boxSize
                                drawingInstances.BoxOutline.Position = boxPosition
                                drawingInstances.BoxOutline.Visible = true
                                drawingInstances.BoxOutline.Color = esp.boxoutline
                                if esp.fading then
                                    drawingInstances.Box.Transparency = 1 - (math.sin(tick() * esp.espfadespeed) + 1) / 2
                                    drawingInstances.BoxOutline.Transparency = 1 - (math.sin(tick() * esp.espfadespeed) + 1) / 2
                                else
                                    drawingInstances.Box.Transparency = 1 - esp.boxtransparency
                                    drawingInstances.BoxOutline.Transparency = 1 - esp.boxoutlinetransparency
                                end
                            else
                                drawingInstances.Box.Visible = false
                                drawingInstances.BoxOutline.Visible = false
                            end
                            if esp.health then
                                drawingInstances.Health.From = Vector2.new((boxPosition.X - 5), boxPosition.Y + boxSize.Y)
                                drawingInstances.Health.To = Vector2.new(drawingInstances.Health.From.X, drawingInstances.Health.From.Y - (character.Humanoid.Health / character.Humanoid.MaxHealth) * boxSize.Y)
                                drawingInstances.Health.Color = esp.healthcolor
                                drawingInstances.Health.Visible = true
                                drawingInstances.HealthOutline.From = Vector2.new(drawingInstances.Health.From.X, boxPosition.Y + boxSize.Y + 1)
                                drawingInstances.HealthOutline.To = Vector2.new(drawingInstances.Health.From.X, (drawingInstances.Health.From.Y - 1 * boxSize.Y) -1)
                                drawingInstances.HealthOutline.Color = esp.healthoutline
                                drawingInstances.HealthOutline.Visible = true
                                if esp.fading then
                                    drawingInstances.Health.Transparency = 1 - (math.sin(tick() * esp.espfadespeed) + 1) / 2
                                    drawingInstances.HealthOutline.Transparency = 1 - (math.sin(tick() * esp.espfadespeed) + 1) / 2
                                else
                                    drawingInstances.Health.Transparency = 1 - esp.healthtransparency
                                    drawingInstances.HealthOutline.Transparency = 1 - esp.healthoutlinetransparency
                                end
                                if esp.healthbartext then
                                    drawingInstances.HealthText.Visible = true
                                    drawingInstances.HealthText.Text = string.format("%s", math.round(character.Humanoid.Health) .. "%")
                                    drawingInstances.HealthText.Position = Vector2.new(drawingInstances.Health.From.X - 15, drawingInstances.Health.From.Y - (character.Humanoid.Health / character.Humanoid.MaxHealth) * boxSize.Y)
                                    drawingInstances.HealthText.Color = esp.healthbartextcolor
                                    drawingInstances.HealthText.OutlineColor = esp.healthbartextoutline
                                    drawingInstances.HealthText.Font = Drawing.Fonts.Plex
                                    if esp.fading then
                                        drawingInstances.HealthText.Transparency = 1 - (math.sin(tick() * esp.espfadespeed) + 1) / 2
                                    else
                                        drawingInstances.HealthText.Transparency = 1 - esp.healthbartexttransparency
                                    end
                                else
                                    drawingInstances.HealthText.Visible = false
                                end
                            else
                                drawingInstances.Health.Visible = false
                                drawingInstances.HealthOutline.Visible = false
                                drawingInstances.HealthText.Visible = false
                            end
                            if esp.chams then
                                drawingInstances.Cham.Parent = character
                                drawingInstances.Cham.FillColor = esp.chamscolor
                                drawingInstances.Cham.OutlineColor = esp.chamsoutline
                                if esp.fading then
                                    drawingInstances.Cham.FillTransparency = (math.sin(tick() * esp.espfadespeed) + 1) / 2
                                    drawingInstances.Cham.OutlineTransparency = (math.sin(tick() * esp.espfadespeed) + 1) / 2
                                else
                                    drawingInstances.Cham.FillTransparency = esp.chamstransparencyinline
                                    drawingInstances.Cham.OutlineTransparency = esp.chamstransparencyoutline
                                end
                            else
                                drawingInstances.Cham.Parent = nil
                            end
                            if esp.name then
                                drawingInstances.Name.Visible = true
                                drawingInstances.Name.Text = string.format("<%s>", character.Humanoid.DisplayName)
                                drawingInstances.Name.Position = Vector2.new(boxSize.X / 2 + boxPosition.X, boxPosition.Y - 16)
                                drawingInstances.Name.Color = esp.namecolor
                                drawingInstances.Name.OutlineColor = esp.nameoutline
                                drawingInstances.Name.Font = Drawing.Fonts.Plex
                                if esp.fading then
                                    drawingInstances.Name.Transparency = 1 - (math.sin(tick() * esp.espfadespeed) + 1) / 2
                                else
                                    drawingInstances.Name.Transparency = 1 - esp.nametransparency
                                end
                            else
                                drawingInstances.Name.Visible = false
                            end
                        else
                            drawingInstances.Box.Visible = false
                            drawingInstances.BoxOutline.Visible = false
                            drawingInstances.Health.Visible = false
                            drawingInstances.HealthOutline.Visible = false
                            drawingInstances.Cham.Parent = nil
                            drawingInstances.Name.Visible = false
                            drawingInstances.HealthText.Visible = false
                        end
                    end
                else
                    drawingInstances.Box.Visible = false
                    drawingInstances.BoxOutline.Visible = false
                    drawingInstances.Health.Visible = false
                    drawingInstances.HealthOutline.Visible = false
                    drawingInstances.Cham.Parent = nil
                    drawingInstances.Name.Visible = false
                    drawingInstances.HealthText.Visible = false
                end
            end
        end
    end
end))
players.PlayerAdded:Connect(LPH_JIT_ULTRA(function(player)
    if player == localPlayer then return end
    esp.players[player] = {
        Box = Drawing.new("Square"),
        BoxOutline = Drawing.new("Square"),
        Health = Drawing.new("Line"),
        HealthOutline = Drawing.new("Line"),
        Cham = Instance.new("Highlight"),
        Name = Drawing.new("Text"),
        HealthText = Drawing.new("Text")
    }
    esp.players[player].Box.Visible = false
    esp.players[player].Box.Filled = false
    esp.players[player].Box.ZIndex = 999
    esp.players[player].Box.Thickness = 1
    esp.players[player].Box.Transparency = 1
    esp.players[player].BoxOutline.Visible = false
    esp.players[player].BoxOutline.Filled = false
    esp.players[player].BoxOutline.ZIndex = 1
    esp.players[player].BoxOutline.Color = Color3.fromRGB(0,0,0)
    esp.players[player].BoxOutline.Thickness = 3
    esp.players[player].BoxOutline.Transparency = 1
    esp.players[player].Health.Visible = false
    esp.players[player].Health.ZIndex = 999
    esp.players[player].Health.Thickness = 1
    esp.players[player].Health.Color = Color3.fromRGB(0,255,0)
    esp.players[player].Health.Transparency = 1
    esp.players[player].HealthOutline.Visible = false
    esp.players[player].HealthOutline.ZIndex = 0
    esp.players[player].HealthOutline.Thickness = 3
    esp.players[player].HealthOutline.Color = Color3.fromRGB(0,0,0)
    esp.players[player].HealthOutline.Transparency = 1
    esp.players[player].Name.Visible = false
    esp.players[player].Name.Size = 13
    esp.players[player].Name.Center = true
    esp.players[player].Name.Outline = true
    esp.players[player].Name.Font = Drawing.Fonts.Plex
    esp.players[player].Name.Color = Color3.fromRGB(255,255,255)
    esp.players[player].Name.Transparency = 1
    esp.players[player].HealthText.Visible = false
    esp.players[player].HealthText.Size = 13
    esp.players[player].HealthText.Center = true
    esp.players[player].HealthText.Outline = true
    esp.players[player].HealthText.Font = Drawing.Fonts.Plex
    esp.players[player].HealthText.Color = Color3.fromRGB(255,255,255)
    esp.players[player].HealthText.Transparency = 1
end))
players.PlayerRemoving:Connect(LPH_JIT_ULTRA(function(player)
    if esp.players[player] then
        for _, v in pairs(esp.players[player]) do
            if v.Remove then
                v:Remove()
            elseif typeof(v) == "Instance" then
                v.Parent = nil
                v:Destroy()
            end
        end
        esp.players[player] = nil
    end
end))
for i, v in next, players:GetPlayers() do
    if v ~= localPlayer then
        esp.players[v] = {
            Box = Drawing.new("Square"),
            BoxOutline = Drawing.new("Square"),
            Health = Drawing.new("Line"),
            HealthOutline = Drawing.new("Line"),
            Cham = Instance.new("Highlight"),
            Name = Drawing.new("Text"),
            HealthText = Drawing.new("Text")
        }
        esp.players[v].Box.Visible = false
        esp.players[v].Box.Filled = false
        esp.players[v].Box.ZIndex = 999
        esp.players[v].Box.Thickness = 1
        esp.players[v].BoxOutline.Visible = false
        esp.players[v].BoxOutline.Filled = false
        esp.players[v].BoxOutline.ZIndex = 1
        esp.players[v].BoxOutline.Color = Color3.fromRGB(0,0,0)
        esp.players[v].BoxOutline.Thickness = 3
        esp.players[v].Health.Visible = false
        esp.players[v].Health.ZIndex = 999
        esp.players[v].Health.Thickness = 1
        esp.players[v].Health.Color = Color3.fromRGB(0,255,0)
        esp.players[v].HealthOutline.Visible = false
        esp.players[v].HealthOutline.ZIndex = 0
        esp.players[v].HealthOutline.Thickness = 3
        esp.players[v].HealthOutline.Color = Color3.fromRGB(0,0,0)
        esp.players[v].Name.Visible = false
        esp.players[v].Name.Size = 13
        esp.players[v].Name.Center = true
        esp.players[v].Name.Outline = true
        esp.players[v].Name.Font = Drawing.Fonts.Plex
        esp.players[v].Name.Color = Color3.fromRGB(255,255,255)
        esp.players[v].HealthText.Visible = false
        esp.players[v].HealthText.Size = 13
        esp.players[v].HealthText.Center = true
        esp.players[v].HealthText.Outline = true
        esp.players[v].HealthText.Font = Drawing.Fonts.Plex
        esp.players[v].HealthText.Color = Color3.fromRGB(255,255,255)
    end
end
ESPGroup:AddToggle('ESPEnabled', {
    Text = 'Enabled',
    Default = false,
    Callback = function(Value)
        esp.enabled = Value
    end
})

ESPGroup:AddToggle('ESPBox', {
    Text = 'Box',
    Default = false,
    Callback = function(Value)
        esp.box = Value
    end
}):AddColorPicker('ESPBoxInline', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Inline',
    Transparency = 0,
    Callback = function(Value)
        esp.boxcolor = Value
        esp.boxtransparency = Value.Transparency or 0
    end
}):AddColorPicker('ESPBoxOutline', {
    Default = Color3.fromRGB(0,0,0),
    Title = 'Outline',
    Transparency = 0,
    Callback = function(Value)
        esp.boxoutline = Value
        esp.boxoutlinetransparency = Value.Transparency or 0
    end
})

ESPGroup:AddToggle('ESPHealth', {
    Text = 'Health',
    Default = false,
    Callback = function(Value)
        esp.health = Value
    end
}):AddColorPicker('ESPHealthInline', {
    Default = Color3.fromRGB(0,255,0),
    Title = 'Inline',
    Transparency = 0,
    Callback = function(Value)
        esp.healthcolor = Value
        esp.healthtransparency = Value.Transparency or 0
    end
}):AddColorPicker('ESPHealthOutline', {
    Default = Color3.fromRGB(0,0,0),
    Title = 'Outline',
    Transparency = 0,
    Callback = function(Value)
        esp.healthoutline = Value
        esp.healthoutlinetransparency = Value.Transparency or 0
    end
})

ESPGroup:AddToggle('ESPHealthBarText', {
    Text = 'Health Bar Text',
    Default = false,
    Callback = function(Value)
        esp.healthbartext = Value
    end
}):AddColorPicker('ESPHealthBarTextInline', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Inline',
    Transparency = 0,
    Callback = function(Value)
        esp.healthbartextcolor = Value
        esp.healthbartexttransparency = Value.Transparency or 0
    end
}):AddColorPicker('ESPHealthBarTextOutline', {
    Default = Color3.fromRGB(0,0,0),
    Title = 'Outline',
    Callback = function(Value)
        esp.healthbartextoutline = Value
    end
})

ESPGroup:AddToggle('ESPChams', {
    Text = 'Chams',
    Default = false,
    Callback = function(Value)
        esp.chams = Value
    end
}):AddColorPicker('ESPChamsInline', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Inline',
    Transparency = 0.5,
    Callback = function(Value)
        esp.chamscolor = Value
        esp.chamstransparencyinline = Value.Transparency or 0.5
    end
}):AddColorPicker('ESPChamsOutline', {
    Default = Color3.fromRGB(0,0,0),
    Title = 'Outline',
    Transparency = 0.5,
    Callback = function(Value)
        esp.chamsoutline = Value
        esp.chamstransparencyoutline = Value.Transparency or 0.5
    end
})

ESPGroup:AddToggle('ESPName', {
    Text = 'Name',
    Default = false,
    Callback = function(Value)
        esp.name = Value
    end
}):AddColorPicker('ESPNameInline', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Inline',
    Transparency = 0,
    Callback = function(Value)
        esp.namecolor = Value
        esp.nametransparency = Value.Transparency or 0
    end
}):AddColorPicker('ESPNameOutline', {
    Default = Color3.fromRGB(0,0,0),
    Title = 'Outline',
    Callback = function(Value)
        esp.nameoutline = Value
    end
})

ESPGroup:AddSlider('ESPRenderDistance', {
    Text = 'Render Distance',
    Default = 10000,
    Min = 1,
    Max = 10000,
    Rounding = 0,
    Callback = function(Value)
        esp.renderdistance = Value
    end
})

ESPGroup:AddToggle('ESPFade', {
    Text = 'ESP Fade',
    Default = false,
    Callback = function(Value)
        esp.fading = Value
    end
})

ESPGroup:AddSlider('ESPFadeSpeed', {
    Text = 'ESP Fade Speed',
    Default = 5,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        esp.espfadespeed = Value
    end
})
coroutine.wrap(function()
-- Table cho các aura (hỗ trợ nhiều)
local Auras = {
    Selected = {},  -- Các aura được chọn từ dropdown (multi)
    Enabled = false,  -- Toggle chung
}

-- Màu chung cho tất cả aura
local AuraColor = Color3.new(1, 1, 1)  -- Default white

-- Function để attach Aura Wing (dựa XML gốc, đầy đủ thuộc tính)
local function AttachAuraWing(character)
    local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
    if not torso then return end
    
    -- Destroy old if exists
    for _, child in ipairs(torso:GetChildren()) do
        if child.Name == "AuraWing" then child:Destroy() end
    end
    
    local container = Instance.new("Folder")
    container.Name = "AuraWing"
    container.Parent = torso

    local pointLight = Instance.new("PointLight")
    pointLight.Range = 5
    pointLight.Brightness = 4
    pointLight.Color = AuraColor
    pointLight.Enabled = true
    pointLight.Shadows = false
    pointLight.Parent = container

    local attach1 = Instance.new("Attachment")
    attach1.CFrame = CFrame.new(5.25, 0, 2) * CFrame.fromMatrix(Vector3.zero, Vector3.new(0.866025388, 0, 0.5), Vector3.new(0, 1, 0), Vector3.new(-0.5, 0, 0.866025388))
    attach1.Parent = container

    local attach2 = Instance.new("Attachment")
    attach2.CFrame = CFrame.new(-5.25, 0, 2) * CFrame.fromMatrix(Vector3.zero, Vector3.new(0.866025388, 0, -0.5), Vector3.new(0, 1, 0), Vector3.new(0.5, 0, 0.866025388))
    attach2.Parent = container

    local attach3 = Instance.new("Attachment")
    attach3.CFrame = CFrame.new(0, 0.75, 0.5)
    attach3.Parent = container

    local beam1 = Instance.new("Beam")
    beam1.Attachment0 = attach3
    beam1.Attachment1 = attach2
    beam1.Brightness = 1
    beam1.Color = ColorSequence.new(AuraColor)
    beam1.CurveSize0 = 2
    beam1.CurveSize1 = 2
    beam1.Enabled = true
    beam1.FaceCamera = false
    beam1.LightEmission = 1
    beam1.LightInfluence = 1
    beam1.Segments = 10
    beam1.Texture = "rbxassetid://9544400688"
    beam1.TextureLength = 1
    beam1.TextureMode = Enum.TextureMode.Stretch
    beam1.TextureSpeed = 0
    beam1.Transparency = NumberSequence.new(0, 0)
    beam1.Width0 = 4
    beam1.Width1 = 6
    beam1.ZOffset = 0
    beam1.Parent = container

    local beam2 = Instance.new("Beam")
    beam2.Attachment0 = attach3
    beam2.Attachment1 = attach1
    beam2.Brightness = 1
    beam2.Color = ColorSequence.new(AuraColor)
    beam2.CurveSize0 = -2
    beam2.CurveSize1 = -2
    beam2.Enabled = true
    beam2.FaceCamera = false
    beam2.LightEmission = 1
    beam2.LightInfluence = 1
    beam2.Segments = 10
    beam2.Texture = "rbxassetid://9544400688"
    beam2.TextureLength = 1
    beam2.TextureMode = Enum.TextureMode.Stretch
    beam2.TextureSpeed = 0
    beam2.Transparency = NumberSequence.new(0, 0)
    beam2.Width0 = 4
    beam2.Width1 = 6
    beam2.ZOffset = 0
    beam2.Parent = container

    local attach4 = Instance.new("Attachment")
    attach4.CFrame = CFrame.new(0, 4.25, 0)
    attach4.Parent = container

    local particle1 = Instance.new("ParticleEmitter")
    particle1.Acceleration = Vector3.new(0, -6, 0)
    particle1.Brightness = 1
    particle1.Color = ColorSequence.new(AuraColor)
    particle1.Drag = 0
    particle1.EmissionDirection = Enum.NormalId.Top
    particle1.Enabled = true
    particle1.FlipbookFramerate = NumberRange.new(1, 1)
    particle1.FlipbookLayout = Enum.ParticleFlipbookLayout.None
    particle1.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    particle1.Lifetime = NumberRange.new(1, 2)
    particle1.LightEmission = 1
    particle1.LightInfluence = 1
    particle1.LockedToPart = true
    particle1.Orientation = Enum.ParticleOrientation.FacingCamera
    particle1.Rate = 50
    particle1.RotSpeed = NumberRange.new(-100, 100)
    particle1.Rotation = NumberRange.new(-360, 360)
    particle1.Shape = Enum.ParticleEmitterShape.Box
    particle1.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
    particle1.ShapePartial = 1
    particle1.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
    particle1.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.5), NumberSequenceKeypoint.new(1, 0.3)})
    particle1.Speed = NumberRange.new(2.5, 2.5)
    particle1.SpreadAngle = Vector2.new(0, 360)
    particle1.Squash = NumberSequence.new(0, 0)
    particle1.Texture = "http://www.roblox.com/asset/?id=7511321694"
    particle1.TimeScale = 1
    particle1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.1, 1), NumberSequenceKeypoint.new(0.3, 0), NumberSequenceKeypoint.new(0.8, 0), NumberSequenceKeypoint.new(1, 1)})
    particle1.VelocityInheritance = 0
    particle1.WindAffectsDrag = false
    particle1.ZOffset = 0
    particle1.Parent = attach4

    local particle2 = Instance.new("ParticleEmitter")
    particle2.Acceleration = Vector3.new(0, -6, 0)
    particle2.Brightness = 1
    particle2.Color = ColorSequence.new(AuraColor)
    particle2.Drag = 0
    particle2.EmissionDirection = Enum.NormalId.Top
    particle2.Enabled = true
    particle2.FlipbookFramerate = NumberRange.new(1, 1)
    particle2.FlipbookLayout = Enum.ParticleFlipbookLayout.None
    particle2.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    particle2.Lifetime = NumberRange.new(1, 2)
    particle2.LightEmission = 1
    particle2.LightInfluence = 1
    particle2.LockedToPart = true
    particle2.Orientation = Enum.ParticleOrientation.FacingCamera
    particle2.Rate = 100
    particle2.RotSpeed = NumberRange.new(-100, 100)
    particle2.Rotation = NumberRange.new(-360, 360)
    particle2.Shape = Enum.ParticleEmitterShape.Box
    particle2.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
    particle2.ShapePartial = 1
    particle2.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
    particle2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.5), NumberSequenceKeypoint.new(1, 0.3)})
    particle2.Speed = NumberRange.new(2.5, 2.5)
    particle2.SpreadAngle = Vector2.new(0, 360)
    particle2.Squash = NumberSequence.new(0, 0)
    particle2.Texture = "rbxassetid://1084976679"
    particle2.TimeScale = 1
    particle2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.2, 0), NumberSequenceKeypoint.new(0.8, 0), NumberSequenceKeypoint.new(1, 1)})
    particle2.VelocityInheritance = 0
    particle2.WindAffectsDrag = false
    particle2.ZOffset = 0
    particle2.Parent = attach4
end

-- Function để attach Aura WingAngel (variant, đầy đủ thuộc tính)
local function AttachAuraWingAngel(character)
    local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
    if not torso then return end
    
    -- Destroy old
    for _, child in ipairs(torso:GetChildren()) do
        if child.Name == "AuraWingAngel" then child:Destroy() end
    end
    
    local container = Instance.new("Folder")
    container.Name = "AuraWingAngel"
    container.Parent = torso

    local pointLight = Instance.new("PointLight")
    pointLight.Range = 6
    pointLight.Brightness = 5
    pointLight.Color = AuraColor
    pointLight.Enabled = true
    pointLight.Shadows = true
    pointLight.Parent = container

    local attach1 = Instance.new("Attachment")
    attach1.CFrame = CFrame.new(6, 1, 2.5) * CFrame.Angles(math.rad(10), math.rad(35), 0)
    attach1.Parent = container

    local attach2 = Instance.new("Attachment")
    attach2.CFrame = CFrame.new(-6, 1, 2.5) * CFrame.Angles(math.rad(10), math.rad(-35), 0)
    attach2.Parent = container

    local attach3 = Instance.new("Attachment")
    attach3.CFrame = CFrame.new(0, 1, 0.75)
    attach3.Parent = container

    local beam1 = Instance.new("Beam")
    beam1.Attachment0 = attach3
    beam1.Attachment1 = attach2
    beam1.Brightness = 1.2
    beam1.Color = ColorSequence.new(AuraColor)
    beam1.CurveSize0 = 3
    beam1.CurveSize1 = 3
    beam1.Enabled = true
    beam1.FaceCamera = false
    beam1.LightEmission = 1
    beam1.LightInfluence = 1
    beam1.Segments = 10
    beam1.Texture = "rbxassetid://9544400688"
    beam1.TextureLength = 1
    beam1.TextureMode = Enum.TextureMode.Stretch
    beam1.TextureSpeed = 0
    beam1.Transparency = NumberSequence.new(0, 0)
    beam1.Width0 = 5
    beam1.Width1 = 7
    beam1.ZOffset = 0
    beam1.Parent = container

    local beam2 = Instance.new("Beam")
    beam2.Attachment0 = attach3
    beam2.Attachment1 = attach1
    beam2.Brightness = 1.2
    beam2.Color = ColorSequence.new(AuraColor)
    beam2.CurveSize0 = -3
    beam2.CurveSize1 = -3
    beam2.Enabled = true
    beam2.FaceCamera = false
    beam2.LightEmission = 1
    beam2.LightInfluence = 1
    beam2.Segments = 10
    beam2.Texture = "rbxassetid://9544400688"
    beam2.TextureLength = 1
    beam2.TextureMode = Enum.TextureMode.Stretch
    beam2.TextureSpeed = 0
    beam2.Transparency = NumberSequence.new(0, 0)
    beam2.Width0 = 5
    beam2.Width1 = 7
    beam2.ZOffset = 0
    beam2.Parent = container

    local attach5 = Instance.new("Attachment")
    attach5.CFrame = CFrame.new(0, 5, 0)
    attach5.Parent = container

    local beam3 = Instance.new("Beam")
    beam3.Attachment0 = attach3
    beam3.Attachment1 = attach5
    beam3.Brightness = 1
    beam3.Color = ColorSequence.new(AuraColor)
    beam3.CurveSize0 = 0
    beam3.CurveSize1 = 0
    beam3.Enabled = true
    beam3.FaceCamera = false
    beam3.LightEmission = 1
    beam3.LightInfluence = 1
    beam3.Segments = 10
    beam3.Texture = "rbxassetid://9544400688"
    beam3.TextureLength = 1
    beam3.TextureMode = Enum.TextureMode.Stretch
    beam3.TextureSpeed = 0
    beam3.Transparency = NumberSequence.new(0, 0)
    beam3.Width0 = 3
    beam3.Width1 = 4
    beam3.ZOffset = 0
    beam3.Parent = container

    local attach4 = Instance.new("Attachment")
    attach4.CFrame = CFrame.new(0, 4.5, 0)
    attach4.Parent = container

    local particle1 = Instance.new("ParticleEmitter")
    particle1.Acceleration = Vector3.new(0, -7, 0)
    particle1.Brightness = 1.2
    particle1.Color = ColorSequence.new(AuraColor)
    particle1.Drag = 0
    particle1.EmissionDirection = Enum.NormalId.Top
    particle1.Enabled = true
    particle1.FlipbookFramerate = NumberRange.new(1, 1)
    particle1.FlipbookLayout = Enum.ParticleFlipbookLayout.None
    particle1.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    particle1.Lifetime = NumberRange.new(1.5, 2.5)
    particle1.LightEmission = 1
    particle1.LightInfluence = 1
    particle1.LockedToPart = true
    particle1.Orientation = Enum.ParticleOrientation.FacingCamera
    particle1.Rate = 60
    particle1.RotSpeed = NumberRange.new(-120, 120)
    particle1.Rotation = NumberRange.new(-360, 360)
    particle1.Shape = Enum.ParticleEmitterShape.Box
    particle1.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
    particle1.ShapePartial = 1
    particle1.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
    particle1.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6), NumberSequenceKeypoint.new(1, 0.4)})
    particle1.Speed = NumberRange.new(3, 3)
    particle1.SpreadAngle = Vector2.new(0, 360)
    particle1.Squash = NumberSequence.new(0, 0)
    particle1.Texture = "http://www.roblox.com/asset/?id=7511321694"
    particle1.TimeScale = 1
    particle1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1, 0), NumberSequenceKeypoint.new(0.3, 0), NumberSequenceKeypoint.new(0.8, 0), NumberSequenceKeypoint.new(1, 1)})
    particle1.VelocityInheritance = 0
    particle1.WindAffectsDrag = false
    particle1.ZOffset = 0
    particle1.Parent = attach4

    local particle2 = Instance.new("ParticleEmitter")
    particle2.Acceleration = Vector3.new(0, -7, 0)
    particle2.Brightness = 1.2
    particle2.Color = ColorSequence.new(AuraColor)
    particle2.Drag = 0
    particle2.EmissionDirection = Enum.NormalId.Top
    particle2.Enabled = true
    particle2.FlipbookFramerate = NumberRange.new(1, 1)
    particle2.FlipbookLayout = Enum.ParticleFlipbookLayout.None
    particle2.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    particle2.Lifetime = NumberRange.new(1.5, 2.5)
    particle2.LightEmission = 1
    particle2.LightInfluence = 1
    particle2.LockedToPart = true
    particle2.Orientation = Enum.ParticleOrientation.FacingCamera
    particle2.Rate = 120
    particle2.RotSpeed = NumberRange.new(-120, 120)
    particle2.Rotation = NumberRange.new(-360, 360)
    particle2.Shape = Enum.ParticleEmitterShape.Box
    particle2.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
    particle2.ShapePartial = 1
    particle2.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
    particle2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6), NumberSequenceKeypoint.new(1, 0.4)})
    particle2.Speed = NumberRange.new(3, 3)
    particle2.SpreadAngle = Vector2.new(0, 360)
    particle2.Squash = NumberSequence.new(0, 0)
    particle2.Texture = "rbxassetid://1084976679"
    particle2.TimeScale = 1
    particle2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.2, 0), NumberSequenceKeypoint.new(0.8, 0), NumberSequenceKeypoint.new(1, 1)})
    particle2.VelocityInheritance = 0
    particle2.WindAffectsDrag = false
    particle2.ZOffset = 0
    particle2.Parent = attach4
end

-- Function để attach Aura Safe (mới, đầy đủ thuộc tính từ XML)
local function AttachAuraSafe(character)
    local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
    if not torso then return end
    
    -- Destroy old
    for _, child in ipairs(torso:GetChildren()) do
        if child.Name == "AuraSafe" then child:Destroy() end
    end
    
    local container = Instance.new("Folder")
    container.Name = "AuraSafe"
    container.Parent = torso

    local pointLight = Instance.new("PointLight")
    pointLight.Range = 5
    pointLight.Brightness = 3
    pointLight.Color = AuraColor
    pointLight.Enabled = true
    pointLight.Shadows = false
    pointLight.Parent = container

    local glowAttach = Instance.new("Attachment")
    glowAttach.Name = "Glow"
    glowAttach.CFrame = CFrame.new(0, 0, 0)
    glowAttach.Parent = container

    local particleGlow = Instance.new("ParticleEmitter")
    particleGlow.Acceleration = Vector3.new(0, 0, 0)
    particleGlow.Brightness = 1
    particleGlow.Color = ColorSequence.new(AuraColor)
    particleGlow.Drag = 0
    particleGlow.EmissionDirection = Enum.NormalId.Back
    particleGlow.Enabled = true
    particleGlow.FlipbookFramerate = NumberRange.new(1, 1)
    particleGlow.FlipbookLayout = Enum.ParticleFlipbookLayout.None
    particleGlow.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
    particleGlow.Lifetime = NumberRange.new(1, 1)
    particleGlow.LightEmission = 1
    particleGlow.LightInfluence = 1
    particleGlow.LockedToPart = true
    particleGlow.Orientation = Enum.ParticleOrientation.FacingCamera
    particleGlow.Rate = 4
    particleGlow.RotSpeed = NumberRange.new(0, 0)
    particleGlow.Rotation = NumberRange.new(0, 0)
    particleGlow.Shape = Enum.ParticleEmitterShape.Box
    particleGlow.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
    particleGlow.ShapePartial = 1
    particleGlow.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
    particleGlow.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 4.25), NumberSequenceKeypoint.new(0.5, 0), NumberSequenceKeypoint.new(1, 3.375)})
    particleGlow.Speed = NumberRange.new(0.001, 0.001)
    particleGlow.SpreadAngle = Vector2.new(0, 0)
    particleGlow.Squash = NumberSequence.new(0, 0)
    particleGlow.Texture = "rbxassetid://1075864321"
    particleGlow.TimeScale = 1
    particleGlow.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5, 0), NumberSequenceKeypoint.new(1, 1)})
    particleGlow.VelocityInheritance = 0
    particleGlow.WindAffectsDrag = false
    particleGlow.ZOffset = -1
    particleGlow.Parent = glowAttach

    local attach2Upper = Instance.new("Attachment")
    attach2Upper.Name = "2"
    attach2Upper.CFrame = CFrame.new(0, 2.125, 0)
    attach2Upper.Parent = container

    local attach2Lower = Instance.new("Attachment")
    attach2Lower.Name = "2"
    attach2Lower.CFrame = CFrame.new(0, -3, 0)
    attach2Lower.Parent = container

    local beamSafe1 = Instance.new("Beam")
    beamSafe1.Attachment0 = attach2Lower
    beamSafe1.Attachment1 = attach2Upper
    beamSafe1.Brightness = 1
    beamSafe1.Color = ColorSequence.new(Color3.new(0.333333, 0.666667, 1), Color3.new(0.333333, 0.666667, 1))
    beamSafe1.CurveSize0 = 0
    beamSafe1.CurveSize1 = 0
    beamSafe1.Enabled = true
    beamSafe1.FaceCamera = true
    beamSafe1.LightEmission = 1
    beamSafe1.LightInfluence = 1
    beamSafe1.Segments = 10
    beamSafe1.Texture = "rbxassetid://7673945506"
    beamSafe1.TextureLength = 0.3
    beamSafe1.TextureMode = Enum.TextureMode.Stretch
    beamSafe1.TextureSpeed = 2
    beamSafe1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5, 0), NumberSequenceKeypoint.new(1, 1)})
    beamSafe1.Width0 = 6
    beamSafe1.Width1 = 6
    beamSafe1.ZOffset = 1
    beamSafe1.Parent = container

    local beamSafe2 = Instance.new("Beam")
    beamSafe2.Attachment0 = attach2Lower
    beamSafe2.Attachment1 = attach2Upper
    beamSafe2.Brightness = 1
    beamSafe2.Color = ColorSequence.new(Color3.new(0, 0.666667, 0), Color3.new(0, 0.666667, 0))
    beamSafe2.CurveSize0 = 0
    beamSafe2.CurveSize1 = 0
    beamSafe2.Enabled = true
    beamSafe2.FaceCamera = true
    beamSafe2.LightEmission = 1
    beamSafe2.LightInfluence = 1
    beamSafe2.Segments = 10
    beamSafe2.Texture = "http://www.roblox.com/asset/?id=6045867277"
    beamSafe2.TextureLength = 0.1
    beamSafe2.TextureMode = Enum.TextureMode.Stretch
    beamSafe2.TextureSpeed = 1
    beamSafe2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5, 0), NumberSequenceKeypoint.new(1, 1)})
    beamSafe2.Width0 = 5
    beamSafe2.Width1 = 5
    beamSafe2.ZOffset = 1
    beamSafe2.Parent = container

    local beamSafe3 = Instance.new("Beam")
    beamSafe3.Attachment0 = attach2Lower
    beamSafe3.Attachment1 = attach2Upper
    beamSafe3.Brightness = 1
    beamSafe3.Color = ColorSequence.new(Color3.new(1, 0.333333, 1), Color3.new(1, 0.333333, 1))
    beamSafe3.CurveSize0 = 0
    beamSafe3.CurveSize1 = 0
    beamSafe3.Enabled = true
    beamSafe3.FaceCamera = true
    beamSafe3.LightEmission = 1
    beamSafe3.LightInfluence = 1
    beamSafe3.Segments = 10
    beamSafe3.Texture = "rbxassetid://1849531275"
    beamSafe3.TextureLength = 0.1
    beamSafe3.TextureMode = Enum.TextureMode.Stretch
    beamSafe3.TextureSpeed = 1
    beamSafe3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5, 0), NumberSequenceKeypoint.new(1, 1)})
    beamSafe3.Width0 = 6
    beamSafe3.Width1 = 6
    beamSafe3.ZOffset = 1
    beamSafe3.Parent = container

    local topSymbolAttach = Instance.new("Attachment")
    topSymbolAttach.Name = "1TopSymbol"
    topSymbolAttach.CFrame = CFrame.new(0, 5.75001049, 1) * CFrame.fromMatrix(Vector3.zero, Vector3.new(0, 0, -1), Vector3.new(-1, 0, 0), Vector3.new(0, 1, 0))
    topSymbolAttach.Parent = container

    local bottomSymbolAttach = Instance.new("Attachment")
    bottomSymbolAttach.Name = "1BottomSymbol"
    bottomSymbolAttach.CFrame = CFrame.new(0, -1.24998808, 1) * CFrame.fromMatrix(Vector3.zero, Vector3.new(0, 0, -1), Vector3.new(-1, 0, 0), Vector3.new(0, 1, 0))
    bottomSymbolAttach.Parent = container

    local beamSymbol = Instance.new("Beam")
    beamSymbol.Attachment0 = topSymbolAttach
    beamSymbol.Attachment1 = bottomSymbolAttach
    beamSymbol.Brightness = 1
    beamSymbol.Color = ColorSequence.new(AuraColor)
    beamSymbol.CurveSize0 = 0.5
    beamSymbol.CurveSize1 = 0.5
    beamSymbol.Enabled = true
    beamSymbol.FaceCamera = false
    beamSymbol.LightEmission = 1
    beamSymbol.LightInfluence = 1
    beamSymbol.Segments = 100
    beamSymbol.Texture = "rbxassetid://8285797183"
    beamSymbol.TextureLength = 1
    beamSymbol.TextureMode = Enum.TextureMode.Stretch
    beamSymbol.TextureSpeed = 0
    beamSymbol.Transparency = NumberSequence.new(0, 0)
    beamSymbol.Width0 = 7
    beamSymbol.Width1 = 7
    beamSymbol.ZOffset = 0
    beamSymbol.Parent = container
end

local function AttachAuras(character)
    -- Clear all old auras first
    for _, child in ipairs(character:GetChildren()) do
        if child:IsA("Folder") and string.find(child.Name, "Aura") then child:Destroy() end
    end
    
    if not Auras.Enabled then return end
    
    for _, aura in ipairs(Auras.Selected) do
        if aura == "Wing" then
            AttachAuraWing(character)
        elseif aura == "WingAngel" then
            AttachAuraWingAngel(character)
        elseif aura == "Safe" then
            AttachAuraSafe(character)
        end
        -- Thêm aura khác nếu có
    end
end

--[[local AuraGroup = Tabs.Visual:AddRightGroupbox('Aura')

local AuraConnection = nil

local function ApplyAuras()
    local char = localPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end

    -- Xóa hết aura cũ trước
    for _, folderName in pairs({"AuraWing", "AuraWingAngel", "AuraSafe"}) do
        local old = char:FindFirstChild(folderName) or (char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")):FindFirstChild(folderName)
        if old then old:Destroy() end
    end

    if not Auras.Enabled or #Auras.Selected == 0 then return end

    for _, auraName in pairs(Auras.Selected) do
        if auraName == "Wing" then
            AttachAuraWing(char)
        elseif auraName == "WingAngel" then
            AttachAuraWingAngel(char)
        elseif auraName == "Safe" then
            AttachAuraSafe(char)
        end
    end
end

-- Khi toggle bật/tắt, chọn aura, đổi màu → apply ngay lập tức
local function StartAuraLoop()
    if AuraConnection then AuraConnection:Disconnect() end
    AuraConnection = RunService.Heartbeat:Connect(function()
        if Auras.Enabled and localPlayer.Character then
            ApplyAuras()
        end
    end)
end

-- UI Callbacks (chỉ cần thay callback thành gọi ApplyAuras)
AuraGroup:AddToggle('AuraEnabledToggle', {
    Text = 'Aura Enabled',
    Default = false,
    Callback = function(Value)
        Auras.Enabled = Value
        if Value then
            ApplyAuras()
            StartAuraLoop() -- bắt đầu loop update realtime
        else
            if AuraConnection then AuraConnection:Disconnect() end
            -- Xóa aura nếu tắt
            pcall(function()
                local torso = localPlayer.Character:FindFirstChild("UpperTorso") or localPlayer.Character:FindFirstChild("Torso")
                if torso then
                    for _, v in pairs(torso:GetChildren()) do
                        if v.Name:find("Aura") then v:Destroy() end
                    end
                end
            end)
        end
    end
}):AddColorPicker('AuraColorPicker', {
    Default = Color3.new(1,1,1),
    Title = 'Aura Color',
    Callback = function(Value)
        AuraColor = Value
        ApplyAuras() -- đổi màu realtime luôn
    end
})

AuraGroup:AddDropdown('AuraSelect', {
    Values = {'Wing', 'WingAngel', 'Safe'},
    Default = {},
    Multi = true,
    Text = 'Select Auras',
    Callback = function(Value)
        Auras.Selected = Value
        ApplyAuras() -- đổi aura realtime luôn
    end
})

-- Respawn vẫn giữ aura
localPlayer.CharacterAdded:Connect(function(char)
    char:WaitForChild("HumanoidRootPart", 10)
    task.wait(1)
    if Auras.Enabled then
        ApplyAuras()
        if Auras.Enabled then StartAuraLoop() end
    end
end)

-- Nếu đang trong game và bật aura thì apply ngay
if localPlayer.Character and Auras.Enabled then
    ApplyAuras()
    StartAuraLoop()
end]]
end)()
local SelfGroup = Tabs.Visual:AddRightGroupbox('Self')
utility = utility or {}

local Settings = {
    Visuals = {
        Character_Trail = {
            Trail_Color = Color3.fromRGB(255, 255, 255),
            Trail_Life = 1.6
        }
    }
}
Settings.Visuals.Character_Chams = {
    Enabled = false,
    Color = Color3.fromRGB(255, 255, 255),
    Material = Enum.Material.ForceField
}

Settings.Visuals.Weapon_Chams = {
    Enabled = false,
    Color = Color3.fromRGB(255, 255, 255),
    Material = Enum.Material.Neon
}

local function applyChams(character)
    if Settings.Visuals.Character_Chams.Enabled and character then
        for i, v in pairs(character:GetDescendants()) do
            if (v.Parent:IsA('Tool') and (v:IsA('MeshPart') or v:IsA('BasePart'))) then continue end
            if v:IsA('MeshPart') then
                v.Material = Settings.Visuals.Character_Chams.Material
                v.Color = Settings.Visuals.Character_Chams.Color
                v.TextureID = ''
            end
            if v:IsA('BasePart') then
                v.Material = Settings.Visuals.Character_Chams.Material
                v.Color = Settings.Visuals.Character_Chams.Color
            end
        end
    end
    if Settings.Visuals.Weapon_Chams.Enabled and character then
        local Gun = character:FindFirstChildOfClass("Tool")
        if Gun then
            for i, v in pairs(Gun:GetChildren()) do
                if v:IsA('MeshPart') then
                    v.Material = Settings.Visuals.Weapon_Chams.Material
                    v.Color = Settings.Visuals.Weapon_Chams.Color
                    v.TextureID = ''
                end
                if v:IsA('BasePart') then
                    v.Material = Settings.Visuals.Weapon_Chams.Material
                    v.Color = Settings.Visuals.Weapon_Chams.Color
                end
            end
        end
    end
end
local function onChamsCharacter(character)
    task.wait(2)
    applyChams(character)
    character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            applyChams(character)
        end
    end)
end

localPlayer.CharacterAdded:Connect(onChamsCharacter)
if localPlayer.Character then
    onChamsCharacter(localPlayer.Character)
end


SelfGroup:AddToggle('WeaponChamsEnabled', {
    Text = 'Weapon Enabled',
    Default = false,
    Callback = function(Value)
        Settings.Visuals.Weapon_Chams.Enabled = Value
        applyChams(localPlayer.Character)
    end
}):AddColorPicker('WeaponChamsColor', {
    Default = Settings.Visuals.Weapon_Chams.Color,
    Title = 'Weapon Color',
    Callback = function(Value)
        Settings.Visuals.Weapon_Chams.Color = Value
        applyChams(localPlayer.Character)
    end
}):AddDropdown('WeaponChamsType', {
    Values = {'Neon', 'ForceField'},
    Default = 'Neon',
    Multi = false,
    Text = 'Weapon Cham Type',
    Callback = function(Value)
        if Value == 'Neon' then
            Settings.Visuals.Weapon_Chams.Material = Enum.Material.Neon
        elseif Value == 'ForceField' then
            Settings.Visuals.Weapon_Chams.Material = Enum.Material.ForceField
        end
        applyChams(localPlayer.Character)
    end
})

SelfGroup:AddToggle('ClientChamsEnabled', {
    Text = 'Client Enabled',
    Default = false,
    Callback = function(Value)
        Settings.Visuals.Character_Chams.Enabled = Value
        applyChams(localPlayer.Character)
    end
}):AddColorPicker('ClientChamsColor', {
    Default = Settings.Visuals.Character_Chams.Color,
    Title = 'Client Color',
    Callback = function(Value)
        Settings.Visuals.Character_Chams.Color = Value
        applyChams(localPlayer.Character)
    end
}):AddDropdown('ClientChamsType', {
    Values = {'Force Field', 'Neon'},
    Default = 'Force Field',
    Multi = false,
    Text = 'Client Cham Type',
    Callback = function(Value)
        if Value == 'Force Field' then
            Settings.Visuals.Character_Chams.Material = Enum.Material.ForceField
        elseif Value == 'Neon' then
            Settings.Visuals.Character_Chams.Material = Enum.Material.Neon
        end
        applyChams(localPlayer.Character)
    end
})
local function ToggleTrail(Bool)
    for i,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
        if v:IsA("BasePart") then
            if Bool then
                local BlaBla = Instance.new("Trail", v)
                BlaBla.Texture = "rbxassetid://1390780157"
                BlaBla.Parent = v
                local Pointer1 = Instance.new("Attachment", v)
                Pointer1.Name = "Pointer1"
                local Pointer2 = Instance.new("Attachment", game.Players.LocalPlayer.Character.HumanoidRootPart)
                Pointer2.Name = "Pointer2"
                BlaBla.Attachment0 = Pointer1
                BlaBla.Attachment1 = Pointer2
                BlaBla.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Settings.Visuals.Character_Trail.Trail_Color), ColorSequenceKeypoint.new(1, Settings.Visuals.Character_Trail.Trail_Color)});
                BlaBla.Lifetime = Settings.Visuals.Character_Trail.Trail_Life
                BlaBla.Name = "BlaBla" -- Set the name
            else
                for _, child in ipairs(v:GetChildren()) do
                    if child:IsA("Trail") and child.Name == 'BlaBla' then -- Corrected the condition
                        child:Destroy()
                    end
                end
            end
        end
    end
end

localPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    if getgenv().trailEnabled then
        ToggleTrail(true)
    end
end)
if localPlayer.Character then 
    if getgenv().trailEnabled then
        ToggleTrail(true)
    end
end

SelfGroup:AddToggle("TrailToggle", {
    Text = "Trail",
    Default = false,
    Callback = function(state)
        getgenv().trailEnabled = state
        ToggleTrail(state)
    end
}):AddColorPicker("TrailColor", {
    Default = Settings.Visuals.Character_Trail.Trail_Color,
    Title = "Trail Color",
    Callback = function(color)
        Settings.Visuals.Character_Trail.Trail_Color = color
        if getgenv().trailEnabled then
            ToggleTrail(false)
            ToggleTrail(true)
        end
    end
})

SelfGroup:AddSlider("TrailLifetime", {
    Text = "Trail Lifetime",
    Default = 1.6,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Callback = function(value)
        Settings.Visuals.Character_Trail.Trail_Life = value
        if getgenv().trailEnabled then
            ToggleTrail(false)
            ToggleTrail(true)
        end
    end
})

coroutine.wrap(function()
local BulletTracerGroup = Tabs.Visual:AddLeftGroupbox('BulletTracer')
matchacc.BulletTracers = {
    Enabled = false,
    TextureID = "rbxassetid://12781852245",
    Color = Color3.new(255, 255, 255),
    Size = 0.4,
    Transparency = 0,
    TimeAlive = 3,
}

-- // Bullet Tracers
local function bullettracerlol(startPos, endPos)
    local startPart = Instance.new("Part")
    startPart.Name = "BulletStart"
    startPart.Anchored = true
    startPart.CanCollide = false
    startPart.Transparency = 1
    startPart.Size = Vector3.new(0.2, 0.2, 0.2)
    startPart.Material = Enum.Material.ForceField
    startPart.Color = Color3.new(1, 0, 0)
    startPart.Transparency = 1
    startPart.CanTouch = false
    startPart.CanQuery = false
    startPart.Massless = true
    startPart.CollisionGroupId = 0
    startPart.Position = startPos
    startPart.Parent = workspace

    local endPart = Instance.new("Part")
    endPart.Name = "BulletEnd"
    endPart.Anchored = true
    endPart.CanCollide = false
    endPart.Size = Vector3.new(0.2, 0.2, 0.2)
    endPart.Material = Enum.Material.ForceField
    endPart.Color = Color3.new(1, 0, 0)
    endPart.Transparency = 1
    endPart.CanTouch = false
    endPart.CanQuery = false
    endPart.Massless = true
    endPart.CollisionGroupId = 0
    endPart.Position = endPos
    endPart.Parent = workspace

    local beam = Instance.new("Beam")
    beam.Attachment0 = Instance.new("Attachment", startPart)
    beam.Attachment1 = Instance.new("Attachment", endPart)
    beam.Parent = startPart
    beam.FaceCamera = true
    beam.Color = ColorSequence.new(matchacc.BulletTracers.Color)
    beam.Texture = matchacc.BulletTracers.TextureID
    beam.LightEmission = 1
    beam.Transparency = NumberSequence.new(matchacc.BulletTracers.Transparency)
    beam.Width0 = matchacc.BulletTracers.Size
    beam.Width1 = matchacc.BulletTracers.Size

    task.delay(matchacc.BulletTracers.TimeAlive, function()
        if beam and beam.Parent then
            local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            local tween = TweenService:Create(beam, tweenInfo, { Width0 = 0, Width1 = 0 })
            tween:Play()
           
            tween.Completed:Wait()
        end

        if startPart and startPart.Parent then startPart:Destroy() end
        if endPart and endPart.Parent then endPart:Destroy() end
        if beam and beam.Parent then beam:Destroy() end
    end)

    return startPart, endPart, beam
end

if getnamecallmethod and MainEvent ~= nil then
    local mt = getrawmetatable(MainEvent)
    setreadonly(mt, false)
           
    local cloned_mt = table.clone(mt)
   
    local oldnamecall = cloned_mt.__namecall
   
    setrawmetatable(MainEvent, {
        __namecall = (function(self, ...)
            local args = { ... }
            if getnamecallmethod() == "FireServer" then
                if args[1] == "ShootGun" then
   
                    -- Bullet Tracers
                    if matchacc.BulletTracers.Enabled then
                        bullettracerlol(args[3], args[4])
                    end
   
                end
            end
   
            return oldnamecall(self, unpack(args))
        end),
   
        __index = cloned_mt.__index,
        __newindex = cloned_mt.__newindex,
        __call = cloned_mt.__call,
        __tostring = cloned_mt.__tostring,
    })

end

BulletTracerGroup:AddToggle('BulletTracersEnabled', {
    Text = 'Enabled',
    Default = false,
    Callback = function(Value)
        matchacc.BulletTracers.Enabled = Value
        if not getnamecallmethod then
            Library:Notify("Your executor does not support this feature")
        end
    end
}):AddColorPicker('BulletTracersColor', {
    Default = matchacc.BulletTracers.Color,
    Title = 'Color',
    Callback = function(Value)
        matchacc.BulletTracers.Color = Value
    end
})

BulletTracerGroup:AddDropdown('BulletTracersTexture', {
    Values = {"Beam", "Lightning", "Heartrate", "Chain", "Glitch", "Swirl"},
    Default = "Beam",
    Multi = false,
    Text = 'Texture',
    Callback = function(Value)
        if Value == "Beam" then
            matchacc.BulletTracers.TextureID = "rbxassetid://12781852245"
        elseif Value == "Lightning" then
            matchacc.BulletTracers.TextureID = "rbxassetid://446111271"
        elseif Value == "Heartrate" then
            matchacc.BulletTracers.TextureID = "rbxassetid://5830549480"
        elseif Value == "Chain" then
            matchacc.BulletTracers.TextureID = "rbxassetid://9632168658"
        elseif Value == "Glitch" then
            matchacc.BulletTracers.TextureID = "rbxassetid://8089467613"
        elseif Value == "Swirl" then
            matchacc.BulletTracers.TextureID = "rbxassetid://5638168605"
        end
    end
})

BulletTracerGroup:AddSlider('BulletTracersSize', {
    Text = 'Size',
    Default = 0.4,
    Min = 0.1,
    Max = 3,
    Rounding = 2,
    Callback = function(Value)
        matchacc.BulletTracers.Size = Value
    end
})

BulletTracerGroup:AddSlider('BulletTracersTransparency', {
    Text = 'Transparency',
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        matchacc.BulletTracers.Transparency = Value
    end
})

BulletTracerGroup:AddSlider('BulletTracersTimeAlive', {
    Text = 'Time Alive',
    Default = 3,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Callback = function(Value)
        matchacc.BulletTracers.TimeAlive = Value
    end
})
end)()
local CrosshairGroup = Tabs.Visual:AddRightGroupbox('Crosshair')
local Client = players.LocalPlayer
local mouse = Client:GetMouse()

-- Visual state storage (parameters only)
local visualState = {
    time = 0,
    rotationProgress = 0,
    currentRotationSpeed = 0.8,
    smoothedRotation = 5,

    lines = {
        top = {Size = UDim2.new(0, 3, 0, 25), Position = UDim2.new(0.5, -1.5, 0, 0), Color = Color3.new(1,1,1)},
        bottom = {Size = UDim2.new(0, 3, 0, 25), Position = UDim2.new(0.5, -1.5, 1, -25), Color = Color3.new(1,1,1)},
        left = {Size = UDim2.new(0, 25, 0, 3), Position = UDim2.new(0, 0, 0.5, -1.5), Color = Color3.new(1,1,1)},
        right = {Size = UDim2.new(0, 25, 0, 3), Position = UDim2.new(1, -25, 0.5, -1.5), Color = Color3.new(1,1,1)},
    },
    -- Text params
    text = {
        Text = "NotHub",
        Position = UDim2.new(0, 0, 0, 0),
        Color = Color3.new(1,1,1),
        Font = Enum.Font.Arcade,
        TextScaled = true,
    }
}

local screenGui
local aimContainer
local topLine, bottomLine, leftLine, rightLine
local textLabel

local lineLength = 25
local lineThickness = 3
local baseRotationSpeed = 0.8
local pulseSpeed = 2.5
local minLength = -10
local maxLength = -30

local time = 0
local rotationProgress = 0
local currentRotationSpeed = baseRotationSpeed
local smoothedRotation = 5

local isCrosshairEnabled = false
local isTextEnabled = true
local isRainbowEnabled = false
local fixedColor = Color3.new(1,1,1)

local function createLine(parent, size, position, color)
    local frame = Instance.new("Frame")
    frame.Size = size
    frame.Position = position
    frame.BackgroundColor3 = color
    frame.BorderSizePixel = 0
    frame.ZIndex = 5
    frame.Parent = parent

    local stroke = Instance.new("UIStroke")
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    stroke.Color = Color3.new(0,0,0)
    stroke.Thickness = 1
    stroke.Parent = frame

    return frame
end

-- Helper to create text with outline
local function createTextLabel(parent, text, position, color, font, scaled)
    local label = Instance.new("TextLabel")
    label.Text = text
    label.Position = position
    label.TextColor3 = color
    label.Font = font
    label.TextScaled = scaled
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(0, 150, 0, 23)
    label.ZIndex = 10
    label.Parent = parent

    local stroke = Instance.new("UIStroke")
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual
    stroke.Color = Color3.new(0,0,0)
    stroke.Thickness = 1
    stroke.LineJoinMode = Enum.LineJoinMode.Round
    stroke.Parent = label

    return label
end

-- Clear previous GUI if exists
local function clearGui()
    if screenGui then
        screenGui:Destroy()
        screenGui = nil
    end
end

-- Create GUI elements fresh and restore from visualState parameters
local function createGui()
    clearGui()

    screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AimSightGUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = Client:WaitForChild("PlayerGui")

    aimContainer = Instance.new("Frame")
    aimContainer.BackgroundTransparency = 1
    aimContainer.Size = UDim2.new(0, 25, 0, 25)
    aimContainer.AnchorPoint = Vector2.new(0.5, 0.5)
    aimContainer.Parent = screenGui

    -- Create lines with saved params
    topLine = createLine(aimContainer, visualState.lines.top.Size, visualState.lines.top.Position, visualState.lines.top.Color)
    bottomLine = createLine(aimContainer, visualState.lines.bottom.Size, visualState.lines.bottom.Position, visualState.lines.bottom.Color)
    leftLine = createLine(aimContainer, visualState.lines.left.Size, visualState.lines.left.Position, visualState.lines.left.Color)
    rightLine = createLine(aimContainer, visualState.lines.right.Size, visualState.lines.right.Position, visualState.lines.right.Color)

    -- Create text label with saved params
    textLabel = createTextLabel(screenGui, visualState.text.Text, visualState.text.Position, visualState.text.Color, visualState.text.Font, visualState.text.TextScaled)
    textLabel.Visible = isTextEnabled
end

local function saveVisualState()
    visualState.time = time
    visualState.rotationProgress = rotationProgress
    visualState.currentRotationSpeed = currentRotationSpeed
    visualState.smoothedRotation = smoothedRotation

    visualState.lines.top.Size = topLine.Size
    visualState.lines.top.Position = topLine.Position
    visualState.lines.top.Color = topLine.BackgroundColor3

    visualState.lines.bottom.Size = bottomLine.Size
    visualState.lines.bottom.Position = bottomLine.Position
    visualState.lines.bottom.Color = bottomLine.BackgroundColor3

    visualState.lines.left.Size = leftLine.Size
    visualState.lines.left.Position = leftLine.Position
    visualState.lines.left.Color = leftLine.BackgroundColor3

    visualState.lines.right.Size = rightLine.Size
    visualState.lines.right.Position = rightLine.Position
    visualState.lines.right.Color = rightLine.BackgroundColor3

    visualState.text.Text = textLabel.Text
    visualState.text.Position = textLabel.Position
    visualState.text.Color = textLabel.TextColor3
    visualState.text.Font = textLabel.Font
    visualState.text.TextScaled = textLabel.TextScaled
end


local function restoreVisualState()
    if not (topLine and bottomLine and leftLine and rightLine and textLabel) then
        return
    end

    time = visualState.time or 0
    rotationProgress = visualState.rotationProgress or 0
    currentRotationSpeed = visualState.currentRotationSpeed or baseRotationSpeed
    smoothedRotation = visualState.smoothedRotation or 5

    topLine.Size = visualState.lines.top.Size or topLine.Size
    topLine.Position = visualState.lines.top.Position or topLine.Position
    topLine.BackgroundColor3 = visualState.lines.top.Color or topLine.BackgroundColor3

    bottomLine.Size = visualState.lines.bottom.Size or bottomLine.Size
    bottomLine.Position = visualState.lines.bottom.Position or bottomLine.Position
    bottomLine.BackgroundColor3 = visualState.lines.bottom.Color or bottomLine.BackgroundColor3

    leftLine.Size = visualState.lines.left.Size or leftLine.Size
    leftLine.Position = visualState.lines.left.Position or leftLine.Position
    leftLine.BackgroundColor3 = visualState.lines.left.Color or leftLine.BackgroundColor3

    rightLine.Size = visualState.lines.right.Size or rightLine.Size
    rightLine.Position = visualState.lines.right.Position or rightLine.Position
    rightLine.BackgroundColor3 = visualState.lines.right.Color or rightLine.BackgroundColor3

    textLabel.Text = visualState.text.Text or textLabel.Text
    textLabel.Position = visualState.text.Position or textLabel.Position
    textLabel.TextColor3 = visualState.text.Color or textLabel.TextColor3
    textLabel.Font = visualState.text.Font or textLabel.Font
    textLabel.TextScaled = visualState.text.TextScaled or textLabel.TextScaled
end

-- Function to get rainbow color by time
local function getRainbowColor(t)
    local r = math.sin(t * 0.6) * 0.5 + 0.5
    local g = math.sin(t * 0.6 + 2) * 0.5 + 0.5
    local b = math.sin(t * 0.6 + 4) * 0.5 + 0.5
    return Color3.new(r, g, b)
end

local function calculateRotationSpeed(progress)
    local slowdownStart = 0.6
    local slowdownDuration = 0.35
    local minSlowdownSpeed = 0.3
    local baseRotationSpeedLocal = baseRotationSpeed

    if progress >= slowdownStart then
        local slowdownProgress = (progress - slowdownStart) / slowdownDuration
        local easedProgress = slowdownProgress * slowdownProgress
        local slowdownFactor = 1 - (easedProgress * (1 - minSlowdownSpeed))
        return baseRotationSpeedLocal * math.max(slowdownFactor, minSlowdownSpeed)
    else
        return baseRotationSpeedLocal
    end
end

local function smoothRotation(currentRot, targetRot, smoothing)
    return currentRot + (targetRot - currentRot) * smoothing
end

local function smoothPulse(t, speed)
    local rawPulse = math.sin(t * speed) * 0.5 + 0.5
    return rawPulse * rawPulse
end

-- On character added, recreate GUI and restore state
local function onCharacterAdded(character)
    if isCrosshairEnabled then
        createGui()
        restoreVisualState()
    end

    local humanoid = character:WaitForChild("Humanoid")
    humanoid.Died:Connect(function()
        saveVisualState()
    end)
end

Client.CharacterAdded:Connect(onCharacterAdded)

if Client.Character then
    onCharacterAdded(Client.Character)
end

local UserInputService = game:GetService("UserInputService")
local isMobile = UserInputService.TouchEnabled

RunService.RenderStepped:Connect(function(deltaTime)
    if not (aimContainer and topLine and bottomLine and leftLine and rightLine and textLabel) then
        return
    end

    time = time + deltaTime

    aimContainer.Position = UDim2.new(0, mouse.X, 0, mouse.Y)
    textLabel.Position = UDim2.new(0, mouse.X - 70, 0, mouse.Y + 50)

    rotationProgress = (rotationProgress + currentRotationSpeed * deltaTime) % 1
    currentRotationSpeed = calculateRotationSpeed(rotationProgress)

    local targetRotation = rotationProgress * 360
    smoothedRotation = smoothRotation(smoothedRotation, targetRotation, 1)
    aimContainer.Rotation = smoothedRotation

    local pulse = smoothPulse(time, pulseSpeed)
    local currentLength = minLength + (maxLength - minLength) * pulse

    topLine.Size = UDim2.new(0, lineThickness, 0, currentLength)
    bottomLine.Size = UDim2.new(0, lineThickness, 0, currentLength)
    leftLine.Size = UDim2.new(0, currentLength, 0, lineThickness)
    rightLine.Size = UDim2.new(0, currentLength, 0, lineThickness)

    topLine.Position = UDim2.new(0.5, -lineThickness / 2, 0, 0)
    bottomLine.Position = UDim2.new(0.5, -lineThickness / 2, 1, -currentLength)
    leftLine.Position = UDim2.new(0, 0, 0.5, -lineThickness / 2)
    rightLine.Position = UDim2.new(1, -currentLength, 0.5, -lineThickness / 2)
    local color = isRainbowEnabled and getRainbowColor(time) or fixedColor

    topLine.BackgroundColor3 = color
    bottomLine.BackgroundColor3 = color
    leftLine.BackgroundColor3 = color
    rightLine.BackgroundColor3 = color

    textLabel.TextColor3 = color
end)
CrosshairGroup:AddToggle('CrosshairEnabled', {
    Text = 'Enabled',
    Default = false,
    Callback = function(Value)
        isCrosshairEnabled = Value
        if Value then
            createGui()
            restoreVisualState()
        else
            clearGui()
        end
    end
}):AddColorPicker('CrosshairColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Color',
    Callback = function(Value)
        fixedColor = Value
        if not isRainbowEnabled and topLine and bottomLine and leftLine and rightLine and textLabel then
            topLine.BackgroundColor3 = Value
            bottomLine.BackgroundColor3 = Value
            leftLine.BackgroundColor3 = Value
            rightLine.BackgroundColor3 = Value
            textLabel.TextColor3 = Value
        end
    end
})

CrosshairGroup:AddToggle('CrosshairText', {
    Text = 'Text',
    Default = true,
    Callback = function(Value)
        isTextEnabled = Value
        if textLabel then
            textLabel.Visible = Value
        end
    end
})

CrosshairGroup:AddSlider('CrosshairSpinSpeed', {
    Text = 'Spin Speed',
    Default = 0.8,
    Min = 0.1,
    Max = 2,
    Rounding = 2,
    Callback = function(Value)
        baseRotationSpeed = Value
    end
})

CrosshairGroup:AddToggle('CrosshairRainbow', {
    Text = 'Rainbow',
    Default = false,
    Callback = function(Value)
        isRainbowEnabled = Value
    end
})
local RainGroup = Tabs.Visual:AddRightGroupbox('Rain')

getgenv().RainSettings = {
    Enabled = false,
    Color = Color3.fromRGB(255, 255, 255),
    Lifetime = 5,
    Rate = 1000,
    Speed = 100,
}
getgenv().SnowSettings = {
    Enabled = false,
    Color = Color3.fromRGB(255, 255, 255),
    Lifetime = 100,  -- Default max lifetime, min fixed at 5 as per XML
    Rate = 100,
    Speed = 10,
}
local rainPart = nil
local rainEmitter = nil
local rainConnection = nil
local snowPart = nil
local snowEmitter = nil
local snowConnection = nil
local function rainParticleEmitter()
    if rainPart then
        rainPart:Destroy()
        rainPart = nil
        rainEmitter = nil
    end

    rainPart = Instance.new("Part")
    rainPart.Size = Vector3.new(51.8, 0.001, 52.084)
    rainPart.CanCollide = false
    rainPart.Anchored = true
    rainPart.Transparency = 1
    rainPart.Parent = workspace

    rainEmitter = Instance.new("ParticleEmitter")
    rainEmitter.Color = ColorSequence.new(RainSettings.Color)
    rainEmitter.LightEmission = 1
    rainEmitter.Orientation = Enum.ParticleOrientation.FacingCameraWorldUp
    rainEmitter.Size = NumberSequence.new(0.4)
    rainEmitter.Squash = NumberSequence.new(4)
    rainEmitter.Texture = "rbxasset://textures/particles/sparkles_main.dds"
    rainEmitter.EmissionDirection = Enum.NormalId.Bottom
    rainEmitter.Lifetime = NumberRange.new(RainSettings.Lifetime)
    rainEmitter.Rate = RainSettings.Rate
    rainEmitter.Speed = NumberRange.new(RainSettings.Speed)
    rainEmitter.LockedToPart = true
    rainEmitter.Enabled = true
    rainEmitter.Parent = rainPart
end
local function snowParticleEmitter()
    if snowPart then
        snowPart:Destroy()
        snowPart = nil
        snowEmitter = nil
    end

    snowPart = Instance.new("Part")
    snowPart.Name = "SnowEmitterPart"
    snowPart.Size = Vector3.new(51.8, 0.001, 52.084)
    snowPart.Anchored = true
    snowPart.CanCollide = false
    snowPart.CanQuery = true
    snowPart.CanTouch = true
    snowPart.CastShadow = true
    snowPart.CollisionGroup = "Default"
    snowPart.CollisionGroupId = 0
    snowPart.Material = Enum.Material.Plastic
    snowPart.PivotOffset = CFrame.new(0,0,0)
    snowPart.Reflectance = 0
    snowPart.RootPriority = 0
    snowPart.RotVelocity = Vector3.new(0,0,0)
    snowPart.Transparency = 1
    snowPart.Velocity = Vector3.new(0,0,0)
    snowPart.Parent = workspace

    snowEmitter = Instance.new("ParticleEmitter")
    snowEmitter.Acceleration = Vector3.new(0,0,0)
    snowEmitter.Brightness = 1
    snowEmitter.Color = ColorSequence.new(SnowSettings.Color)
    snowEmitter.Drag = 0
    snowEmitter.EmissionDirection = Enum.NormalId.Bottom
    snowEmitter.Enabled = true
    snowEmitter.FlipbookFramerate = NumberRange.new(1,1)
    snowEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.None
    snowEmitter.FlipbookMode = Enum.ParticleFlipbookMode.Loop
    snowEmitter.Lifetime = NumberRange.new(5, 100)  -- Min 5, Max from settings
    snowEmitter.LightEmission = 0
    snowEmitter.LightInfluence = 0
    snowEmitter.LockedToPart = false
    snowEmitter.Orientation = Enum.ParticleOrientation.FacingCamera
    snowEmitter.Rate = SnowSettings.Rate
    snowEmitter.RotSpeed = NumberRange.new(360,360)
    snowEmitter.Rotation = NumberRange.new(20,20)
    snowEmitter.Shape = Enum.ParticleEmitterShape.Box
    snowEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
    snowEmitter.ShapePartial = 1
    snowEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
    snowEmitter.Size = NumberSequence.new(0.2)
    snowEmitter.Speed = NumberRange.new(SnowSettings.Speed)
    snowEmitter.SpreadAngle = Vector2.new(500,500)
    snowEmitter.Squash = NumberSequence.new(0)
    snowEmitter.Texture = "rbxassetid://118641183"
    snowEmitter.TimeScale = 1
    snowEmitter.Transparency = NumberSequence.new(0.2)
    snowEmitter.VelocityInheritance = 0
    snowEmitter.WindAffectsDrag = false
    snowEmitter.ZOffset = 0
    snowEmitter.Parent = snowPart
end
RainGroup:AddToggle('RainEnabled', {
    Text = 'Enabled',
    Default = false,
    Callback = function(Value)
        RainSettings.Enabled = Value
        if Value then
            rainParticleEmitter()
            rainConnection = RunService.Heartbeat:Connect(function()
			    local camPos = Camera.CFrame.Position
			    rainPart.CFrame = CFrame.new(camPos + Vector3.new(0, 30, 0))
            end)
        else
            if rainConnection then
                rainConnection:Disconnect()
                rainConnection = nil
            end
            if rainPart then
                rainPart:Destroy()
                rainPart = nil
                rainEmitter = nil
            end
        end
    end
}):AddColorPicker('RainColor', {
    Default = RainSettings.Color,
    Title = 'Rain Color',
    Callback = function(Value)
        RainSettings.Color = Value
        if RainSettings.Enabled then
            rainParticleEmitter()
        end
    end
})

RainGroup:AddInput('RainLifetime', {
    Default = tostring(RainSettings.Lifetime),
    Numeric = true,
    Finished = true,
    Text = 'Lifetime',
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            RainSettings.Lifetime = num
            if RainSettings.Enabled then
                rainParticleEmitter()
            end
        end
    end
})

RainGroup:AddSlider('RainRate', {
    Text = 'Amount',
    Default = RainSettings.Rate,
    Min = 1,
    Max = 10000,
    Rounding = 0,
    Callback = function(Value)
        RainSettings.Rate = Value
        if RainSettings.Enabled then
            rainParticleEmitter()
        end
    end
})

RainGroup:AddSlider('RainSpeed', {
    Text = 'Speed',
    Default = RainSettings.Speed,
    Min = 10,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        RainSettings.Speed = Value
        if RainSettings.Enabled then
            rainParticleEmitter()
        end
    end
})
RainGroup:AddToggle('SnowEnabled', {
    Text = 'Snow Enabled',
    Default = false,
    Callback = function(Value)
        SnowSettings.Enabled = Value
        if Value then
            snowParticleEmitter()
            snowConnection = RunService.Heartbeat:Connect(function()
                local camPos = Camera.CFrame.Position
                snowPart.CFrame = CFrame.new(camPos + Vector3.new(0, 5, 0))
            end)
        else
            if snowConnection then
                snowConnection:Disconnect()
                snowConnection = nil
            end
            if snowPart then
                snowPart:Destroy()
                snowPart = nil
                snowEmitter = nil
            end
        end
    end
}):AddColorPicker('SnowColor', {
    Default = SnowSettings.Color,
    Title = 'Snow Color',
    Callback = function(Value)
        SnowSettings.Color = Value
        if SnowSettings.Enabled then
            snowParticleEmitter()
        end
    end
})

RainGroup:AddSlider('SnowRate', {
    Text = 'Snow Amount',
    Default = SnowSettings.Rate,
    Min = 1,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        SnowSettings.Rate = Value
        if SnowSettings.Enabled then
            snowParticleEmitter()
        end
    end
})

RainGroup:AddSlider('SnowSpeed', {
    Text = 'Snow Speed',
    Default = SnowSettings.Speed,
    Min = 1,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        SnowSettings.Speed = Value
        if SnowSettings.Enabled then
            snowParticleEmitter()
        end
    end
})
local MovementGroup = Tabs.Character:AddLeftGroupbox('Movement')

matchacc.Movement = {
    Speed = {
        Enabled = false,
        Keybind = false,
        Speed = 20,
    },
    Fly = {
        Enabled = false,
        Keybind = false,
        Speed = 20,
    },
}

MovementGroup:AddToggle('SpeedEnabled', {
    Text = 'Speed Enabled',
    Default = false,
    Callback = function(Value)
        matchacc.Movement.Speed.Enabled = Value
    end
}):AddKeyPicker('SpeedKey', {
    Default = 'none',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Speed Key',
    Callback = function(Value)
        matchacc.Movement.Speed.Keybind = Value
    end
})

MovementGroup:AddSlider('SpeedValue', {
    Text = 'Speed',
    Default = 20,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        matchacc.Movement.Speed.Speed = Value
    end
})

MovementGroup:AddToggle('FlyEnabled', {
    Text = 'Fly Cframe',
    Default = false,
    Callback = function(Value)
        matchacc.Movement.Fly.Enabled = Value
    end
}):AddKeyPicker('FlyKey', {
    Default = 'none',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Fly Key',
    Callback = function(Value)
        matchacc.Movement.Fly.Keybind = Value
    end
})

MovementGroup:AddSlider('FlySpeed', {
    Text = 'Fly Speed',
    Default = 20,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        matchacc.Movement.Fly.Speed = Value
    end
})
getgenv().FlySpeed = 150
getgenv().FlightEnabled = false
getgenv().Flying = false
local IdleAnim = Instance.new("Animation")
IdleAnim.AnimationId = "rbxassetid://3541114300"

local IdleTrack, FlyTrack
local FlyAnim = Instance.new("Animation")
FlyAnim.AnimationId = "rbxassetid://3541044388"
local function CreateCore()
    if workspace:FindFirstChild("Core") then workspace.Core:Destroy() end
    local Core = Instance.new("Part")
    Core.Name = "Core"
    Core.Size = Vector3.new(0.05, 0.05, 0.05)
    Core.CanCollide = false
    Core.Transparency = 1
    Core.Parent = workspace

    local Weld = Instance.new("Weld", Core)
    Weld.Part0 = Core
    Weld.Part1 = localPlayer.Character.HumanoidRootPart
    Weld.C0 = CFrame.new(0, 0, 0)
    return Core
end

local currentMove = Vector3.zero

-- Kiểm tra có đang di chuyển không
local function IsMoving()
    return currentMove.Magnitude > 0.1
end

local function StartFly()
    if getgenv().Flying or not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    getgenv().Flying = true

    local hum = localPlayer.Character:FindFirstChildOfClass("Humanoid")
    hum.PlatformStand = true

    -- Load animations
    IdleTrack = hum:LoadAnimation(IdleAnim)
    FlyTrack = hum:LoadAnimation(FlyAnim)

    IdleTrack:Play()

    local Core = CreateCore()

    local BV = Instance.new("BodyVelocity", Core)
    BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    BV.Velocity = Vector3.zero

    local BG = Instance.new("BodyGyro", Core)
    BG.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    BG.P = 9e4
    BG.CFrame = Core.CFrame

    local connection
    connection = RunService.RenderStepped:Connect(function()
        if not getgenv().Flying then connection:Disconnect() return end
        
        local camera = Camera
        currentMove = Vector3.zero

        if UserInputService:IsKeyDown(Enum.KeyCode.W) then currentMove += camera.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then currentMove -= camera.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then currentMove -= camera.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then currentMove += camera.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then currentMove += Vector3.new(0, 1, 0) end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then currentMove -= Vector3.new(0, 1, 0) end

        BV.Velocity = currentMove * getgenv().FlySpeed
        BG.CFrame = camera.CFrame

        -- Animation switching
        if IsMoving() then
            if IdleTrack.IsPlaying then IdleTrack:Stop() end
            if not FlyTrack.IsPlaying then FlyTrack:Play() end
        else
            if FlyTrack.IsPlaying then FlyTrack:Stop() end
            if not IdleTrack.IsPlaying then IdleTrack:Play() end
        end
    end)
end

local function StopFly()
    if not getgenv().Flying then return end
    getgenv().Flying = false

    local hum = localPlayer.Character:FindFirstChildOfClass("Humanoid")
    hum.PlatformStand = false

    if IdleTrack then IdleTrack:Stop() end
    if FlyTrack then FlyTrack:Stop() end

    if workspace:FindFirstChild("Core") then
        workspace.Core:Destroy()
    end
end
-- Nút bật/tắt Fly V2
MovementGroup:AddToggle('FlightV2_Enabled', {
    Text = 'Fly Velocity + superhero',
    Default = false,
    Callback = function(value)
        getgenv().FlightEnabled = value
        if not value then
            StopFly()
        end
    end
}):AddKeyPicker('FlightV2_Keybind', {
    Default = 'none',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Fly V2 Keybind',
    Callback = function(state)
        if UserInputService:GetFocusedTextBox() then return end
        if state and getgenv().FlightEnabled then
            StartFly()
        else
            StopFly()
        end
    end
})

-- Slider tốc độ bay
MovementGroup:AddSlider('FlightV2_Speed', {
    Text = 'Fly Speed',
    Default = 150,
    Min = 10,
    Max = 1000,
    Rounding = 0,
    Callback = function(value)
        getgenv().FlySpeed = value
    end
})

-- Reset khi respawn (đã có sẵn trong script gốc, chỉ cần thêm StopFly)
localPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    StopFly() -- Dừng bay khi respawn
    if getgenv().FlightEnabled then
        -- Tự động bật lại nếu toggle vẫn đang bật
        task.wait(2)
        if getgenv().FlightEnabled then
            StartFly()
        end
    end
end)
-- WalkSpeed
MovementGroup:AddToggle('WalkSpeedToggle', {
    Text = 'Walk Speed',
    Default = false,
    Callback = function(Value)
        matchacc.Movement.WalkSpeedEnabled = Value
    end
}):AddKeyPicker('WalkSpeedKey', {
    Default = 'None',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Walk Speed'
})

MovementGroup:AddSlider('WalkSpeedSlider', {
    Text = 'Speed',
    Default = 16,
    Min = 1,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        matchacc.Movement.WalkSpeed = Value
    end
})

-- JumpPower
MovementGroup:AddToggle('JumpPowerToggle', {
    Text = 'Jump Power',
    Default = false,
    Callback = function(Value)
        matchacc.Movement.JumpPowerEnabled = Value
    end
}):AddKeyPicker('JumpPowerKey', {
    Default = 'None',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Jump Power'
})

MovementGroup:AddSlider('JumpPowerSlider', {
    Text = 'Power',
    Default = 50,
    Min = 1,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        matchacc.Movement.JumpPower = Value
    end
})

getgenv().Matcha.BunnyHop = {
    Enabled = false,
    Keybind = false,
    Speed = 100
}
MovementGroup:AddToggle('BunnyHop_Enabled', {
    Text = 'Bunny Hop',
    Default = false,
    Callback = function(value)
        getgenv().Matcha.BunnyHop.Enabled = value
    end
}):AddKeyPicker('BunnyHop_Keybind', {
    Default = 'None',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Bunny Hop Keybind',
    Callback = function(state)
        getgenv().Matcha.BunnyHop.Keybind = state
    end
})

MovementGroup:AddSlider('BunnyHop_Speed', {
    Text = 'Bunny Hop Speed',
    Default = 100,
    Min = 1,
    Max = 200,
    Rounding = 0,
    Callback = function(value)
        getgenv().Matcha.BunnyHop.Speed = value
    end
})

-- Logic Bunny Hop (chạy liên tục)
RunService.RenderStepped:Connect(function()
    if not getgenv().Matcha.BunnyHop.Enabled or not getgenv().Matcha.BunnyHop.Keybind then return end
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("Humanoid") or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then return end

    local hum = localPlayer.Character:FindFirstChildOfClass("Humanoid")
    local hrp = localPlayer.Character.HumanoidRootPart
    local camera = Camera

    if UserInputService:IsKeyDown(Enum.KeyCode.Space) and hum.FloorMaterial ~= Enum.Material.Air then
        hum.Jump = true

        local look = camera.CFrame.LookVector * Vector3.new(1, 0, 1)
        local move = Vector3.zero

        if UserInputService:IsKeyDown(Enum.KeyCode.W) then move += look end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then move -= look end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then move += Vector3.new(-look.Z, 0, look.X) end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then move += Vector3.new(look.Z, 0, -look.X) end

        if move.Magnitude > 0 then
            local speed = getgenv().Matcha.BunnyHop.Speed
            hrp.Velocity = Vector3.new(move.Unit.X * speed, hrp.Velocity.Y, move.Unit.Z * speed)
        end
    end
end)

getgenv().Matcha.SpinBot = {
    Enabled = false,
    Speed = 500
}

MovementGroup:AddToggle('SpinBot_Enabled', {
    Text = 'SpinBot',
    Default = false,
    Callback = function(value)
        getgenv().Matcha.SpinBot.Enabled = value
    end
}):AddKeyPicker('SpinBot_Keybind', {
    Default = 'none',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'SpinBot Keybind',

})

MovementGroup:AddSlider('SpinBot_Speed', {
    Text = 'Spin Speed',
    Default = 500,
    Min = 1,
    Max = 10000,
    Rounding = 0,
    Callback = function(value)
        getgenv().Matcha.SpinBot.Speed = value
    end
})
local MacroGroup = Tabs.Character:AddLeftGroupbox('Fake Macro')
player = game.Players.LocalPlayer
character = player.Character or player.CharacterAdded:Wait()
humanoid = character:WaitForChild("Humanoid")
emoteId = "rbxassetid://3189777795"

-- Speed variables
maxSpeed = 300
baseSpeed = 16
speedIncrement = 1.75
emoteDuration = 1.6 

-- Variables to track speed and state
currentSpeed = baseSpeed
isSpeedEnabled = false
emoteTrack = nil
isSpeedReady = false

-- Cache the hotkey (Q) for reuse
Keybind = Enum.KeyCode.Q

-- Efficient use of services and enum values
UserInputService = game:GetService("UserInputService")
RunService = game:GetService("RunService")

-- Function to initialize the character and humanoid
function initializeCharacter(newCharacter)
	character = newCharacter or player.Character
	humanoid = character:WaitForChild("Humanoid")
	currentSpeed = baseSpeed
	humanoid.WalkSpeed = baseSpeed
	isSpeedEnabled = false
	isSpeedReady = false
end

-- Function to play the emote
function playEmote()
	animation = Instance.new("Animation")
	animation.AnimationId = emoteId
	emoteTrack = humanoid:LoadAnimation(animation)
	emoteTrack:Play()

	-- Stop the emote after the duration from the slider
	task.wait(emoteDuration)
	if emoteTrack and emoteTrack.IsPlaying then
		emoteTrack:Stop()
	end

	-- After the emote ends, set isSpeedReady to true to start gradual speed increase
	isSpeedReady = true
end

-- Function to manage speed (gradual increase)
function updateSpeed()
	if _G.ScriptEnabled and isSpeedEnabled then
		if isSpeedReady then
			currentSpeed = math.min(currentSpeed + speedIncrement, maxSpeed)
			humanoid.WalkSpeed = currentSpeed
		else
			humanoid.WalkSpeed = baseSpeed
		end
	elseif not isSpeedEnabled or not _G.ScriptEnabled then
		humanoid.WalkSpeed = baseSpeed
		currentSpeed = baseSpeed
	end
end

-- Toggle the speed feature
function toggleSpeedFeature()
	if not _G.ScriptEnabled then return end
	isSpeedEnabled = not isSpeedEnabled
	if isSpeedEnabled then
		currentSpeed = baseSpeed
		humanoid.WalkSpeed = baseSpeed
		isSpeedReady = false
		playEmote()
	else
		currentSpeed = baseSpeed
		humanoid.WalkSpeed = baseSpeed
		isSpeedReady = false
	end
end

-- Reinitialize the script on character respawn
player.CharacterAdded:Connect(initializeCharacter)

-- Bind the hotkey (Q) to toggle the feature
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if _G.ScriptEnabled and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Keybind then
		toggleSpeedFeature()
	end
end)

-- Bind RunService Heartbeat to continuously update speed
RunService.Heartbeat:Connect(updateSpeed)

-- Initialize the script for the current character
initializeCharacter(character)

MacroGroup:AddToggle('MyToggle', {
	Text = 'Fake Macro',
	Default = false,
	Tooltip = 'This is a tooltip',

	Callback = function(Value)
	   
		-- Toggle the speed feature based on the toggle value
		if Value then
			_G.ScriptEnabled = true
			resetCharacter()
		else
			_G.ScriptEnabled = false
		end
	end
}):AddKeyPicker('KeyPicker', {
	Default = 'Q', -- Initial keybind (can be changed)
	SyncToggleState = false,
	Mode = 'Toggle', -- Modes: Always, Toggle, Hold
	Text = 'Speed Toggle Keybind',

	Callback = function(Value)
	end,

	ChangedCallback = function(New)
		Keybind = New
	end
})

-- Add Slider for emote duration
MacroGroup:AddSlider('EmoteDuration', {
	Text = 'Emote Duration (Seconds)',
	Default = 1.6,
	Min = 0,
	Max = 2.5,
	Rounding = 2,
	Compact = false,
	Callback = function(Value)
		emoteDuration = Value
	end
})

-- Add Slider for max speed
MacroGroup:AddSlider('MaxSpeed', {
	Text = 'Max Speed',
	Default = 300,
	Min = 16,
	Max = 1000, -- Adjust max limit as needed
	Rounding = 0,
	Compact = false,

	Callback = function(Value)
		print('[cb] Max Speed changed! New value:', Value)
		maxSpeed = Value
	end
})

-- Add Slider for speed increment
MacroGroup:AddSlider('SpeedIncrement', {
	Text = 'Speed Increment',
	Default = 1.75,
	Min = 0.1,
	Max = 10,
	Rounding = 2,
	Compact = false,

	Callback = function(Value)
		print('[cb] Speed Increment changed! New value:', Value)
		speedIncrement = Value
	end
})

-- Logic SpinBot
RunService.Heartbeat:Connect(function(dt)
    if not getgenv().Matcha.SpinBot.Enabled then return end
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then return end

    local hrp = localPlayer.Character.HumanoidRootPart
    local spinSpeed = getgenv().Matcha.SpinBot.Speed

    hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(spinSpeed * dt), 0)
end)
-- Loop set WalkSpeed và JumpPower liên tục (thêm vào script, sau UI setup)
RunService.Heartbeat:Connect(function()
    local hum = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        if matchacc.Movement.WalkSpeedEnabled then
            hum.WalkSpeed = matchacc.Movement.WalkSpeed
        end
        if matchacc.Movement.JumpPowerEnabled then
            hum.JumpPower = matchacc.Movement.JumpPower
            hum.UseJumpPower = true  -- Đảm bảo dùng JumpPower
        end
    end
end)

-- Reset khi character respawn (thêm vào CharacterAdded)
localPlayer.CharacterAdded:Connect(function(char)
    StopFly()  -- Reset fly nếu đang bật
    task.wait(1)  -- Chờ character load
    if matchacc.Movement.FlyEnabled then StartFly() end
end)
-- Integrate Movement Logic into Heartbeat
RunService.Heartbeat:Connect(function(dt)
    -- Speed
    if matchacc.Movement.Speed.Enabled and matchacc.Movement.Speed.Keybind then
        if localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local move_direction = localPlayer.Character.Humanoid.MoveDirection
            local hrp = localPlayer.Character.HumanoidRootPart
            hrp.CFrame = hrp.CFrame + (move_direction * dt) * matchacc.Movement.Speed.Speed * 10
        end
    end
    
    -- Fly
    if matchacc.Movement.Fly.Enabled and matchacc.Movement.Fly.Keybind then
        if localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local move_direction = localPlayer.Character.Humanoid.MoveDirection
            local hrp = localPlayer.Character.HumanoidRootPart
            local add = Vector3.new(0, (UserInputService:IsKeyDown(Enum.KeyCode.Space) and matchacc.Movement.Fly.Speed / 8 or UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) and -matchacc.Movement.Fly.Speed / 8) or 0, 0)
            hrp.CFrame = hrp.CFrame + (move_direction * dt) * matchacc.Movement.Fly.Speed * 10
            hrp.CFrame = hrp.CFrame + add
            hrp.Velocity = (hrp.Velocity * Vector3.new(1, 0, 1)) + Vector3.new(0, 1.9, 0)
        end
    end
end) 
--logic
if getnamecallmethod then 
    local Meta = getrawmetatable(game)
    local backupindex = Meta.__index
    setreadonly(Meta, false)

    Meta.__index = function(t, k)
        if k:lower() == "hit" then
            if matchacc.TargetAim.Enabled and matchacc.TargetAim.Target ~= "None" and localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
                if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Head") and not TargetPlayer.Character:FindFirstChild("ForceField") then
                    if not KnockCheck(TargetPlayer) then
                        return TargetPlayer.Character.Head.CFrame
                    end
                end
            end
        end
        return backupindex(t, k)
    end
end
if getnamecallmethod and game.GameId == 9825515356 then
    local OldNamecall
    OldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
        local args = {...}
        local method = getnamecallmethod()

        if method == "FireServer" and self.Name == "MainEvent" and args[1] == "Shoot" then
            if matchacc.TargetAim.Enabled and matchacc.TargetAim.AutoFire and matchacc.TargetAim.Target ~= "None" and localPlayer and localPlayer.Character then
                local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
                if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Head") and not TargetPlayer.Character:FindFirstChild("ForceField") then
                    if not KnockCheck(TargetPlayer) then
                        local TargetPart = TargetPlayer.Character.Head
                        if TargetPart and args[2] then
                            for _, info in pairs(args[2][1]) do
                                info["Instance"] = TargetPart
                            end
                            for _, info in pairs(args[2][2]) do
                                info["thePart"] = TargetPart
                                info["theOffset"] = CFrame.new()
                            end
                            return OldNamecall(self, unpack(args))
                        end
                    end
                end
            end
        end

        return OldNamecall(self, ...)
    end)
end

-- Mouse1 Down Detect
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        M1Down = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        M1Down = false
    end
end)
local SelectedGun = '[Rifle]'
local BuyingSingle = false
local BuyingAmmo = false
local ShopTable = {
    ["[Rifle]"] = {ShopName = "[Rifle] - $1694"},
    ["[Rifle Ammo]"] = {ShopName = "5 [Rifle Ammo] - $273"},
    ["[LMG]"] = {ShopName = "[LMG] - $4098"},
    ["[LMG Ammo]"] = {ShopName = "200 [LMG Ammo] - $328"},
    ["[AK47]"] = {ShopName = "[AK47] - $2459"},
    ["[AK47 Ammo]"] = {ShopName = "90 [AK47 Ammo] - $87"},
    ["[AUG]"] = {ShopName = "[AUG] - $2131"},
    ["[AUG Ammo]"] = {ShopName = "90 [AUG Ammo] - $87"},
    ["[AR]"] = {ShopName = "[AR] - $1093"},
    ["[AR Ammo]"] = {ShopName = "60 [AR Ammo] - $82"},
    ["[Double-Barrel SG]"] = {ShopName = "[Double-Barrel SG] - $1475"},
    ["[Double-Barrel SG Ammo]"] = {ShopName = "18 [Double-Barrel SG Ammo] - $55"},
    ["[Drum-Shotgun]"] = {ShopName = "[Drum-Shotgun] - $1202"},
    ["[Drum-Shotgun Ammo]"] = {ShopName = "18 [Drum-Shotgun Ammo] - $71"},
    ["[DrumGun]"] = {ShopName = "[DrumGun] - $3278"},
    ["[DrumGun Ammo]"] = {ShopName = "100 [DrumGun Ammo] - $219"},
    ["[Fire Armor]"] = {ShopName = "[Fire Armor] - $2623"},
    ["[Glock]"] = {ShopName = "[Glock] - $546"},
    ["[Glock Ammo]"] = {ShopName = "25 [Glock Ammo] - $66"},
    ["[P90]"] = {ShopName = "[P90] - $1093"},
    ["[P90 Ammo]"] = {ShopName = "120 [P90 Ammo] - $66"},
    ["[RPG]"] = {ShopName = "[RPG] - $21855"},
    ["[RPG Ammo]"] = {ShopName = "5 [RPG Ammo] - $1093"},
    ["[Revolver]"] = {ShopName = "[Revolver] - $1421"},
    ["[Revolver Ammo]"] = {ShopName = "12 [Revolver Ammo] - $82"},
    ["[Silencer]"] = {ShopName = "[Silencer] - $601"},
    ["[Silencer Ammo]"] = {ShopName = "25 [Silencer Ammo] - $55"},
    ["[SilencerAR]"] = {ShopName = "[SilencerAR] - $1366"},
    ["[SilencerAR Ammo]"] = {ShopName = "120 [SilencerAR Ammo] - $82"},
    ["[Shotgun]"] = {ShopName = "[Shotgun] - $1366"},
    ["[Shotgun Ammo]"] = {ShopName = "20 [Shotgun Ammo] - $66"},
    ["[SMG]"] = {ShopName = "[SMG] - $820"},
    ["[SMG Ammo]"] = {ShopName = "80 [SMG Ammo] - $66"},
    ["[TacticalShotgun]"] = {ShopName = "[TacticalShotgun] - $1912"},
    ["[TacticalShotgun Ammo]"] = {ShopName = "20 [TacticalShotgun Ammo] - $66"},
    ["[Taser]"] = {ShopName = "[Taser] - $1093"},
    ["[Grenade]"] = {ShopName = "[Grenade] - $765"},
}

local headshots = {}
headshots.AutoArmor = {Enabled = false}
headshots.AutoLoadout = {Enabled = false, Gun = '[Rifle]'}
local pingvalue = nil
local split = nil
local ping = nil
local PredictionValue = nil

local GlobalPredictionMultiplier = 0.80

local basePredictionTable = {
    {ping = 130, value = 0.51},
    {ping = 125, value = 0.49},
    {ping = 110, value = 0.46},
    {ping = 105, value = 0.38},
    {ping = 90,  value = 0.36},
    {ping = 80,  value = 0.34},
    {ping = 70,  value = 0.31},
    {ping = 60,  value = 0.229},
    {ping = 50,  value = 0.225},
    {ping = 40,  value = 0.256}
}
local previousKnock = false
local previousDead = false
local lastTargetCharacter = nil

-- Thêm event PlayerRemoving (sau MainEvent = getMainRemote())
players.PlayerRemoving:Connect(function(plr)
    if plr.Name == matchacc.TargetAim.Target then
        Library:Notify(plr.Name .. " left the game", 3)
        matchacc.TargetAim.Target = "None"
        previousKnock = false
        previousDead = false
        lastTargetCharacter = nil
    end
end)
game:GetService("RunService").Stepped:Connect(function()
    pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
    split = string.split(pingvalue, '(')
    ping = tonumber(split[1])

    for _, data in ipairs(basePredictionTable) do
        if ping < data.ping then
            PredictionValue = data.value * GlobalPredictionMultiplier
            break
        end
    end
end)

RunService.Heartbeat:Connect(function(dt)
	if getnamecallmethod and matchacc.RapidFire.Enabled then
	    local tool = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Tool")
	    if tool and tool:FindFirstChild("GunScript") then 
	        for _, v in ipairs(getconnections(tool.Activated)) do
	            local funcinfo = debug.getinfo(v.Function)
	            for i = 1, funcinfo.nups do
	                local c, n = debug.getupvalue(v.Function, i)
	                if type(c) == "number" then 
	                    debug.setupvalue(v.Function, i, 0)
	                end
	            end
	        end
	    end
	end
    local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
    local useDesync = matchacc.TargetAim.Strafe or matchacc.TargetAim.AutoStomp or matchacc.KillAura.StompAura 
    local hrp = localPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Tool = localPlayer.Character:FindFirstChildOfClass("Tool")
    local SavedPosition = hrp.CFrame
    if useDesync and hrp then
        if matchacc.TargetAim.Strafe and matchacc.TargetAim.Target ~= "None" and TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Head") and not (AutoArmorActive or AutoLoadoutActive or BuyingSingleActive or BuyingAmmoActive) then
            if not TargetPlayer.Character:FindFirstChild("ForceField") then
                if not KnockCheck(TargetPlayer) and localPlayer.Character.BodyEffects.Reload.Value == false then
                    if matchacc.TargetAim.VoidResolver and (TargetPlayer.Character.HumanoidRootPart.Position - Vector3.new(0, 0, 0)).Magnitude > 5000 then return end
                    local currentPosition = TargetPlayer.Character.Head.Position
                    local lastPosition = previousPositions[TargetPlayer] or currentPosition
                    local estimatedVelocity = (currentPosition - lastPosition) / dt
                    local alpha = 0.5
                    customVelocities[TargetPlayer] = (customVelocities[TargetPlayer] or Vector3.zero) * alpha + estimatedVelocity * (1 - alpha)
                    previousPositions[TargetPlayer] = currentPosition
                    local strafeOffset
                    if matchacc.TargetAim.StrafeMethod == "Orbit" then
                        strafeOffset = Vector3.new(math.cos(tick()*10)*10, 0, math.sin(tick()*10)*10)
                    elseif matchacc.TargetAim.StrafeMethod == "Randomize" then
                        strafeOffset = Vector3.new(math.random(-15,15), math.random(-15,15), math.random(-15,15))
                    end
                    local desyncPosition = currentPosition + (customVelocities[TargetPlayer] * PredictionValue) + strafeOffset
                    hrp.CFrame = CFrame.lookAt(desyncPosition, currentPosition)
                    if matchacc.TargetAim.VisualizeStrafe then
                        BodyClone:SetPrimaryPartCFrame(hrp.CFrame)
                        BodyCloneHighlight.Enabled = true
                        SetRigTransparency(BodyClone, 0)
                        SetRigColor(BodyClone, matchacc.TargetAim.VisualizeStrafeInlineColor)
                        BodyCloneHighlight.FillColor = matchacc.TargetAim.VisualizeStrafeInlineColor
                        BodyCloneHighlight.OutlineColor = matchacc.TargetAim.VisualizeStrafeOutlineColor
                    else
                        BodyCloneHighlight.Enabled = false
                        BodyClone:SetPrimaryPartCFrame(CFrame.new(9999, 9999, 9999))
                        SetRigTransparency(BodyClone, 1)
                    end
                    if matchacc.TargetAim.LineStrafe and matchacc.TargetAim.VisualizeStrafe then
                        local rootPos = hrp.Position
                        local clonePos = BodyClone.HumanoidRootPart.Position
                        local screen1, onScreen1 = Camera:WorldToViewportPoint(rootPos)
                        local screen2, onScreen2 = Camera:WorldToViewportPoint(clonePos)
                        if onScreen1 and onScreen2 then
                            DesyncLine.From = Vector2.new(screen1.X, screen1.Y)
                            DesyncLine.To = Vector2.new(screen2.X, screen2.Y)
                            DesyncLine.Color = BodyCloneHighlight.FillColor
                            DesyncLine.Visible = true
                        else
                            DesyncLine.Visible = false
                        end
                    else
                        DesyncLine.Visible = false
                    end
                    local PredictedAimingPosition = currentPosition + (customVelocities[TargetPlayer] * PredictionValue)
                    local args = {
                        [1] = "ShootGun",
                        [2] = Tool.Handle,
                        [3] = Tool.Handle.Position,
                        [4] = PredictedAimingPosition,
                        [5] = TargetPlayer.Character.Head,
                        [6] = Vector3.new(0, 0, 0)
                    }
                    if matchacc.TargetAim.AutoFire then
                        MainEvent:FireServer(unpack(args))
                    elseif M1Down then
                        MainEvent:FireServer(unpack(args))
                    end
                    RunService:BindToRenderStep("RestoreStrafe", 199, function()
                        hrp.CFrame = SavedPosition
                        RunService:UnbindFromRenderStep("RestoreStrafe")
                    end)
                end
            else
                hrp.CFrame += Vector3.new(math.random(-11223344556677889900,11223344556677889900), math.random(0,11223344556677889900), math.random(-11223344556677889900,11223344556677889900))
                RunService:BindToRenderStep("RestoreRandom", 199, function()
                    hrp.CFrame = SavedPosition
                    RunService:UnbindFromRenderStep("RestoreRandom")
                end)
            end
        elseif TargetPlayer.Character:FindFirstChild("ForceField") or not Tool then
            hrp.CFrame += Vector3.new(math.random(-11223344556677889900,11223344556677889900), math.random(0,11223344556677889900), math.random(-11223344556677889900,11223344556677889900))
            RunService:BindToRenderStep("RestoreForceField", 199, function()
                hrp.CFrame = SavedPosition
                RunService:UnbindFromRenderStep("RestoreForceField")
            end)
        end
    else
        BodyClone:SetPrimaryPartCFrame(CFrame.new(9999, 9999, 9999))
        BodyCloneHighlight.Enabled = false
        DesyncLine.Visible = false
        ka_tracer.Transparency = 1
    end
    if matchacc.TargetAim.Enabled and matchacc.TargetAim.Target ~= "None" and TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Head") and not KnockCheck(TargetPlayer) then
        local tool = localPlayer.Character:FindFirstChildOfClass("Tool")
        if tool and (not TargetPlayer.Character:FindFirstChild("ForceField") or tool.Name == "[Rifle]") then
            if matchacc.TargetAim.AutoFire then
                if game.PlaceId == 9825515356 then
                    local args = {
                        "Shoot",
                        {
                            {
                                [1] = {
                                    ["Instance"] = TargetPlayer.Character.Head,
                                    ["Normal"] = Vector3.new(0.9937344193458557, 0.10944880545139313, -0.022651424631476402),
                                    ["Position"] = Vector3.new(-141.78562927246094, 33.89368438720703, -365.6424865722656)
                                },
                                [2] = {
                                    ["Instance"] = TargetPlayer.Character.Head,
                                    ["Normal"] = Vector3.new(0.9937344193458557, 0.10944880545139313, -0.022651424631476402),
                                    ["Position"] = Vector3.new(-141.78562927246094, 33.89368438720703, -365.6424865722656)
                                },
                                [3] = {
                                    ["Instance"] = TargetPlayer.Character.Head,
                                    ["Normal"] = Vector3.new(0.9937343597412109, 0.10944879800081253, -0.022651422768831253),
                                    ["Position"] = TargetPlayer.Character.Head.Position 
                                },
                                [4] = {
                                    ["Instance"] = TargetPlayer.Character.Head,
                                    ["Normal"] = Vector3.new(0.9937344193458557, 0.10944880545139313, -0.022651424631476402),
                                    ["Position"] = TargetPlayer.Character.Head.Position 
                                },
                                [5] = {
                                    ["Instance"] = TargetPlayer.Character.Head,
                                    ["Normal"] = Vector3.new(0.9937344193458557, 0.10944880545139313, -0.022651424631476402),
                                    ["Position"] = Vector3.new(-141.79481506347656, 34.033607482910156, -365.369384765625)
                                }
                            },
                            {
                                [1] = {
                                    ["thePart"] = TargetPlayer.Character.Head,
                                    ["theOffset"] = CFrame.new(0, 0, 0)
                                },
                                [2] = {
                                    ["thePart"] = TargetPlayer.Character.Head,
                                    ["theOffset"] = CFrame.new(0, 0, 0)
                                },
                                [3] = {
                                    ["thePart"] = TargetPlayer.Character.Head,
                                    ["theOffset"] = CFrame.new(0, 0, 0)
                                },
                                [4] = {
                                    ["thePart"] = TargetPlayer.Character.Head,
                                    ["theOffset"] = CFrame.new(0, 0, 0)
                                },
                                [5] = {
                                    ["thePart"] = TargetPlayer.Character.Head,
                                    ["theOffset"] = CFrame.new(0, 0, 0)
                                }
                            },
                            localPlayer.Character.Head.Position,
                            localPlayer.Character.Head.Position,
                            workspace:GetServerTimeNow()
                        }
                    }
                    MainEvent:FireServer(unpack(args))
                else
                    local args = {
                        [1] = "ShootGun",
                        [2] = tool.Handle,
                        [3] = tool.Handle.Position,
                        [4] = TargetPlayer.Character.Head.Position,
                        [5] = TargetPlayer.Character.Head,
                        [6] = Vector3.new(0, 0, 0)
                    }
                    MainEvent:FireServer(unpack(args))
                end
            elseif M1Down then
                local args = {
                    [1] = "ShootGun",
                    [2] = tool.Handle,
                    [3] = tool.Handle.Position,
                    [4] = TargetPlayer.Character.Head.Position,
                    [5] = TargetPlayer.Character.Head,
                    [6] = Vector3.new(0, 0, 0)
                }
                MainEvent:FireServer(unpack(args))
            end
        end
    end
end)
RunService.Heartbeat:Connect(function(dt)
    TargetAimActive = false
    BuyingActive = false
    AutoArmorActive = false
    AutoLoadoutActive = false
    BuyingSingleActive = false
    BuyingAmmoActive = false

    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Tool = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Tool")
    local SavedPosition = hrp and hrp.CFrame


    -- Desync logic (chỉ bật desync khi không mua đồ / không strafe)
    local useDesync = matchacc.TargetAim.Strafe or matchacc.TargetAim.AutoStomp or matchacc.KillAura.StompAura
    abletodesync = not (TargetAimActive or AutoArmorActive or AutoLoadoutActive or BuyingAmmoActive or BuyingSingleActive)

    -- === AUTO KILL LOGIC (PAUSE KHI MUA ĐỒ) ===
    if matchacc.AutoKill.Enabled and matchacc.AutoKill.Target and not (AutoArmorActive or AutoLoadoutActive or BuyingSingleActive or BuyingAmmoActive) then
        local Target = players:FindFirstChild(matchacc.AutoKill.Target)
        if Target and Target.Character and localPlayer.Character then
            local humanoidRootPart = localPlayer.Character:FindFirstChild("HumanoidRootPart")
            local head = localPlayer.Character:FindFirstChild("Head")
            local tool = localPlayer.Character:FindFirstChildOfClass("Tool")
            local toolHandle = tool and tool:FindFirstChild("Handle")
            local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
            local targetHead = Target.Character:FindFirstChild("Head")

			if humanoidRootPart and head and toolHandle and targetHRP and targetHead then
			    if Target.Character:FindFirstChild("Humanoid") then
			        local hum = Target.Character.Humanoid
			        local curr = math.round(hum.Health)
			        local prev = previousTargetHealth[Target.Name]
			
			        if prev ~= nil and curr < prev then
			            -- Hit Sound
			            if matchacc.HitEffects.HitSounds then
			                createHitSound()
			            end
			
			            -- Hit Notification
			            if matchacc.HitEffects.HitNotifications then
			                Library:Notify("NotHub - AutoKill Hit: " .. Target.Name .. " - Health: " .. curr, matchacc.HitEffects.HitNotificationsTime)
			            end
			
			            -- Hit Chams (chỉ khi đang target bằng AutoKill hoặc TargetAim)
			            if matchacc.HitEffects.HitChams.Enabled then
			                createHitChamWithFade(Target)
			            end
                        if matchacc.HitEffects.HitEffect.Enabled then
                            playHitEffect(Target)
                        end
			        end
			
			        previousTargetHealth[Target.Name] = curr
			    end
			end
        end
    end

	if matchacc.TargetAim.Enabled and matchacc.TargetAim.Target ~= "None" then
	    local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
	    if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Humanoid") then
	        local hum = TargetPlayer.Character.Humanoid
	        local curr = math.round(hum.Health)
	        local prev = previousTargetHealth[TargetPlayer.Name]
	
	        if prev ~= nil and curr < prev then
	            -- Hit Sound
	            if matchacc.HitEffects.HitSounds then
	                createHitSound()
	            end
	
	            -- Hit Notification
	            if matchacc.HitEffects.HitNotifications then
	                Library:Notify("NotHub - Target Hit: " .. TargetPlayer.Name .. " - Health: " .. curr, matchacc.HitEffects.HitNotificationsTime)
	            end
	
	            -- Hit Chams
	            if matchacc.HitEffects.HitChams.Enabled then
	                createHitChamWithFade(TargetPlayer)
	            end
				if matchacc.HitEffects.HitEffect.Enabled then
					playHitEffect(TargetPlayer)
				end
	        end
	
	        previousTargetHealth[TargetPlayer.Name] = curr
	    end
	end

    local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
    if matchacc.KillAura.Enabled then
        if Tool and Tool:FindFirstChild("Handle") then
            if localPlayer.Character.BodyEffects:FindFirstChild("K.O") and not localPlayer.Character.BodyEffects["K.O"].Value then
                local closest = math.huge
                local ka_target = nil
                for _, player in pairs(players:GetPlayers()) do
                    if player ~= localPlayer and not matchacc.KillAura.Whitelist[player.Name] and player.Character and player.Character:FindFirstChild("Head") and not player.Character:FindFirstChild("GRABBING_CONSTRAINT") then
                        if player.Character.BodyEffects:FindFirstChild("K.O") and not player.Character.BodyEffects["K.O"].Value then
                            local dist = (hrp.Position - player.Character.Head.Position).Magnitude
                            if dist < closest and dist <= matchacc.KillAura.Range then
                                closest = dist
                                ka_target = player
                            end
                        end
                    end
                end
                if ka_target and ka_target.Character and ka_target.Character:FindFirstChild("Head") then
                    hrp.CFrame = CFrame.lookAt(hrp.Position, ka_target.Character.Head.Position)
                    if matchacc.KillAura.Visualize then
                        ka_tracer.Transparency = 0
                        ka_tracer.Size = Vector3.new(0.2, 0.2, (hrp.Position - ka_target.Character.Head.Position).Magnitude)
                        ka_tracer.CFrame = CFrame.lookAt(hrp.Position, ka_target.Character.Head.Position) * CFrame.new(0, 0, -ka_tracer.Size.Z / 2)
                    else
                        ka_tracer.Transparency = 1
                    end
                    local humanoid = ka_target.Character:FindFirstChild("Humanoid")
                    if humanoid then
                        if not ka_lastHealth[ka_target.Name] then
                            ka_lastHealth[ka_target.Name] = humanoid.Health
                        end
                        if humanoid.Health < ka_lastHealth[ka_target.Name] then
                            createHitSound()
                        end
                        ka_lastHealth[ka_target.Name] = humanoid.Health
                    end
                    local offset = matchacc.KillAura.Silent and Vector3.new(0, -12, 0) or Vector3.new(0, 0, 0)
                    MainEvent:FireServer(
                        "ShootGun",
                        Tool:FindFirstChild("Handle"),
                        Tool:FindFirstChild("Handle").CFrame.Position + offset,
                        ka_target.Character.Head.Position + offset,
                        ka_target.Character.Head,
                        Vector3.new(0, 0, -1)
                    )
                else
                    ka_tracer.Transparency = 1
                end
            end
        else
            ka_tracer.Transparency = 1
        end
    end
    if matchacc.TargetAim.Enabled and matchacc.TargetAim.Target ~= "None" then
        local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
        if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Humanoid") and TargetPlayer.Character:FindFirstChild("Head") and not TargetPlayer.Character:FindFirstChild("ForceField") then
            local humanoid = TargetPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                local currentHealth = math.round(humanoid.Health)
                if lastHealth == nil or matchacc.TargetAim.Target ~= lastTarget then
                    lastHealth = currentHealth
                end
                if currentHealth < lastHealth then
                    if matchacc.HitEffects.HitNotifications then
                        Library:Notify("NotHub - Target Hit: " .. TargetPlayer.Name .. " - Health: " .. currentHealth, matchacc.HitEffects.HitNotificationsTime)
                    end
                    if matchacc.HitEffects.HitSounds then
                        createHitSound()
                    end
                end
                lastHealth = currentHealth
                lastTarget = matchacc.TargetAim.Target
            end
        end
    end
    if matchacc.TargetAim.Enabled and matchacc.TargetAim.Target ~= "None" and TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Head") then
        if matchacc.TargetAim.Highlight then
            if not TargetPlayer.Character:FindFirstChild("Highlight") then
                local Highlight = Instance.new("Highlight")
                Highlight.Parent = TargetPlayer.Character
            end
            TargetPlayer.Character.Highlight.FillColor = matchacc.TargetAim.HighlightFillColor
            TargetPlayer.Character.Highlight.OutlineColor = matchacc.TargetAim.HighlightOutlineColor
        end
        if matchacc.TargetAim.LookAt then
            localPlayer.Character.Humanoid.AutoRotate = false
            localPlayer.Character.HumanoidRootPart.CFrame = CFrame.lookAt(localPlayer.Character.HumanoidRootPart.Position, Vector3.new(TargetPlayer.Character.HumanoidRootPart.Position.X, localPlayer.Character.HumanoidRootPart.Position.Y, TargetPlayer.Character.HumanoidRootPart.Position.Z))
        else
            localPlayer.Character.Humanoid.AutoRotate = true
        end
        if matchacc.TargetAim.Tracer then
            local mouseScreenPosition = UserInputService:GetMouseLocation()
            local head = TargetPlayer.Character:FindFirstChild("Head")
            local humanoidRootPart = TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if head and humanoidRootPart then
                local headScreenPosition, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local adjustedMousePosition = Vector2.new(mouseScreenPosition.X, mouseScreenPosition.Y)
                    local tool = localPlayer.Character:FindFirstChildOfClass("Tool")
                    if matchacc.TargetAim.TracerPosition == "Tool" and tool and tool:FindFirstChild("Handle") then
                        local pos = Camera:WorldToViewportPoint(tool.Handle.Position)
                        tracer.From = Vector2.new(pos.X, pos.Y)
                        tracerOutline.From = Vector2.new(pos.X, pos.Y)
                    else
                        tracer.From = adjustedMousePosition
                        tracerOutline.From = adjustedMousePosition
                    end           
                    tracer.To = Vector2.new(headScreenPosition.X, headScreenPosition.Y)
                    tracerOutline.To = Vector2.new(headScreenPosition.X, headScreenPosition.Y)
                    tracerOutline.Visible = true
                    tracer.Visible = true
                    tracerOutline.Color = matchacc.TargetAim.TracerOutlineColor
                    tracer.Color = matchacc.TargetAim.TracerFillColor
                else
                    tracer.Visible = false
                    tracerOutline.Visible = false
                end
            end
        end
    else
        localPlayer.Character.Humanoid.AutoRotate = true
        tracer.Visible = false
        tracerOutline.Visible = false
    end
    if matchacc.TargetAim.Target ~= "None" then
        local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
        if TargetPlayer then
            if TargetPlayer.Character ~= lastTargetCharacter and lastTargetCharacter then
                Library:Notify(TargetPlayer.Name .. " respawned", 3)
                previousKnock = false
                previousDead = false
            end
            lastTargetCharacter = TargetPlayer.Character
            if TargetPlayer.Character then
                local be = TargetPlayer.Character:FindFirstChild("BodyEffects")
                if be then
                    local ko = be:FindFirstChild("K.O")
                    local sdeath = be:FindFirstChild("SDeath")
                    local hum = TargetPlayer.Character:FindFirstChildOfClass("Humanoid")
                    local currentKnock = ko and ko.Value or false
                    local currentDead = (sdeath and sdeath.Value) or (hum and hum.Health <= 0) or false
                    if currentKnock and not previousKnock then
                        Library:Notify(TargetPlayer.Name .. " knocked", 3)
                    end
                    if currentDead and not previousDead then
                        Library:Notify(TargetPlayer.Name .. " died", 3)
                    end
                    previousKnock = currentKnock
                    previousDead = currentDead
                end
            end
        else
            Library:Notify(matchacc.TargetAim.Target .. " left the game", 3)
            matchacc.TargetAim.Target = "None"
            previousKnock = false
            previousDead = false
            lastTargetCharacter = nil
        end
    end
    if not useDesync or hrp then 
        BodyClone:SetPrimaryPartCFrame(CFrame.new(9999, 9999, 9999))
        BodyCloneHighlight.Enabled = false
        DesyncLine.Visible = false
        ka_tracer.Transparency = 1
    end
    if useDesync and hrp then
        if matchacc.TargetAim.AutoStomp and TargetPlayer and KnockCheck(TargetPlayer) and localPlayer.Character.BodyEffects.Reload.Value == false then
            local bodyEffects = TargetPlayer.Character:FindFirstChild("BodyEffects")
            local isDead = bodyEffects and bodyEffects:FindFirstChild("SDeath") and bodyEffects.SDeath.Value
            if isDead == false then
                hrp.CFrame = CFrame.new(TargetPlayer.Character.UpperTorso.Position + Vector3.new(0, 3, 0))
                if matchacc.HitEffects.HitNotifications then
                    if tick() - t >= 3 then
                        t = tick()
                        Library:Notify("NotHub - Attempted to Stomp Target: " .. TargetPlayer.Name, matchacc.HitEffects.HitNotificationsTime)
                    end
                end
                MainEvent:FireServer("Stomp")
                RunService:BindToRenderStep("RestoreStomp", 199, function()
                    hrp.CFrame = SavedPosition
                    RunService:UnbindFromRenderStep("RestoreStomp")
                end)
            end
        elseif matchacc.KillAura.StompAura and not (TargetAimActive or AutoArmorActive or AutoLoadoutActive or BuyingAmmoActive or BuyingSingleActive) then
            local shortestDistance = math.huge
            local stompTarget
            for _, player in pairs(players:GetPlayers()) do
                if player ~= localPlayer and player.Character and player.Character:FindFirstChild("Head") and KnockCheck(player) and not player.Character:FindFirstChild("ForceField") then
                    local distance = (player.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                    if distance <= matchacc.KillAura.Range and distance < shortestDistance then
                        shortestDistance = distance
                        stompTarget = player
                    end
                end
            end
            if stompTarget then
                local bodyEffects = stompTarget.Character:FindFirstChild("BodyEffects")
                local isDead = bodyEffects and bodyEffects:FindFirstChild("SDeath") and bodyEffects.SDeath.Value
                if isDead == false then
                    hrp.CFrame = CFrame.new(stompTarget.Character.UpperTorso.Position + Vector3.new(0, 3, 0))
                    MainEvent:FireServer("Stomp")
                    RunService:BindToRenderStep("RestoreStompAura", 199, function()
                        hrp.CFrame = SavedPosition
                        RunService:UnbindFromRenderStep("RestoreStompAura")
                    end)
                end
            end
        end
    end
end)
game:GetService('RunService').Heartbeat:Connect(function(dt)

    -- Target Aim Logic (giữ nguyên từ script gốc của bạn)
    if matchacc.TargetAim.Enabled and matchacc.TargetAim.Strafe and matchacc.TargetAim.Target ~= "None" and localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and localPlayer.Character:FindFirstChild("Humanoid") and localPlayer.Character:FindFirstChild("Head") then
        local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
        local Tool = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Tool")
        if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Head") and Tool then
            if not TargetPlayer.Character:FindFirstChild("ForceField") or Tool.Name == "[Rifle]" then
                local bodyEffects = TargetPlayer.Character:FindFirstChild("BodyEffects")
                local isDead = bodyEffects and bodyEffects:FindFirstChild("Dead") and bodyEffects.Dead.Value
                if ((not KnockCheck(TargetPlayer)) or (matchacc.TargetAim.AutoStomp and isDead == false)) and localPlayer.Character and localPlayer.Character:FindFirstChild("BodyEffects") and localPlayer.Character.BodyEffects:FindFirstChild("Reload") and localPlayer.Character.BodyEffects.Reload.Value == false then
                    if matchacc.TargetAim.VoidResolver then
                        if (TargetPlayer.Character.HumanoidRootPart.Position - Vector3.new(0, 0, 0)).Magnitude > 5000 then
                            return
                        end
                    end
                    TargetAimActive = true
                end
            end
        end
    end
    -- Buy Single Logic
    if BuyingSingle and not game.Players.LocalPlayer.Character:FindFirstChild(SelectedGun) and not game.Players.LocalPlayer.Backpack:FindFirstChild(SelectedGun) then
        BuyingSingleActive = true
    end
    -- Buying Ammo Logic
    if BuyingAmmo then
        BuyingAmmoActive = true
    end
    -- Auto Loadout Logic (sửa: mua súng nếu chưa có, mua ammo nếu hết đạn - mua 3 lần)
    if headshots.AutoLoadout.Enabled and headshots.AutoLoadout.Gun and ShopTable[headshots.AutoLoadout.Gun] then
        local char = game.Players.LocalPlayer.Character
        local backpack = game.Players.LocalPlayer.Backpack
        local gunInChar = char:FindFirstChild(headshots.AutoLoadout.Gun)
        local gunInBackpack = backpack:FindFirstChild(headshots.AutoLoadout.Gun)
       
        -- Mua súng nếu chưa có
        if not gunInChar and not gunInBackpack then
            AutoLoadoutActive = true
        else
            -- Kiểm tra ammo (súng giờ ở backpack)
            local equippedGun = backpack:FindFirstChild(headshots.AutoLoadout.Gun)
            if equippedGun and equippedGun:FindFirstChild("Ammo") and equippedGun.Ammo.Value == 0 then
                -- Mua ammo 3 lần khi hết đạn
                local AmmoName = "[" .. headshots.AutoLoadout.Gun:sub(2, -2) .. " Ammo]"
                if ShopTable[AmmoName] then
                    for i = 1, 3 do
                        local shop = game.Workspace.Ignored.Shop:FindFirstChild(ShopTable[AmmoName].ShopName)
                        if shop and shop:FindFirstChild("Head") then
                            local hrp = char.HumanoidRootPart
                            local saved = hrp.CFrame
                            hrp.CFrame = shop.Head.CFrame
			                local currentTool = char:FindFirstChildOfClass("Tool")
			                if currentTool then
			                    currentTool.Parent = plr.Backpack
			                end
                            for j = 1, 5 do
                                fireclickdetector(shop:FindFirstChildOfClass("ClickDetector"))
                            end
                            game:GetService("RunService"):BindToRenderStep("RestoreCFrame", 199, function()
                                hrp.CFrame = saved
                                game:GetService("RunService"):UnbindFromRenderStep("RestoreCFrame")
                            end)
                        end
                    end
                end
            end
        end
    end
    -- Auto Armor Logic
    if headshots.AutoArmor.Enabled and game.Players.LocalPlayer.Character.BodyEffects.Armor.Value < 100 then
        AutoArmorActive = true
    end
    -- Checking for desync
    if TargetAimActive or matchacc.AutoKill.Enabled or AutoArmorActive or AutoLoadoutActive or BuyingAmmoActive or BuyingSingleActive then
        abletodesync = false
    else
        abletodesync = true
    end
    -- Xử lý mua hàng trong loop (tương tự headshotcc)
    local plr = game.Players.LocalPlayer
    local char = plr.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if char and hrp then
        pcall(function()
            -- Buy Single (thả bất kỳ tool đang cầm trước khi mua)
            if BuyingSingle and not char:FindFirstChild(SelectedGun) and not plr.Backpack:FindFirstChild(SelectedGun) then
                local shop = game.Workspace.Ignored.Shop:FindFirstChild(ShopTable[SelectedGun].ShopName)
                if shop and shop:FindFirstChild("Head") then
                    local saved = hrp.CFrame
                    hrp.CFrame = shop.Head.CFrame
	                local currentTool = char:FindFirstChildOfClass("Tool")
	                if currentTool then
	                    currentTool.Parent = plr.Backpack
	                end
                    for i = 1, 10 do
                        fireclickdetector(shop:FindFirstChildOfClass("ClickDetector"))
                    end
                    game:GetService("RunService"):BindToRenderStep("RestoreCFrame", 199, function()
                        hrp.CFrame = saved
                        game:GetService("RunService"):UnbindFromRenderStep("RestoreCFrame")
                    end)
                end
            else
                BuyingSingle = false
            end
            -- Buy Ammo (single pack) - đã có thả tool
            if BuyingAmmo then
                local AmmoName = "[" .. SelectedGun:sub(2, -2) .. " Ammo]"
                local ammoData = ShopTable[AmmoName]
                if ammoData then
                    local shop = game.Workspace.Ignored.Shop:FindFirstChild(ammoData.ShopName)
                    if shop and shop:FindFirstChild("Head") then
                        if char:FindFirstChild(SelectedGun) or plr.Backpack:FindFirstChild(SelectedGun) then
                            local gunObj = char:FindFirstChild(SelectedGun)
                            if gunObj then
                                gunObj.Parent = plr.Backpack
                            end
                            local saved = hrp.CFrame
                            hrp.CFrame = shop.Head.CFrame
			                local currentTool = char:FindFirstChildOfClass("Tool")
			                if currentTool then
			                    currentTool.Parent = plr.Backpack
			                end
                            for i = 1, 5 do
                                fireclickdetector(shop:FindFirstChildOfClass("ClickDetector"))
                            end
                            game:GetService("RunService"):BindToRenderStep("RestoreCFrame", 199, function()
                                hrp.CFrame = saved
                                game:GetService("RunService"):UnbindFromRenderStep("RestoreCFrame")
                            end)
                        end
                    end
                end
                BuyingAmmo = false
            end
            -- Auto Loadout (mua súng nếu chưa có - ammo đã xử lý ở trên)
            if headshots.AutoLoadout.Enabled and headshots.AutoLoadout.Gun and ShopTable[headshots.AutoLoadout.Gun] and not char:FindFirstChild(headshots.AutoLoadout.Gun) and not plr.Backpack:FindFirstChild(headshots.AutoLoadout.Gun) then
                -- Thả tool đang cầm nếu có
                local ShopItem = game.Workspace.Ignored.Shop:FindFirstChild(ShopTable[headshots.AutoLoadout.Gun].ShopName)
                if ShopItem and ShopItem:FindFirstChild("Head") then
                    local saved = hrp.CFrame
                    hrp.CFrame = ShopItem.Head.CFrame
	                local currentTool = char:FindFirstChildOfClass("Tool")
	                if currentTool then
	                    currentTool.Parent = plr.Backpack
	                    task.wait(0.1)
	                end
                    for i = 1, 5 do
                        fireclickdetector(ShopItem:FindFirstChildOfClass("ClickDetector"))
                    end
                    game:GetService("RunService"):BindToRenderStep("RestoreCFrame", 199, function()
                        hrp.CFrame = saved
                        game:GetService("RunService"):UnbindFromRenderStep("RestoreCFrame")
                    end)
                end
            end
            -- Auto Armor
            if headshots.AutoArmor.Enabled and char.BodyEffects and char.BodyEffects.Armor and char.BodyEffects.Armor.Value < 100 then
                local shop = game.Workspace.Ignored.Shop:FindFirstChild('[High-Medium Armor] - $2513')
                if shop and shop:FindFirstChild("Head") then
                    local oldArmor = char.BodyEffects.Armor.Value
                    local saved = hrp.CFrame
                    hrp.CFrame = shop.Head.CFrame
	                local currentTool = char:FindFirstChildOfClass("Tool")
	                if currentTool then
	                    currentTool.Parent = plr.Backpack
	                end
                    for i = 1, 5 do
                        fireclickdetector(shop:FindFirstChildOfClass("ClickDetector"))
                    end
                    game:GetService("RunService"):BindToRenderStep("RestoreCFrame", 199, function()
                        hrp.CFrame = saved
                        game:GetService("RunService"):UnbindFromRenderStep("RestoreCFrame")
                    end)
                    if char.BodyEffects.Armor.Value > oldArmor then
                    end
                end
            end
        end)
    end
end)
RunService.Heartbeat:Connect(function(dt)
        if matchacc.AutoKill.Enabled and matchacc.AutoKill.Target and not (AutoArmorActive or AutoLoadoutActive or BuyingSingleActive or BuyingAmmoActive) then
        if matchacc.AutoKill.Target ~= nil then
            local Target = players:FindFirstChild(matchacc.AutoKill.Target)
            if Target and Target.Character and localPlayer and localPlayer.Character then
                local humanoidRootPart = localPlayer.Character:FindFirstChild("HumanoidRootPart")
                local head = localPlayer.Character:FindFirstChild("Head")
                local tool = localPlayer.Character:FindFirstChildOfClass("Tool")
                local toolHandle = tool and tool:FindFirstChild("Handle")
                local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
                local targetHead = Target.Character:FindFirstChild("Head")

                local SavedPosition = localPlayer.Character.HumanoidRootPart.CFrame

                if humanoidRootPart and head and toolHandle and targetHRP and targetHead then
                    if not KnockCheck(Target) then
                        if not Target.Character:FindFirstChild("ForceField") then
                            localPlayer.Character.HumanoidRootPart.CFrame = CFrame.lookAt(Target.Character.Head.Position + Vector3.new(math.random(-15,15), math.random(-15,15), math.random(-15,15)), Target.Character.Head.Position)
                            Library:Notify("NotHub - Shooting Target.", 1)
                            MainEvent:FireServer("ShootGun", toolHandle, toolHandle.Position, Target.Character.Head.Position, targetHead, Vector3.new(0, 1, 0))
                        else
                            localPlayer.Character.HumanoidRootPart.CFrame += Vector3.new(math.random(-11223344556677889900,11223344556677889900), math.random(0,11223344556677889900), math.random(-11223344556677889900,11223344556677889900))
                            Library:Notify("NotHub - Waiting.. Target has spawn protection.", 1)
                            MainEvent:FireServer("Reload", tool)
                        end
                        if matchacc.AutoKill.AutoKillDesync then
                            RunService:BindToRenderStep("RestoreCFrame", 199, function()
                                localPlayer.Character.HumanoidRootPart.CFrame = SavedPosition
                                RunService:UnbindFromRenderStep("RestoreCFrame")
                            end)
                        end
                    else
                        -- Handle dead targets
                        local bodyEffects = Target.Character:FindFirstChild("BodyEffects")
                        local isDead = bodyEffects and bodyEffects:FindFirstChild("SDeath") and bodyEffects.SDeath.Value
                        if isDead == false then
                            if Target.Character:FindFirstChild("UpperTorso") and Target.Character:FindFirstChild("HumanoidRootPart") and Target.Character:FindFirstChild("Humanoid") then
                                humanoidRootPart.CFrame = CFrame.new(Target.Character.UpperTorso.Position + Vector3.new(0, 3, 0))
                                Library:Notify("NotHub - Stomping Target.", 1)
                                MainEvent:FireServer("Stomp")
                            end
                        elseif isDead == true then
                            -- Move to safe position when target is dead
                            localPlayer.Character.HumanoidRootPart.CFrame += Vector3.new(math.random(-11223344556677889900,11223344556677889900), math.random(0,11223344556677889900), math.random(-11223344556677889900,11223344556677889900))
                            Library:Notify("NotHub - Waiting.. Target is currently dead.", 1)
                            MainEvent:FireServer("Reload", tool)
                        end

                        if matchacc.AutoKill.AutoKillDesync then
                            RunService:BindToRenderStep("RestoreCFrame", 199, function()
                                localPlayer.Character.HumanoidRootPart.CFrame = SavedPosition
                                RunService:UnbindFromRenderStep("RestoreCFrame")
                            end)
                        end

                    end
                else
                    localPlayer.Character.HumanoidRootPart.CFrame += Vector3.new(math.random(-11223344556677889900,11223344556677889900), math.random(0,11223344556677889900), math.random(-11223344556677889900,11223344556677889900))
                    Library:Notify("NotHub - Waiting.. Equip your gun while using 'Auto Kill Target'.", 1)

                    if matchacc.AutoKill.AutoKillDesync then
                        RunService:BindToRenderStep("RestoreCFrame", 199, function()
                            localPlayer.Character.HumanoidRootPart.CFrame = SavedPosition
                            RunService:UnbindFromRenderStep("RestoreCFrame")
                        end)
                    end
                end
            end
        else
            -- If no target is found
            local humanoidRootPart = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                humanoidRootPart.CFrame += Vector3.new(math.random(-11223344556677889900,11223344556677889900), math.random(0,11223344556677889900), math.random(-11223344556677889900,11223344556677889900))
            end
            Library:Notify("NotHub - Target not found(Hide void).", 3)
            if matchacc.AutoKill.AutoKillDesync then
                RunService:BindToRenderStep("RestoreCFrame", 199, function()
                    localPlayer.Character.HumanoidRootPart.CFrame = SavedPosition
                    RunService:UnbindFromRenderStep("RestoreCFrame")
                end)
            end
        end
    end
end)
local RS = cloneref(game:GetService("RunService"))
local highlights = {}

RS.RenderStepped:Connect(function()
    if matchacc.HitboxExpander.Enabled then
        for _, Player in pairs(players:GetPlayers()) do
            if Player == Client then continue end
            local HRP = Player.Character and Player.Character:WaitForChild("HumanoidRootPart")
            if HRP then
                HRP.Size = Vector3.new(matchacc.HitboxExpander.Size, matchacc.HitboxExpander.Size, matchacc.HitboxExpander.Size)
                HRP.CanCollide = false
                if matchacc.HitboxExpander.Visualize then
                    if not highlights[Player] then
                        local Visualize = Instance.new("Highlight")
                        HRP.Transparency = 0.9
                        Visualize.Parent = HRP
                        Visualize.FillColor = matchacc.HitboxExpander.Color
                        Visualize.OutlineColor = matchacc.HitboxExpander.OutlineColor
                        Visualize.FillTransparency = matchacc.HitboxExpander.FillTransparency
                        Visualize.OutlineTransparency = matchacc.HitboxExpander.OutlineTransparency
                        highlights[Player] = Visualize
                    else
                        local Visualize = highlights[Player]
                        HRP.Transparency = 0.9
                        Visualize.FillColor = matchacc.HitboxExpander.Color
                        Visualize.OutlineColor = matchacc.HitboxExpander.OutlineColor
                        Visualize.FillTransparency = matchacc.HitboxExpander.FillTransparency
                        Visualize.OutlineTransparency = matchacc.HitboxExpander.OutlineTransparency
                    end
                else
                    local Visualize = highlights[Player]
                    if Visualize then
                        Visualize:Destroy()
                        HRP.Transparency = 1
                        highlights[Player] = nil
                    end
                end
            end
        end
    end
end)

local CharacterModsGroup = Tabs.Character:AddRightGroupbox('Character Mods')

-- Anti Slowdown (No Slow / No Jump Cooldown / No Reload Slow)
local function toggleAntiSlow(bool)
    if bool then
        RunService:BindToRenderStep("Anti-Slow", Enum.RenderPriority.Camera.Value, function()
            if localPlayer.Character and localPlayer.Character:FindFirstChild("BodyEffects") then
                local BE = localPlayer.Character.BodyEffects
                local Movement = BE:FindFirstChild("Movement")
                if Movement then
                    if Movement:FindFirstChild("NoWalkSpeed") then Movement.NoWalkSpeed:Destroy() end
                    if Movement:FindFirstChild("ReduceWalk") then Movement.ReduceWalk:Destroy() end
                    if Movement:FindFirstChild("NoJumping") then Movement.NoJumping:Destroy() end
                end
                if BE:FindFirstChild("Reload") and BE.Reload.Value then
                    BE.Reload.Value = false
                end
            end
        end)
    else
        RunService:UnbindFromRenderStep("Anti-Slow")
    end
end

CharacterModsGroup:AddToggle('AntiSlow', {
    Text = 'No Slowdown',
    Default = false,
    Callback = function(v) toggleAntiSlow(v) end
})

-- No Jump Cooldown
getgenv().NoJumpCooldown = false
RunService.RenderStepped:Connect(function()
    if getgenv().NoJumpCooldown and localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
        local hum = localPlayer.Character.Humanoid
        hum.UseJumpPower = not hum.UseJumpPower
    end
end)

CharacterModsGroup:AddToggle('NoJumpCooldown', {
    Text = 'No Jump Cooldown',
    Default = false,
    Callback = function(v) getgenv().NoJumpCooldown = v end
})
-- ==================== ANIMATION (Right Side) ====================
local AnimationGroup = Tabs.Character:AddRightGroupbox('Animation')


getgenv().Matcha.Dance = {
    Enabled = false,
    Playing = false,
    Selected = "Baby Queen - Bouncy Twirl",
    AnimationId = "14352343065"
}

local DanceList = {
    ["Baby Queen - Bouncy Twirl"] = "14352343065",
    ["Floss"] = "10714340543",
    ["Yungblud Happier Jump"] = "15609995579",
    ["Godlike"] = "10714347256",
    ["Mae Stephens - Dance"] = "16553163212",
    ["Victory Dance"] = "15505456446",
    ["Elton John - Heart Skip"] = "11309255148",
    ["Sturdy Dance - Ice Spice"] = "17746180844",
    ["Old Town Road Dance"] = "10714391240",
    ["Sidekicks"] = "10370362157",
    ["Baby Dance"] = "10713983178",
    ["Rampage"] = "139658061151500",
    ["Rambunctious"] = "85916053135662",
    ["Griddy"] = "121966805049108",
    ["Orange Justice"] = "78927657777256"
}

local danceTrack = nil

local function loadDance(name)
    local char = localPlayer.Character
    if not char or not char:FindFirstChild("Humanoid") then return end

    if danceTrack then
        danceTrack:Stop()
        danceTrack:Destroy()
        danceTrack = nil
    end

    local animId = DanceList[name]
    if animId then
        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://" .. animId
        danceTrack = char.Humanoid:LoadAnimation(anim)
        danceTrack.Priority = Enum.AnimationPriority.Action
        if getgenv().Matcha.Dance.Playing then
            danceTrack.Looped = true
            danceTrack:Play()
        end
    end
end

AnimationGroup:AddDropdown('DanceSelect', {
    Values = (function()
        local t = {}
        for k,_ in pairs(DanceList) do table.insert(t, k) end
        table.sort(t)
        return t
    end)(),
    Default = 1,
    Multi = false,
    Text = 'Dance Animation',
    Searchable = true,
    Callback = function(v)
        getgenv().Matcha.Dance.Selected = v
        loadDance(v)
    end
})

AnimationGroup:AddToggle('DanceToggle', {
    Text = 'Play Dance',
    Default = false,
    Callback = function(v)
        getgenv().Matcha.Dance.Enabled = v
        getgenv().Matcha.Dance.Playing = v
        if v and danceTrack then
            danceTrack.Looped = true
            danceTrack:Play()
        elseif danceTrack then
            danceTrack:Stop()
        end
    end
}):AddKeyPicker('DanceKey', {
    Default = 'None',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Dance Keybind'
})
coroutine.wrap(function()
local KeepOnDeath = false

-- Animation hiện tại đang dùng
local AnimationOptions = {
    ["Idle1"] = "http://www.roblox.com/asset/?id=180435571",
    ["Idle2"] = "http://www.roblox.com/asset/?id=180435792",
    ["Walk"]  = "http://www.roblox.com/asset/?id=180426354",
    ["Run"]   = "http://www.roblox.com/asset/?id=180426354",
    ["Jump"]  = "http://www.roblox.com/asset/?id=125750702",
    ["Climb"] = "http://www.roblox.com/asset/?id=180436334",
    ["Fall"]  = "http://www.roblox.com/asset/?id=180436148"
}

-- Danh sách animation pack
local AnimationSets = {
    ["Default"]   = { idle1 = "180435571", idle2 = "180435792", walk = "180426354", run = "180426354", jump = "125750702", climb = "180436334", fall = "180436148" },
    ["Ninja"]     = { idle1 = "656117400", idle2 = "656118341", walk = "656121766", run = "656118852", jump = "656117878", climb = "656114359", fall = "656115606" },
    ["Superhero"] = { idle1 = "616111295", idle2 = "616113536", walk = "616122287", run = "616117076", jump = "616115533", climb = "616104706", fall = "616108001" },
    ["Robot"]     = { idle1 = "616088211", idle2 = "616089559", walk = "616095330", run = "616091570", jump = "616090535", climb = "616086039", fall = "616087089" },
    ["Cartoon"]   = { idle1 = "742637544", idle2 = "742638445", walk = "742640026", run = "742638842", jump = "742637942", climb = "742636889", fall = "742637151" },
    ["Catwalk"]   = { idle1 = "133806214992291", idle2 = "94970088341563", walk = "109168724482748", run = "81024476153754", jump = "116936326516985", climb = "119377220967554", fall = "92294537340807" },
    ["Zombie"]    = { idle1 = "616158929", idle2 = "616160636", walk = "616168032", run = "616163682", jump = "616161997", climb = "616156119", fall = "616157476" },
    ["Mage"]      = { idle1 = "707742142", idle2 = "707855907", walk = "707897309", run = "707861613", jump = "707853694", climb = "707826056", fall = "707829716" },
    ["Pirate"]    = { idle1 = "750785693", idle2 = "750782770", walk = "750785693", run = "750782770", jump = "750782770", climb = "750782770", fall = "750782770" },
    ["Knight"]    = { idle1 = "657595757", idle2 = "657568135", walk = "657552124", run = "657564596", jump = "657560148", climb = "657556206", fall = "657552124" },
    ["Vampire"]   = { idle1 = "1083465857", idle2 = "1083465857", walk = "1083465857", run = "1083465857", jump = "1083465857", climb = "1083465857", fall = "1083465857" },
    ["Bubbly"]    = { idle1 = "910004836", idle2 = "910009958", walk = "910034870", run = "910025107", jump = "910016857", climb = "910009958", fall = "910009958" },
    ["Elder"]     = { idle1 = "845386501", idle2 = "845397899", walk = "845403856", run = "845386501", jump = "845386501", climb = "845386501", fall = "845386501" },
    ["Toy"]       = { idle1 = "782841498", idle2 = "782841498", walk = "782841498", run = "782841498", jump = "782841498", climb = "782841498", fall = "782841498" }
}

-- Hàm áp dụng animation
local function applyCustomAnimations(character)
    if not character or not character:FindFirstChild("Animate") then return end
    local Animate = character.Animate

    local Cloned = Animate:Clone()
    Cloned.idle.Animation1.AnimationId = AnimationOptions.Idle1
    Cloned.idle.Animation2.AnimationId = AnimationOptions.Idle2
    Cloned.walk.WalkAnim.AnimationId   = AnimationOptions.Walk
    Cloned.run.RunAnim.AnimationId     = AnimationOptions.Run
    Cloned.jump.JumpAnim.AnimationId   = AnimationOptions.Jump
    Cloned.climb.ClimbAnim.AnimationId = AnimationOptions.Climb
    Cloned.fall.FallAnim.AnimationId   = AnimationOptions.Fall

    Animate:Destroy()
    Cloned.Parent = character
end

-- Áp dụng khi respawn nếu bật Keep On Death
localPlayer.CharacterAdded:Connect(function(char)
    if KeepOnDeath then
        task.wait(1.5)
        applyCustomAnimations(char)
    end
end)

-- Tạo danh sách tên pack
local animPackNames = {}
for name,_ in pairs(AnimationSets) do table.insert(animPackNames, name) end
table.sort(animPackNames)

-- Hàm cập nhật 1 animation riêng lẻ
local function updateAnimation(key, id)
    AnimationOptions[key] = "http://www.roblox.com/asset/?id=" .. id
    if localPlayer.Character then
        applyCustomAnimations(localPlayer.Character)
    end
end
AnimationGroup:AddDropdown('AnimPack', {
    Values = animPackNames,
    Default = 1,
    Multi = false,
    Text = 'Animation Pack',
    Searchable = true,
    Callback = function(value)
        local set = AnimationSets[value]
        updateAnimation("Idle1", set.idle1)
        updateAnimation("Idle2", set.idle2)
        updateAnimation("Walk",  set.walk)
        updateAnimation("Run",   set.run)
        updateAnimation("Jump",  set.jump)
        updateAnimation("Climb", set.climb)
        updateAnimation("Fall",  set.fall)
    end
})

AnimationGroup:AddDropdown('Idle1', {
    Values = animPackNames,
    Default = 1,
    Multi = false,
    Text = 'Idle Animation 1',
    Callback = function(v) updateAnimation("Idle1", AnimationSets[v].idle1) end
})

AnimationGroup:AddDropdown('Idle2', {
    Values = animPackNames,
    Default = 1,
    Multi = false,
    Text = 'Idle Animation 2',
    Callback = function(v) updateAnimation("Idle2", AnimationSets[v].idle2) end
})

AnimationGroup:AddDropdown('Walk', {
    Values = animPackNames,
    Default = 1,
    Multi = false,
    Text = 'Walk Animation',
    Callback = function(v) updateAnimation("Walk", AnimationSets[v].walk) end
})

AnimationGroup:AddDropdown('Run', {
    Values = animPackNames,
    Default = 1,
    Multi = false,
    Text = 'Run Animation',
    Callback = function(v) updateAnimation("Run", AnimationSets[v].run) end
})

AnimationGroup:AddDropdown('Jump', {
    Values = animPackNames,
    Default = 1,
    Multi = false,
    Text = 'Jump Animation',
    Callback = function(v) updateAnimation("Jump", AnimationSets[v].jump) end
})

AnimationGroup:AddDropdown('Climb', {
    Values = animPackNames,
    Default = 1,
    Multi = false,
    Text = 'Climb Animation',
    Callback = function(v) updateAnimation("Climb", AnimationSets[v].climb) end
})

AnimationGroup:AddDropdown('Fall', {
    Values = animPackNames,
    Default = 1,
    Multi = false,
    Text = 'Fall Animation',
    Callback = function(v) updateAnimation("Fall", AnimationSets[v].fall) end
})

AnimationGroup:AddToggle('KeepAnimOnDeath', {
    Text = 'Keep On Death',
    Default = false,
    Tooltip = 'Giữ animation sau khi respawn',
    Callback = function(v) KeepOnDeath = v end
})
end)()
getgenv().Matcha.Character = getgenv().Matcha.Character or {}
getgenv().Matcha.Character.Noclip = false

local NoclipConnection
local function toggleNoclip(bool)
    getgenv().Matcha.Character.Noclip = bool
    if bool then
        NoclipConnection = RunService.Stepped:Connect(function()
            if localPlayer.Character then
                for _, v in pairs(localPlayer.Character:GetDescendants()) do
                    if v:IsA("BasePart") and v.CanCollide then
                        v.CanCollide = false
                    end
                end
            end
        end)
    else
        if NoclipConnection then NoclipConnection:Disconnect() end
    end
end

CharacterModsGroup:AddToggle('Noclip', {
    Text = 'Noclip',
    Default = false,
    Callback = toggleNoclip
}):AddKeyPicker('NoclipKey', { Default = 'N', SyncToggleState = true, Mode = 'Toggle', Text = 'Noclip' })

do
    local CollectionService = game:GetService("CollectionService")
    local seats = {}
    local function disableSeat(seat, bool)
        if seat and seat:IsA("Seat") then
            seat.Disabled = bool
            if bool then CollectionService:AddTag(seat, "NoSitSeat") else CollectionService:RemoveTag(seat, "NoSitSeat") end
        end
    end
    for _, seat in workspace:GetDescendants() do
        if seat:IsA("Seat") then disableSeat(seat, false) table.insert(seats, seat) end
    end
    workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("Seat") then table.insert(seats, obj) disableSeat(obj, getgenv().NoSeat or false) end
    end)
    CharacterModsGroup:AddToggle('NoSeat', {
        Text = 'No Seat',
        Default = false,
        Callback = function(v)
            getgenv().NoSeat = v
            for _, seat in seats do disableSeat(seat, v) end
        end
    })
end
coroutine.wrap(function()
local LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Auto Chatters')
-- List of Rizz lines
local Rizz = {
    "Are you a magician? Because whenever I look at you, everyone else disappears.",
    "Do you have a map? I keep getting lost in your eyes.",
    "Are you French? Because Eiffel for you.",
    "Are you a campfire? Because you’re hot and I want s’more.",
    "Do you have a Band-Aid? Because I just scraped my knee falling for you.",
    "Are you a time traveler? Because I see you in my future.",
    "Do you have a sunburn, or are you always this hot?",
    "Is your dad a boxer? Because you’re a knockout!",
    "Are you a snowstorm? Because you make my heart race.",
    "Can I follow you home? Cause my parents always told me to follow my dreams.",
    "Are you a camera? Because every time I look at you, I smile.",
    "Are you an angel? Because heaven is missing one.",
    "Is it hot in here or is it just you?",
    "Can you lend me a pencil? Because I want to draw a smile on your face.",
    "Do you know if there are any Wi-Fi signals around here? Because I’m feeling a connection.",
    "Is your name Chapstick? Because you’re da balm!",
    "Are you a dictionary? Because you add meaning to my life.",
    "Do you have a pencil? Because I want to erase your past and write our future.",
    "Do you have a quarter? Because I want to call my mom and tell her I met ‘The One’."
}

Debris = game:GetService("Debris")

-- Toggle the script state
_G.rizzEnabled = false

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Rizz chatter',
    Default = false, -- Default value (true / false)
    Tooltip = 'Rizzes up the shawtys', -- Information shown when you hover over the toggle
    
    Callback = function(Value)
        _G.rizzEnabled = Value
        
        if _G.rizzEnabled then
            -- Function to send a random Rizz line
            local function sendRandomRizz()
                local message = Rizz[math.random(#Rizz)] -- Choose a random line
                print("Sending rizz: " .. message)
                
                -- Chat system support (new and legacy)
                local chat = TextChatService.ChatInputBarConfiguration.TargetTextChannel
                
                if TextChatService.ChatVersion == Enum.ChatVersion.LegacyChatService then
                    local chatEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
                    if chatEvent then
                        chatEvent.SayMessageRequest:FireServer(message, "All")
                    end
                elseif chat then
                    chat:SendAsync(message)
                else
                    print("Chat system not available.")
                end
            end
            
            -- Set up loop to send Rizz line every 3 seconds
            _G.rizzLoop = task.spawn(function()
                while _G.rizzEnabled do
                    sendRandomRizz()
                    task.wait(3) -- Wait 3 seconds before sending another line
                end
            end)
        else
            -- Stop the loop
            if _G.rizzLoop then
                task.cancel(_G.rizzLoop)
                _G.rizzLoop = nil
            end
        end
    end
}):AddKeyPicker('Rizzchat', { Default = 'none', SyncToggleState = true, Mode = 'Toggle', Text = 'rizzchat' })

Toxic = {
"EZ",
"Bro doesn't know what aimlabs is",
"SO EZ",
"What are you aiming at, the skybox?",
"Bro doesn't have rizz",
"Sigma who?",
"storm trooper ahh",

"Am still buffering",
"Bro shooting at butterflies",
"Your aim took PTO",
"Skill issue deluxe edition",
"Crosshair needs therapy",
"Bro lagging in real life",
"Movement downloaded wrong",
"Rizz meter: 0%",
"Sigma mode: disabled",
"Bullets allergic to damage",
"Your aim is camera shy",
"Bro fighting shadows",
"Accuracy on cooldown",
"Gameplay running at 12 FPS",
"Aim.exe stopped responding",
"Stormtrooper firmware installed",
"Bro’s crosshair wandering",
"Missed in 4K",
"Bro swinging at the air",
"Movement lookin like wet socks",
"Your aim wandered off the map",
"Controller disconnected vibes",
"NPC aim > your aim",
"Bullets practicing pacifism",
"Your aim forgot the assignment",
"Bro plays like it’s a cutscene",
"Accuracy experiencing turbulence",
"Bro using demo version skills",
"Crosshair lost its purpose",
"Your aim needs a GPS",
"Movement confused about reality",
"Aim spiritually lost",
"Bro missing like it’s tradition",
"Your aim went AFK",
"Bro’s WiFi powered by hope",
"Lag fighting lag",
"Bro aiming like he’s daydreaming",
"Crosshair on vacation",
"Bro’s bullets taking detours",
"Movement stuck in airplane mode",
"Bro playing on grandma settings",
"Your aim needs calibration",
"Skillpack not installed",
"Accuracy in spectator mode",
"Bro’s aim loaded the wrong map",
"Bullets refusing to cooperate",
"Bro still in warmup",
"Crosshair socially anxious",
"Aim drifting like a car",
"Your bullets scared of commitment",
"Movement having identity issues",
"Bro’s aim under construction",
"Aim RNG not in your favor",
"Bro fighting gravity instead",
"Accuracy clocked out early",
"Your aim is guessing",
"Stormtrooper mode: ultra",
"Bro controlling recoil not aim",
"Your crosshair filing taxes",
"Aim forgot to spawn in",
"Movement stuck on loading screen",
"Bro playing on emotional ping",
"Crosshair doing side quests",
"Your aim needs counseling",
"Bro’s bullets peaceful mode",
"Aim failed to render",
"Movement lagging IRL",
"Bro using free trial aim",
"Accuracy downgraded",
"Crosshair overslept",
"Your aim exploring the scenery",
"Bro aiming with confidence but no direction",
"Bullets wandering aimlessly",
"Aim stuck in the loading zone",
"Movement slippery like ice",
"Bro’s aim needs patch notes",
"Your aim buffering in HD",
"Crosshair trying its best… maybe",
"Bro swinging like a malfunctioning fan",
"Your aim studying astronomy",
"Aim forgot its job",
"Bro hitting everything but enemies",
"Accuracy in low power mode",
"Crosshair vibing, not aiming",
"Movement disconnected",
"Bro missing like he’s sponsored by misclicks",
"Your aim took a smoke break",
"Bullets lost in transit",
"Aim trying to escape the game",
"Bro moving like WiFi on 1 bar",
"Crosshair running diagnostics",
"Your aim ran out of RAM",
"Aim asked for tech support",
"Bro’s accuracy in airplane mode",
"Movement downloaded from Wish",
"Bullets still loading",
"Your aim politely avoiding hits",
"Bro playing like the screen is optional",
"Aim trying to find itself",
"Crosshair doing freestyle mode",
"Movement emotionally unstable",
"Your aim saw the enemy and panicked",
"Bro’s aim fell asleep",
"Accuracy evaporated",
"Aim forgot collision exists",
"Bro missing like it’s a hobby",
"Your aim is a hazard",
"Crosshair sightseeing mid-fight",
"Aim desynced from reality",
"Bro fumbling the universe",
"Movement delayed by 3 business days",
"Your aim running on Windows 95",
"Bullets refusing to participate",
"Bro’s aim was not invited",
"Accuracy taking a vacation",
"Aim socially distancing",
"Movement powered by sadness",
"Bro’s crosshair practicing free will",
"Your aim got stage fright",
"Aim took the scenic route",
"Bullets lagging behind",
"Crosshair locked in confusion",
"Bro playing with negative FPS",
"Accuracy downgraded to demo",
"Aim malfunction detected",
"Bro still calibrating mid-fight",
"Your aim filed for retirement",
"Crosshair crashed",
"Aim dehydrated",
"Bro lost in the tutorial",
"Accuracy not responding",
"Your aim out of service",
"Aim forgot to clock in",
"Movement refusing commands",
"Bro’s bullets questioning life",
"Your aim is guessing wildly",
"Accuracy in economy mode",
"Bro casting invisible bullets",
"Crosshair slipped",
"Aim taking a coffee break",
"Bro’s skill expired",
"Your aim stuck in traffic",
"Accuracy on lunch break",
"Bro aiming with vibes only",
"Bullets too shy to hit",
"Movement soft-locked",
"Aim in spectator mode",
"Bro struggling to load accuracy",
"Your aim practicing pacifism",
"Crosshair confused and scared",
"Aim downloading updates",
"Bro playing at 2 FPS",
"Accuracy got nerfed",
"Your aim suffering lag spikes",
"Movement doing interpretive dance",
"Aim fell into the void",
"Bro missing geometrically impossible shots",
"Crosshair trying to escape",
"Your aim is legally blind (in-game)",
"Aim drifting into another timeline",
"Bro using expired accuracy",
"Movement skipped tutorial",
"Accuracy sleeping on the job",
"Aim lagging behind reality",
"Bro hitting the environment only",
"Your aim lost connection",
"Crosshair teleported away",
"Aim stunned by existence",
"Bro failing aim labs IRL",
"Accuracy scared of enemies",
"Your aim rendered in 144p",
"Aim refusing to load assets",
"Bro missing the broad side of a barn",
"Movement glitching",
"Accuracy socially awkward",
"Aim listening to music instead",
"Bro’s bullets on energy saver",
"Your aim daydreaming",
"Crosshair on strike",
"Aim running outdated firmware",
"Bro aiming at the moon",
"Accuracy evaporated",
"Movement sideways for no reason",
"Your aim soft-crashed",
"Aim started lagging emotionally",
"Bro throwing warning shots only",
"Accuracy downgraded itself",
"Your aim ghosting the enemy",
"Crosshair off-task again",
"Aim opening another app",
"Bro’s bullets overshot the universe",
"Movement experiencing burnout",
"Accuracy in exile",
"Aim went AFK",
"Bro sightseeing mid-fight",
"Your aim yawning",
"Crosshair negotiating hits",
"Aim too tired to function",
"Bro blasting everything but enemies",
"Accuracy taking personal days",
"Aim studying the environment",
"Your aim under review",
"Crosshair needs updates",
"Aim rebelling",
"Bro’s aim staged a protest",
"Accuracy disconnected spiritually",
"Aim floating around",
"Your crosshair afraid of commitment",
"Bro needs aim therapy",
"Aim fumbling basic tasks",
"Movement directionless",
"Accuracy running diagnostics",
"Your aim unsure of life choices",
"Crosshair recalibrating vibes",
"Aim zoned out",
"Bro hit the air perfectly",
"Accuracy missing completely",
"Aim spinning out of control",
"Bro performing a magic trick instead of aiming",
"Your aim procrastinating",
"Crosshair confused about existence",
"Aim wants to go home",
"Bro misclicked his confidence",
"Accuracy melting",
"Aim expired",
"Your aim visiting another match",
"Crosshair chilling",
"Aim replaying memories",
"Movement daydreaming",
"Bro skipped accuracy day",
"Your aim still buffering",
"Accuracy reconsidering its career",
"Aim dizzy",
"Bro misinterpreting geometry",
"Your aim undecided",
"Crosshair weak",
"Aim practicing self-care",
"Bro failing aim school",
"Accuracy strolling",
"Aim drifting off",
"Your aim derailed",
"Movement processing slowly",
"Bro running Windows Vista aim",
"Accuracy loading for eternity",
"Aim refusing orders",
"Your aim in safe mode",
"Crosshair malfunctioning creatively",
"Aim too shocked to aim",
"Bro missed so hard it looped",
"Accuracy sleeping peacefully",
"Aim in airplane mode",
"Your aim pretending to be blind",
"Bro’s bullets hesitating",
"Crosshair short-circuited",
"Aim out of energy",
"Accuracy submitted resignation",
"Aim confused about physics",
"Movement taking scenic route",
"Bro applying for new aim",
"Accuracy underwhelmed",
"Aim scared of the target",
"Your aim misplaced",
"Crosshair borrowed from another game",
"Aim reported missing",
"Bro downloaded the wrong skill pack",
"Accuracy frozen",
"Aim needs therapy",
"Movement overwhelmed",
"Your aim lagging mentally",
"Aim refusing to lock on",
"Bro practicing nonviolence",
"Accuracy took a sick day",
"Your aim yeeted itself",
"Crosshair got lost",
"Aim taking shortcuts",
"Bro’s aim compressed",
"Accuracy corrupted",
"Aim rebooting",
"Your aim stunned",
"Crosshair burnt out",
"Aim contemplating life",
"Bro invented new miss angles",
"Accuracy on strike again",
"Aim refusing input",
"Your aim under maintenance",
"Crosshair crashed",
"Aim clocked out",
"Bro forgot to aim",
"Accuracy sneezing",
"Aim trembling",
"Your aim lost in translation",
"Crosshair lagging spiritually",
"Aim searching for peace",
"Bro wandered off mentally",
"Accuracy confused deeply",
"Aim stuck in a loop",
"Your aim smacking air",
"Crosshair running late",
"Aim malfunction magical edition",
"Bro missed intentionally (I hope)",
"Accuracy unavailable",
"Aim rendering issues",
"Your aim practically invisible",
"Crosshair glitching stylishly",
"Aim tripped",
"Bro’s aim self-destructed",
"Accuracy freezing up",
"Aim vibing instead of aiming",
"Your aim rebooting emotions",
"Crosshair politely declining",
"Aim fainted",
"Bro confusing enemies with the map",
"Accuracy fell off",
"Aim snoring",
"Your aim mentally absent",
"Crosshair sidetracked",
"Aim unfocused completely",
"Bro delivering warning shots",
"Accuracy in nap mode",
"Aim drifting like a balloon",
"Your aim hopelessly optimistic"
}

ChatVersion = TextChatService.ChatVersion
ChatEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
TargetTextChannel = TextChatService.ChatInputBarConfiguration.TargetTextChannel

function sendRandomToxic()
    message = Toxic[math.random(#Toxic)]
    print("Sending toxic: " .. message)
    
    if ChatVersion == Enum.ChatVersion.LegacyChatService and ChatEvent then
        ChatEvent.SayMessageRequest:FireServer(message, "All")
    elseif TargetTextChannel then
        TargetTextChannel:SendAsync(message)
    else
        print("Chat system not available.")
    end
end

local toxicConnection
isToxicChatting = false
function toggleToxicChat(enabled)
    _G.toxicEnabled = enabled
    
    if _G.toxicEnabled then
        if not toxicConnection then
            toxicConnection = RunService.Heartbeat:Connect(function()
                if isToxicChatting == false then
                    isToxicChatting = true
                    sendRandomToxic()
                    task.wait(3) -- Wait for 3 seconds before sending another message
                    isToxicChatting = false
                end
            end)
        end
    else
        if toxicConnection then
            toxicConnection:Disconnect()
            toxicConnection = nil
        end
    end
end

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Toxic chatter',
    Default = false,
    Tooltip = 'Sends toxic chats',
    Callback = toggleToxicChat
}):AddKeyPicker('Toxicchat', { Default = 'none', SyncToggleState = true, Mode = 'Toggle', Text = 'toxic' })

Promo = {
    "NotHub On Top🍵",
    "NotHub so clean yall still losing to it..🍵",
    "Must be rough playing without NotHub 💔🍵",
    "cant win a hvh? maybe try /matchahvh🍵",
    "🍵if u wanna stop losing hop in /matchahvh",
    "🍵bro if u cant win just get Matcha . cc",
    "how to win a hvh? step 1: get Matcha . cc🍵",
    "gg/Vsnz2wfjP5🍵",
    "NotHub users eat, yall starve 🍵",
    "No NotHub? no wins. simple. ??",
    "You crying in chat while NotHub cooking 🍵",
    "If missing shots was a job you’d be CEO 🍵",
    "NotHub got me winning, you got excuses 🍵",
    "Keep blaming lag, we know it's skill 🍵",
    "NotHub smooth, yall movement shaky 🍵",
    "NotHub on top, your aim on vacation 🍵",
    "You fighting air while NotHub hitting heads 🍵",
    "NotHub turning bots into bosses 🍵",
    "You need NotHub more than WiFi 🍵",
    "NotHub users glide, you slide 🍵",
    "Your gameplay crying, NotHub thriving 🍵",
    "You chasing clout, NotHub chasing wins 🍵",
    "NotHub got the boost, you got excuses 🍵",
    "You pressing buttons, we pressing victory 🍵",
    "NotHub users pop off, you pop up dead 🍵",
    "Skill issue? NotHub don’t judge 🍵",
    "NotHub keeps you calm, you keep panic 🍵",
    "No NotHub? say hello to respawn 🍵",
    "NotHub players flex, you stumble 🍵",
    "Your aim wandering, NotHub laser-focused 🍵",
    "NotHub got bars, you got tears 🍵",
    "Try as you might, NotHub too strong 🍵",
    "NotHub users cook, you still reading the recipe 🍵",
    "Your shots missing, NotHub hitting 🍵",
    "NotHub above, you below 🍵",
    "We slide, you collide 🍵",
    "NotHub users shine, your screen blurry 🍵",
    "NotHub clean, your game messy 🍵",
    "You talking big, we acting bigger 🍵",
    "NotHub got moves, you got panic 🍵",
    "Without NotHub? GG for you 🍵",
    "NotHub making legends, you making mistakes 🍵",
    "You flinch, we feast 🍵",
    "NotHub players rise, you respawn 🍵",
    "We dominate, you imitate 🍵",
    "NotHub got juice, you got crumbs 🍵",
    "NotHub never sleeps, you lag 🍵",
    "You chasing shadows, we chasing wins 🍵",
    "NotHub users glide, your feet stuck 🍵",
    "No NotHub? keep dreaming 🍵",
    "NotHub built for pros, you built for bots 🍵",
    "Your keyboard crying, NotHub laughing 🍵",
    "NotHub users on top, you hitting ground 🍵",
    "You tap, we snap 🍵",
    "NotHub got focus, you got panic attacks 🍵",
    "Keep trying, we keep winning 🍵",
    "NotHub moving smooth, you jittery 🍵",
    "NotHub users dominate, you spectate 🍵",
    "You losing fast, NotHub blasting 🍵",
    "NotHub got style, your shots messy 🍵",
    "You lag, we swag 🍵",
    "NotHub players clean, you dirty 🍵",
    "Your moves weak, NotHub strong 🍵",
    "NotHub users laugh, you cry 🍵",
    "Keep missing, NotHub keep scoring 🍵",
    "You freeze, we feast 🍵",
    "NotHub got energy, you tired 🍵",
    "NotHub turning noobs into legends 🍵",
    "You flailing, we flying 🍵",
    "NotHub smooth operator, you panic button 🍵",
    "No NotHub? surrender early 🍵",
    "NotHub got tactics, you got chaos 🍵",
    "You panic, we execute 🍵",
    "NotHub users calm, you screaming 🍵",
    "NotHub gliding, you stumbling 🍵",
    "You pray, we slay 🍵",
    "NotHub on top, your score low 🍵",
    "Your shots weak, NotHub strong 🍵",
    "NotHub always moving, you stuck 🍵",
    "You spinning wheels, NotHub winning 🍵",
    "NotHub users cooking, you freezing 🍵",
    "You panic, we dominate 🍵",
    "NotHub turning losses into wins 🍵",
    "You chasing shadows, we chasing glory 🍵",
    "NotHub got juice, your hands dry 🍵",
    "You flinch, we feast 🍵",
    "NotHub players glide, you stumble 🍵",
    "Your aim shaky, NotHub steady 🍵",
    "NotHub above, you below 🍵",
    "You miss shots, we hit 🍵",
    "NotHub users rise, you respawn 🍵",
    "Your tactics weak, NotHub strong 🍵",
    "NotHub got bars, you got lag 🍵",
    "You panic, we score 🍵",
    "NotHub on top, you bottom 🍵",
    "You crying, NotHub laughing 🍵",
    "NotHub got power, you weak 🍵",
    "You tap, we dominate 🍵",
    "NotHub shining, you hiding 🍵",
    "Your game messy, NotHub clean 🍵",
    "You flail, we flex 🍵",
    "NotHub cooking, you freezing 🍵",
    "NotHub users glide, you slide 🍵",
    "Your aim wandering, NotHub laser 🍵",
    "You panic, we feast 🍵",
    "NotHub got style, your shots weak 🍵",
    "You losing, NotHub winning 🍵",
    "NotHub moving smooth, you jittery 🍵",
    "No NotHub? just GG 🍵",
    "NotHub built for winners, you built for bots 🍵",
    "Your keyboard crying, NotHub laughing 🍵",
    "You spin, we glide 🍵",
    "NotHub users on top, you bottom 🍵",
    "You press panic, we press victory 🍵",
    "NotHub got juice, you dry 🍵",
    "You flinch, we feast 🍵",
    "NotHub players dominate, you spectate 🍵",
    "You lag, we swag 🍵",
    "NotHub got tactics, you chaos 🍵",
    "No NotHub? just pray 🍵",
    "NotHub smooth operator, you panic button 🍵",
    "Your game weak, NotHub strong 🍵",
    "NotHub users clean, you messy 🍵",
    "You tap, we snap 🍵",
    "NotHub on top, your score low 🍵",
    "Your shots miss, NotHub hits 🍵",
    "NotHub always moving, you stuck 🍵",
    "You spinning wheels, we winning 🍵",
    "NotHub cooking, you freezing 🍵",
    "You panic, we dominate 🍵",
    "NotHub turning noobs into legends 🍵",
    "You chasing shadows, we chasing glory 🍵",
    "NotHub got juice, your hands dry 🍵",
    "You flinch, we feast 🍵",
    "NotHub players glide, you stumble 🍵"
}
local ChatVersion = TextChatService.ChatVersion
local ChatEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
local TargetTextChannel = TextChatService.ChatInputBarConfiguration.TargetTextChannel

local function sendRandomPromo()
    local message = Promo[math.random(#Promo)]
    print("Sending Kill Say Promo: " .. message)
    if ChatVersion == Enum.ChatVersion.LegacyChatService and ChatEvent then
        ChatEvent.SayMessageRequest:FireServer(message, "All")
    elseif TargetTextChannel then
        TargetTextChannel:SendAsync(message)
    else
        print("Chat system not available.")
    end
end


ChatVersion = TextChatService.ChatVersion
ChatEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
TargetTextChannel = TextChatService.ChatInputBarConfiguration.TargetTextChannel

function sendRandomPromo()
    message = Promo[math.random(#Promo)]
    print("Sending Promo: " .. message)
    
    if ChatVersion == Enum.ChatVersion.LegacyChatService and ChatEvent then
        ChatEvent.SayMessageRequest:FireServer(message, "All")
    elseif TargetTextChannel then
        TargetTextChannel:SendAsync(message)
    else
        print("Chat system not available.")
    end
end

local PromoConnection
isPromoChatting = false
function togglePromoChat(enabled)
    _G.PromoEnabled = enabled
    
    if _G.PromoEnabled then
        if not PromoConnection then
            PromoConnection = RunService.Heartbeat:Connect(function()
                if isPromoChatting == false then
                    isPromoChatting = true
                    sendRandomPromo()
                    task.wait(5) -- Wait for 3 seconds before sending another message
                    isPromoChatting = false
                end
            end)
        end
    else
        if PromoConnection then
            PromoConnection:Disconnect()
            PromoConnection = nil
        end
    end
end

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Promo chatter',
    Default = false,
    Tooltip = 'Sends Promo chats',
    Callback = togglePromoChat
}):AddKeyPicker('Promochat', { Default = 'none', SyncToggleState = true, Mode = 'Toggle', Text = 'promochat' })
end)()
local TrollingBox = Tabs.Misc:AddLeftGroupbox('Trolling')

getgenv().jerkOffEnabled = false
TrollingBox:AddToggle('JerkOff', {
    Text = 'Jerk Off',
    Default = false,
    Callback = function(v)
        getgenv().jerkOffEnabled = v
        if v then
            local speaker = game.Players.LocalPlayer
            local humanoid = speaker.Character and speaker.Character:FindFirstChildOfClass("Humanoid")
            local backpack = speaker:FindFirstChild("Backpack")
            if not humanoid or not backpack then
                Library:Notify("Character or backpack not found!", 5)
                return
            end

            local function createJerkOffTool()
                local tool = Instance.new("Tool")
                tool.Name = "Jerk Off"
                tool.ToolTip = "in the stripped club. straight up \"jorking it\" . and by \"it\" , haha, well. let's justr say. My peanits."
                tool.RequiresHandle = false
                tool.Parent = backpack

                local jorkin = false
                local track = nil

                local function stopTomfoolery()
                    jorkin = false
                    if track then
                        track:Stop()
                        track = nil
                    end
                end

                tool.Equipped:Connect(function()
                    jorkin = true
                end)
                tool.Unequipped:Connect(stopTomfoolery)
                humanoid.Died:Connect(stopTomfoolery)

                task.spawn(function()
                    while task.wait() do
                        if not jorkin then continue end
                        local isR15 = humanoid.RigType == Enum.HumanoidRigType.R15
                        if not track then
                            local anim = Instance.new("Animation")
                            anim.AnimationId = isR15 and "rbxassetid://698251653" or "rbxassetid://72042024"
                            track = humanoid:LoadAnimation(anim)
                        end
                        track:Play()
                        track:AdjustSpeed(isR15 and 0.7 or 0.65)
                        track.TimePosition = 0.6
                        task.wait(0.1)
                        while track and track.TimePosition < (isR15 and 0.7 or 0.65) do
                            task.wait(0.1)
                        end
                        if track then
                            track:Stop()
                            track = nil
                        end
                    end
                end)
            end

            createJerkOffTool()
        else
            local speaker = game.Players.LocalPlayer
            local backpack = speaker:FindFirstChild("Backpack")
            local character = speaker.Character
            if backpack then
                local toolInBackpack = backpack:FindFirstChild("Jerk Off")
                if toolInBackpack then
                    toolInBackpack:Destroy()
                end
            end
            if character then
                local toolInCharacter = character:FindFirstChild("Jerk Off")
                if toolInCharacter then
                    toolInCharacter:Destroy()
                end
            end
        end
    end
})


getgenv().Test = false
getgenv().SoundId = "6899466638"
getgenv().ToolEnabled = false

getgenv().CreateTool = function()
    getgenv().Tool = Instance.new("Tool")
    getgenv().Tool.RequiresHandle = false
    getgenv().Tool.Name = "[Kick]"
    getgenv().Tool.TextureId = "rbxassetid://483225199"
    getgenv().Animation = Instance.new("Animation")
    getgenv().Animation.AnimationId = "rbxassetid://2788306916"
    getgenv().Tool.Activated:Connect(function()
        getgenv().Test = true
        getgenv().Player = game.Players.LocalPlayer
        getgenv().Character = getgenv().Player.Character or getgenv().Player.CharacterAdded:Wait()
        getgenv().Humanoid = getgenv().Character:FindFirstChild("Humanoid")
        if getgenv().Humanoid then
            getgenv().AnimationTrack = getgenv().Humanoid:LoadAnimation(getgenv().Animation)
            getgenv().AnimationTrack:AdjustSpeed(3.4)
            getgenv().AnimationTrack:Play()
        end
        task.wait(0.6)
        getgenv().Boombox = game.Players.LocalPlayer.Backpack:FindFirstChild("[Boombox]")
        if getgenv().Boombox then
            getgenv().Boombox.Parent = game.Players.LocalPlayer.Character
            MainEvent:FireServer("Boombox", tonumber(getgenv().SoundId))
            getgenv().Boombox.RequiresHandle = false
            getgenv().Boombox.Parent = game.Players.LocalPlayer.Backpack
            task.wait(1)
            MainEvent:FireServer("BoomboxStop")
        else
            getgenv().Sound = Instance.new("Sound", workspace)
            getgenv().Sound.SoundId = "rbxassetid://" .. getgenv().SoundId
            getgenv().Sound:Play()
            task.wait(1)
            getgenv().Sound:Stop()
        end
        wait(1.4)
        getgenv().Test = false
    end)
    getgenv().Tool.Parent = game.Players.LocalPlayer:WaitForChild("Backpack")
end

getgenv().RemoveTool = function()
    getgenv().Player = game.Players.LocalPlayer
    getgenv().Tool = getgenv().Player.Backpack:FindFirstChild("[Kick]") or getgenv().Player.Character:FindFirstChild("[Kick]")
    if getgenv().Tool then getgenv().Tool:Destroy() end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if getgenv().Test then
        getgenv().Character = game.Players.LocalPlayer.Character
        if not getgenv().Character then return end
        getgenv().HumanoidRootPart = getgenv().Character:FindFirstChild("HumanoidRootPart")
        if not getgenv().HumanoidRootPart then return end
        getgenv().originalVelocity = getgenv().HumanoidRootPart.Velocity
        getgenv().HumanoidRootPart.Velocity = Vector3.new(getgenv().HumanoidRootPart.CFrame.LookVector.X * 800, 800, getgenv().HumanoidRootPart.CFrame.LookVector.Z * 800)
        game:GetService("RunService").RenderStepped:Wait()
        getgenv().HumanoidRootPart.Velocity = getgenv().originalVelocity
    end
end)
TrollingBox:AddToggle('Pqnd4Kick', {
    Text = 'Pqnd4 Kick Tool',
    Default = false,
    Callback = function(v)
        getgenv().ToolEnabled = v
        if v then getgenv().CreateTool() else getgenv().RemoveTool() end
    end
})

local AnimPackBox = Tabs.Misc:AddLeftGroupbox('Animation Packs')
local hasLoadedPacks = false

AnimPackBox:AddButton({
    Text = 'Load Animation Packs',
    Func = function()
        if hasLoadedPacks then
            return
        end
        hasLoadedPacks = true
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Kazamatcha/matcha.tea/refs/heads/main/animationspacks"))()
    end
})
local MiscBox = Tabs.Misc:AddRightGroupbox('Misc')

local antiStompActive = false

local lastDeathPosition = nil
RunService.Heartbeat:Connect(function()
    local chr = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hum = chr:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    local bodyEffects = chr:FindFirstChild("BodyEffects")
    if not bodyEffects then return end
    local koValue = bodyEffects:FindFirstChild("K.O")
    -------------------------
    -- ANTI STOMP XỬ LÝ --
    -------------------------
    if antiStompActive then
        if hum.Health <= 5 or (koValue and koValue.Value) then
            -- Bỏ tool nếu đang cầm
            local tool = chr:FindFirstChildOfClass("Tool")
            if tool then
                tool.Parent = LocalPlayer.Backpack
            end
            -- Xóa body parts
            for _, v in pairs(chr:GetChildren()) do
                if v:IsA("MeshPart") or v:IsA("Part") then
                    v:Destroy()
                end
            end
            -- Xóa phụ kiện
            for _, v in pairs(chr:GetChildren()) do
                if v:IsA("Accessory") then
                    if v:FindFirstChild("Handle") then
                        v.Handle:Destroy()
                    end
                end
            end
        end
    end

end)


MiscBox:AddToggle('AntiStomp', {
    Text = 'Anti Stomp',
    Default = false,
    Callback = function(v)
        antiStompActive = v
    end
})
local antiBagConnection
MiscBox:AddToggle('AntiBag', {
    Text = 'Anti Bag',
    Default = false,
    Callback = function(Value)
        if Value then
            antiBagConnection = RunService.Heartbeat:Connect(function()
                if localPlayer.Character:FindFirstChild('Christmas_Sock') then
                    localPlayer.Character:FindFirstChild('Christmas_Sock'):Destroy() 
                end
            end)
        else
            if antiBagConnection then
                antiBagConnection:Disconnect()
                antiBagConnection = nil
            end
        end
    end
})

local antiGrabConnection
MiscBox:AddToggle('AntiGrab', {
    Text = 'Anti Grab',
    Default = false,
    Callback = function(Value)
        if Value then
            antiGrabConnection = RunService.Heartbeat:Connect(function()
                local GC = localPlayer.Character:FindFirstChild("GRABBING_CONSTRAINT")
                if GC then
                    GC:Destroy()
                    wait(0.04)
                    local humanoid = localPlayer.Character:FindFirstChildWhichIsA('Humanoid')
                    if humanoid then
                        humanoid.Sit = true
                    end
                end
            end)
        else
            if antiGrabConnection then
                antiGrabConnection:Disconnect()
                antiGrabConnection = nil
            end
        end
    end
})
if isDaHood then
    getgenv().CASH_AURA_ENABLED = false
    getgenv().CASH_AURA_RANGE = 17
    getgenv().COOLDOWN = 0.2

    local function GetCash()
        local cash = {}
        local drop = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Drop")
        if not drop then return cash end
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not root then return cash end

        for _, v in drop:GetChildren() do
            if v.Name == "MoneyDrop" then
                local pos = v:GetAttribute("OriginalPos") or v.Position
                if (pos - root.Position).Magnitude <= getgenv().CASH_AURA_RANGE then
                    table.insert(cash, v)
                end
            end
        end
        return cash
    end

    local function CashAuraLoop()
        while getgenv().CASH_AURA_ENABLED do
            for _, money in GetCash() do
                local cd = money:FindFirstChildOfClass("ClickDetector")
                if cd then fireclickdetector(cd) end
            end
            task.wait(getgenv().COOLDOWN)
        end
    end

    MiscBox:AddToggle('CashAura', {
        Text = 'Cash Aura',
        Default = false,
        Callback = function(v)
            getgenv().CASH_AURA_ENABLED = v
            if v then task.spawn(CashAuraLoop) end
        end
    })
    MiscBox:AddSlider('CashAuraRange', {
        Text = 'Cash Aura Range',
        Min = 10, Max = 50, Default = 17, Rounding = 1,
        Callback = function(v) getgenv().CASH_AURA_RANGE = v end
    })

    MiscBox:AddSlider('CashAuraCD', {
        Text = 'Cash Aura Cooldown',
        Min = 0.1, Max = 1, Default = 0.2, Rounding = 2,
        Callback = function(v) getgenv().COOLDOWN = v end
    })
end

local autoReloadEnabled = false
local silentReloadEnabled = false
local removeShootAnimEnabled = false

RunService.Heartbeat:Connect(function()
    if not autoReloadEnabled then return end
    local tool = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if tool and tool:FindFirstChild("Ammo") and tool.Ammo.Value <= 0 then
        pcall(function()
            MainEvent:FireServer("Reload", tool)
        end)
    end
end)
MiscBox:AddToggle('AutoReloadToggle', {
    Text = 'Auto Reload',
    Default = false,
    Callback = function(v)
        autoReloadEnabled = v
        Library:Notify(v and "Auto Reload: ON" or "Auto Reload: OFF", 2)
    end
})
-- ====================== RPG & GRENADE DETECTION (DA HOOD ONLY) ======================
if isDaHood then
    getgenv().AntiRPGDesyncEnabled = false
    getgenv().GrenadeDetectionEnabled = false
    getgenv().AntiRPGDesyncLoop = nil

    local function StartDetection()
        if getgenv().AntiRPGDesyncLoop then return end
        getgenv().AntiRPGDesyncLoop = game:GetService("RunService").PostSimulation:Connect(function()
            local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
            if not hrp or not hum then return end

            local rpg = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Model") and workspace.Ignored.Model:FindFirstChild("Launcher")
            local grenade = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Handle")

            local threat = (getgenv().AntiRPGDesyncEnabled and rpg) or (getgenv().GrenadeDetectionEnabled and grenade and (grenade.Position - hrp.Position).Magnitude < 16)
            if threat then
                local offset = Vector3.new(math.random(-100,100), math.random(50,150), math.random(-100,100))
                hum.CameraOffset = -offset
                local old = hrp.CFrame
                hrp.CFrame = CFrame.new(hrp.Position + offset)
                task.wait()
                hrp.CFrame = old
            end
        end)
    end

    local function StopDetection()
        if getgenv().AntiRPGDesyncLoop then
            getgenv().AntiRPGDesyncLoop:Disconnect()
            getgenv().AntiRPGDesyncLoop = nil
        end
    end

    MiscBox:AddToggle('RPGDetect', {
        Text = 'RPG Detection',
        Default = false,
        Callback = function(v)
            getgenv().AntiRPGDesyncEnabled = v
            if v or getgenv().GrenadeDetectionEnabled then StartDetection() else StopDetection() end
        end
    })

    MiscBox:AddToggle('GrenadeDetect', {
        Text = 'Grenade Detection',
        Default = false,
        Callback = function(v)
            getgenv().GrenadeDetectionEnabled = v
            if v or getgenv().AntiRPGDesyncEnabled then StartDetection() else StopDetection() end
        end
    })
end

MiscBox:AddToggle('ChatSpy', {
    Text = 'Chat Spy',
    Default = true,
    Callback = function(v)
        ChatEnabled = v
        if chatWindow then chatWindow.Enabled = v end
    end
})
local maxzoom = game.Players.LocalPlayer.CameraMaxZoomDistance
MiscBox:AddToggle('InfZoom', {
    Text = 'Infinite Zoom',
    Default = false,
    Callback = function(v)
        if v then
            game.Players.LocalPlayer.CameraMaxZoomDistance = math.huge
        else
            game.Players.LocalPlayer.CameraMaxZoomDistance = maxzoom 
        end
    end
})
local ngu = MiscBox:AddButton({
    Text = 'Force Reset',
    Func = function()
        local hum = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum then hum.Health = 0 end
    end
})
	
-- 3. Unjail (Da Hood only)
if isDaHood then
    ngu:AddButton({
	    Text = 'Redeem All Codes',
	    Func = function()
	        local codes = {"ADMINABUSE","HALLOWEEN25"}
	        local mainEvent = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent")
	        if not mainEvent then Library:Notify("MainEvent not found!", 5) return end
	
	        for _, code in ipairs(codes) do
	            mainEvent:FireServer("EnterPromoCode", code)
	            Library:Notify("Redeeming: " .. code, 4)
	            task.wait(4.2)
	        end
	        Library:Notify("All codes redeemed!", 6)
	    end
	})

    MiscBox:AddButton({
        Text = 'Unjail (125$)',
        Func = function()
            local plr = game.Players.LocalPlayer
            local currency = plr:FindFirstChild("DataFolder") and plr.DataFolder:FindFirstChild("Currency")
            if not currency or currency.Value < 125 then
                Library:Notify("Not enough cash! (Need 125$)", 5)
                return
            end

            local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            hrp.CFrame = CFrame.new(-270.94, 20.327, -242.38)
            task.wait(0.5)

            local keyShop = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Shop") and workspace.Ignored.Shop:FindFirstChild("[Key] - $125")
            if keyShop and keyShop:FindFirstChild("ClickDetector") then
                fireclickdetector(keyShop.ClickDetector)
                task.wait(0.2)
                fireclickdetector(keyShop.ClickDetector)
                fireclickdetector(keyShop.ClickDetector)
            end

            repeat task.wait() until plr.Backpack:FindFirstChild("[Key]") or plr.Character:FindFirstChild("[Key]")

            local key = plr.Backpack:FindFirstChild("[Key]") or plr.Character:FindFirstChild("[Key]")
            if key then
                local hum = plr.Character:FindFirstChildOfClass("Humanoid")
                if hum then hum:EquipTool(key) end
                task.wait(0.3)
                hrp.CFrame = CFrame.new(-485.668, 23.631, -285.169) -- Bank
                task.wait(0.5)
                key:Activate()
                Library:Notify("Unjailed successfully!", 5)
            end
        end
    })
else
    print("Không phải Da Hood → Bỏ qua Unjail")
end
if isDaHood then
    local DetectionBox = Tabs.Misc:AddRightGroupbox('Detection')

    -- Cấu hình
    local antiModEnabled = false
    local checkModFriendsEnabled = false
    local groupCheckEnabled = false
    local antiModMethod = "Notify" -- Notify / Kick

    -- Danh sách Moderator (UserId)
    local modList = {
        163721789, 15427717, 201454243, 822999, 63794379, 17260230, 28357488, 93101606,
        8195210, 89473551, 16917269, 85989579, 1553950697, 476537893, 155627580,
        31163456, 7200829, 25717070, 16138978, 60660789, 1161411094, 9125623,
        11319153, 34758833, 194109750, 35616559, 1257271138, 28885841, 23558830,
        4255947062, 29242182, 2395613299, 3314981799, 3390225662, 2459178,
        2846299656, 2967502742, 7001683347, 7312775547, 328566086, 170526279,
        99356639, 352087139, 6074834798, 2212830051, 3944434729, 5136267958,
        84570351, 542488819, 1830168970, 3950637598, 1962396833
    }

    -- Group ID cần kiểm tra (Da Hood Mod Group, Staff Group, v.v.)
    local groupIDs = {10604500, 17215700}


    -- === Hàm phát hiện Moderator ===
    local function detectMods()
        while antiModEnabled do
            task.wait(1.5)
            for _, player in ipairs(Players:GetPlayers()) do
                if player == LocalPlayer then continue end

                -- Kiểm tra UserId trong danh sách đen
                if table.find(modList, player.UserId) then
                    local msg = "MODERATOR DETECTED: " .. player.DisplayName .. " (@" .. player.Name .. ")"
                    if antiModMethod == "Notify" then
                        Library:Notify(msg, 5)
                    else
                        LocalPlayer:Kick("MOD DETECTED: " .. player.DisplayName)
                    end
                end

                -- Kiểm tra Group + Role (nếu bật)
                if groupCheckEnabled then
                    for _, groupId in ipairs(groupIDs) do
                        local success, inGroup = pcall(player.IsInGroup, player, groupId)
                        if success and inGroup then
                            local role = "Unknown"
                            pcall(function() role = player:GetRoleInGroup(groupId) end)
                            local msg = "[" .. role .. "] JOINED: " .. player.DisplayName .. " (@" .. player.Name .. ")"
                            if antiModMethod == "Notify" then
                                Library:Notify(msg, 5)
                            else
                                LocalPlayer:Kick("STAFF DETECTED: " .. player.DisplayName)
                            end
                        end
                    end
                end
            end
        end
    end

    -- === Kiểm tra bạn bè với Mod ===
    local function checkFriendsWithMods()
        while checkModFriendsEnabled do
            task.wait(8) -- Không cần check quá nhanh
            for _, player in ipairs(Players:GetPlayers()) do
                if player == LocalPlayer then continue end
                pcall(function()
                    local friends = player:GetFriendsAsync()
                    local page = friends:GetCurrentPage()
                    for _, friend in ipairs(page) do
                        if table.find(modList, friend.Id) then
                            Library:Notify(player.DisplayName .. " is friends with a Moderator!", 6)
                            break
                        end
                    end
                end)
            end
        end
    end

    -- === UI ===
    local AntiModToggle = DetectionBox:AddToggle('AntiMod', {
        Text = 'Anti Mod Detection',
        Default = false,
        Callback = function(v)
            antiModEnabled = v
            Library:Notify(v and "Anti-Mod: ON" or "Anti-Mod: OFF", 3)
            if v then task.spawn(detectMods) end
        end
    })

    local DepBox = DetectionBox:AddDependencyBox()
    DepBox:SetupDependencies({{Toggles.AntiMod, true}})

    DepBox:AddDropdown('AntiModMethod', {
        Values = {"Notify", "Kick"},
        Default = "Notify",
        Multi = false,
        Text = 'Action Method',
        Callback = function(v)
            antiModMethod = v
            Library:Notify("Anti-Mod Action → " .. v, 3)
        end
    })

    DepBox:AddToggle('CheckModFriends', {
        Text = 'Check Mod Friends',
        Default = false,
        Tooltip = 'Warns if someone is friends with a Moderator',
        Callback = function(v)
            checkModFriendsEnabled = v
            Library:Notify(v and "Mod Friends Check: ON" or "Mod Friends Check: OFF", 3)
            if v then task.spawn(checkFriendsWithMods) end
        end
    })

    DepBox:AddToggle('GroupCheck', {
        Text = 'Staff Group Check',
        Default = false,
        Tooltip = 'Detects players in restricted Da Hood staff groups',
        Callback = function(v)
            groupCheckEnabled = v
            Library:Notify(v and "Staff Group Check: ON" or "Staff Group Check: OFF", 3)
            if v and antiModEnabled then task.spawn(detectMods) end
        end
    })

else
    print("Không phải Da Hood → Bỏ qua Anti-Mod Detection")
end
--[[local Workspace, RunService, Players, CoreGui, Lighting = cloneref(game:GetService("Workspace")), cloneref(game:GetService("RunService")), cloneref(game:GetService("Players")), game:GetService("CoreGui"), cloneref(game:GetService("Lighting"))

local ESP = {
    Enabled = false,
    TeamCheck = true,
    UseBoundingBox = false,
    MaxDistance = 1000,
    FontSize = 13,
    FadeOut = {
        OnDistance = false,
        OnDeath = false,
        OnLeave = false,
    },
    Options = { 
        Teamcheck = false, TeamcheckRGB = Color3.fromRGB(0, 255, 0),
        Friendcheck = false, FriendcheckRGB = Color3.fromRGB(0, 255, 0),
        Highlight = false, HighlightRGB = Color3.fromRGB(255, 0, 0),
    },

    Drawing = {
        Chams = {
            Enabled  = false,
            Thermal = false,
            FillRGB = Color3.fromRGB(255, 255, 255),
            Fill_Transparency = 100,
            HardFill = false,
            OutlineRGB = Color3.fromRGB(255, 255, 255),
            Outline_Transparency = 100,
            VisibleCheck = false,
        },
        
        Names = {
            Enabled = false,
            RGB = Color3.fromRGB(255, 255, 255),
        },
        Flags = {
            Enabled = false,
        },
        Distances = {
            Enabled = false, 
            Position = "Text",
            RGB = Color3.fromRGB(255, 255, 255),
        },
        Weapons = {
            Enabled = false, WeaponTextRGB = Color3.fromRGB(255, 255, 255),
            Outlined = false,
            Gradient = false,
            GradientRGB1 = Color3.fromRGB(255, 255, 255), GradientRGB2 = Color3.fromRGB(255, 255, 255),
        },
        Healthbar = {
            Enabled = false,  
            HealthText = false, Lerp = false, HealthTextRGB = Color3.fromRGB(119, 120, 255),
            Width = 2.5,
            Gradient = true, GradientRGB1 = Color3.fromRGB(200, 0, 0), GradientRGB2 = Color3.fromRGB(220, 220, 220), GradientRGB3 = Color3.fromRGB(255, 255, 255), 
        },
        Boxes = {
            Animate = false,
            RotationSpeed = 300,
            ImageFill,
            Gradient = true, GradientRGB1 = Color3.fromRGB(223, 223, 233), GradientRGB2 = Color3.fromRGB(0, 0, 0), 
            GradientFill = true, GradientFillRGB1 = Color3.fromRGB(223, 233, 233), GradientFillRGB2 = Color3.fromRGB(0, 0, 0), 
            Filled = {
                Enabled = false,
                Transparency = 0.75,
                RGB = Color3.fromRGB(0, 0, 0),
            },
            Full = {
                Enabled = false,
                RGB = Color3.fromRGB(255, 255, 255),
            },
            Corner = {
                Enabled = false,
                RGB = Color3.fromRGB(255, 255, 255),
            },
        };
    };
    Connections = {
        RunService = RunService;
    };
    Fonts = {};
}


local Euphoria = ESP.Connections;
local lplayer = Players.LocalPlayer;
local camera = game.Workspace.CurrentCamera;
local Cam = Workspace.CurrentCamera;
local RotationAngle, Tick = -45, tick();

local Weapon_Icons = {
    ["Wooden Bow"] = "http://www.roblox.com/asset/?id=17677465400",
    ["Crossbow"] = "http://www.roblox.com/asset/?id=17677473017",
    ["Salvaged SMG"] = "http://www.roblox.com/asset/?id=17677463033",
    ["Salvaged AK47"] = "http://www.roblox.com/asset/?id=17677455113",
    ["Salvaged AK74u"] = "http://www.roblox.com/asset/?id=17677442346",
    ["Salvaged M14"] = "http://www.roblox.com/asset/?id=17677444642",
    ["Salvaged Python"] = "http://www.roblox.com/asset/?id=17677451737",
    ["Military PKM"] = "http://www.roblox.com/asset/?id=17677449448",
    ["Military M4A1"] = "http://www.roblox.com/asset/?id=17677479536",
    ["Bruno's M4A1"] = "http://www.roblox.com/asset/?id=17677471185",
    ["Military Barrett"] = "http://www.roblox.com/asset/?id=17677482998",
    ["Salvaged Skorpion"] = "http://www.roblox.com/asset/?id=17677459658",
    ["Salvaged Pump Action"] = "http://www.roblox.com/asset/?id=17677457186",
    ["Military AA12"] = "http://www.roblox.com/asset/?id=17677475227",
    ["Salvaged Break Action"] = "http://www.roblox.com/asset/?id=17677468751",
    ["Salvaged Pipe Rifle"] = "http://www.roblox.com/asset/?id=17677468751",
    ["Salvaged P250"] = "http://www.roblox.com/asset/?id=17677447257",
    ["Nail Gun"] = "http://www.roblox.com/asset/?id=17677484756"
};

local Functions = {}
do
    function Functions:Create(Class, Properties)
        local _Instance = typeof(Class) == 'string' and Instance.new(Class) or Class
        for Property, Value in pairs(Properties) do
            _Instance[Property] = Value
        end
        return _Instance;
    end

    function Functions:FadeOutOnDist(element, distance)
        local transparency = math.max(0.1, 1 - (distance / ESP.MaxDistance))
        if element:IsA("TextLabel") then
            element.TextTransparency = 1 - transparency
        elseif element:IsA("ImageLabel") then
            element.ImageTransparency = 1 - transparency
        elseif element:IsA("UIStroke") then
            element.Transparency = 1 - transparency
        elseif element:IsA("Frame") and (element == Healthbar or element == BehindHealthbar) then
            element.BackgroundTransparency = 1 - transparency
        elseif element:IsA("Frame") then
            element.BackgroundTransparency = 1 - transparency
        elseif element:IsA("Highlight") then
            element.FillTransparency = 1 - transparency
            element.OutlineTransparency = 1 - transparency
        end;
    end;  
end;

do 
    local ScreenGui = Functions:Create("ScreenGui", {
        Parent = CoreGui,
        Name = "ESPHolder",
    });

    local DupeCheck = function(plr)
        if ScreenGui:FindFirstChild(plr.Name) then
            ScreenGui[plr.Name]:Destroy()
        end
    end

function render_esp_for_player(plr)
ESP = ESP or {}
ESP.Objects = ESP.Objects or {}

        coroutine.wrap(DupeCheck)(plr) 
        local Name = Functions:Create("TextLabel", {Parent = ScreenGui, Position = UDim2.new(0.5, 0, 0, -11), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(255, 255, 255), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, TextStrokeColor3 = Color3.fromRGB(0, 0, 0), RichText = true})
        local Distance = Functions:Create("TextLabel", {Parent = ScreenGui, Position = UDim2.new(0.5, 0, 0, 11), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(255, 255, 255), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, TextStrokeColor3 = Color3.fromRGB(0, 0, 0), RichText = true})
        local Weapon = Functions:Create("TextLabel", {Parent = ScreenGui, Position = UDim2.new(0.5, 0, 0, 31), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(255, 255, 255), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, TextStrokeColor3 = Color3.fromRGB(0, 0, 0), RichText = true})
        local Box = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.fromRGB(0, 0, 0), BackgroundTransparency = 0.75, BorderSizePixel = 0})
      local BoxImage = Functions:Create("ImageLabel", {
    Parent = ScreenGui,
    BackgroundTransparency = 1,
    ImageTransparency = ESP.Drawing.Boxes.Filled.Transparency,
    Image = "rbxassetid://10670510697",
    ScaleType = Enum.ScaleType.Stretch,
    Visible = ESP.Drawing.Boxes.ImageFill
})

        local Gradient1 = Functions:Create("UIGradient", {Parent = Box, Enabled = ESP.Drawing.Boxes.GradientFill, Color = ColorSequence.new{ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientFillRGB1), ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientFillRGB2)}})
        local Outline = Functions:Create("UIStroke", {Parent = Box, Enabled = ESP.Drawing.Boxes.Gradient, Transparency = 0, Color = Color3.fromRGB(255, 255, 255), LineJoinMode = Enum.LineJoinMode.Miter})
        local Gradient2 = Functions:Create("UIGradient", {Parent = Outline, Enabled = ESP.Drawing.Boxes.Gradient, Color = ColorSequence.new{ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientRGB1), ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientRGB2)}})
        local Healthbar = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.fromRGB(255, 255, 255), BackgroundTransparency = 0})
        local BehindHealthbar = Functions:Create("Frame", {Parent = ScreenGui, ZIndex = -1, BackgroundColor3 = Color3.fromRGB(0, 0, 0), BackgroundTransparency = 0})
        local HealthbarGradient = Functions:Create("UIGradient", {Parent = Healthbar, Enabled = ESP.Drawing.Healthbar.Gradient, Rotation = -90, Color = ColorSequence.new{ColorSequenceKeypoint.new(0, ESP.Drawing.Healthbar.GradientRGB1), ColorSequenceKeypoint.new(0.5, ESP.Drawing.Healthbar.GradientRGB2), ColorSequenceKeypoint.new(1, ESP.Drawing.Healthbar.GradientRGB3)}})
        local HealthText = Functions:Create("TextLabel", {Parent = ScreenGui, Position = UDim2.new(0.5, 0, 0, 31), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(255, 255, 255), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, TextStrokeColor3 = Color3.fromRGB(0, 0, 0)})
        local Chams = Functions:Create("Highlight", {Parent = ScreenGui, FillTransparency = 1, OutlineTransparency = 0, OutlineColor = Color3.fromRGB(119, 120, 255), DepthMode = "AlwaysOnTop"})
        local WeaponIcon = Functions:Create("ImageLabel", {Parent = ScreenGui, BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(0, 0, 0), BorderSizePixel = 0, Size = UDim2.new(0, 40, 0, 40)})
        local Gradient3 = Functions:Create("UIGradient", {Parent = WeaponIcon, Rotation = -90, Enabled = ESP.Drawing.Weapons.Gradient, Color = ColorSequence.new{ColorSequenceKeypoint.new(0, ESP.Drawing.Weapons.GradientRGB1), ColorSequenceKeypoint.new(1, ESP.Drawing.Weapons.GradientRGB2)}})
        local LeftTop = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local LeftSide = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local RightTop = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local RightSide = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local BottomSide = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local BottomDown = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local BottomRightSide = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local BottomRightDown = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local Flag1 = Functions:Create("TextLabel", {Parent = ScreenGui, Position = UDim2.new(1, 0, 0, 0), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(255, 255, 255), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, TextStrokeColor3 = Color3.fromRGB(0, 0, 0)})
        local Flag2 = Functions:Create("TextLabel", {Parent = ScreenGui, Position = UDim2.new(1, 0, 0, 0), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(255, 255, 255), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, TextStrokeColor3 = Color3.fromRGB(0, 0, 0)})

        local Updater = function()
            local Connection;
            local function HideESP()
                Box.Visible = false;
                Name.Visible = false;
                Distance.Visible = false;
                Weapon.Visible = false;
                Healthbar.Visible = false;
                BehindHealthbar.Visible = false;
                HealthText.Visible = false;
                WeaponIcon.Visible = false;
                LeftTop.Visible = false;
                LeftSide.Visible = false;
                BottomSide.Visible = false;
                BottomDown.Visible = false;
                RightTop.Visible = false;
                RightSide.Visible = false;
                BottomRightSide.Visible = false;
                BottomRightDown.Visible = false;
                Flag1.Visible = false;
                BoxImage.Visible = false;
                Chams.Enabled = false;
                Flag2.Visible = false;
                if not plr then
                    ScreenGui:Destroy();
                    Connection:Disconnect();
                end
            end

            Connection = Euphoria.RunService.RenderStepped:Connect(function()
                if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local HRP = plr.Character.HumanoidRootPart
                    local Humanoid = plr.Character:WaitForChild("Humanoid");
                    local Pos, OnScreen = Cam:WorldToScreenPoint(HRP.Position)
                    local Dist = (Cam.CFrame.Position - HRP.Position).Magnitude / 3.5714285714

                    if OnScreen and Dist <= ESP.MaxDistance then
                local center_cframe, size = plr.Character:GetBoundingBox()
local corners = {}

for x = -0.5, 0.5, 1 do
    for y = -0.5, 0.5, 1 do
        for z = -0.5, 0.5, 1 do
            local offset = Vector3.new(x * size.X, y * size.Y, z * size.Z)
            local world_pos = center_cframe.Position + center_cframe:VectorToWorldSpace(offset)
            local screen_pos, on_screen = Cam:WorldToViewportPoint(world_pos)

            if on_screen then
                table.insert(corners, screen_pos)
            end
        end
    end
end

if #corners == 8 then
    local min_x, min_y = math.huge, math.huge
    local max_x, max_y = -math.huge, -math.huge

    for _, point in ipairs(corners) do
        min_x = math.min(min_x, point.X)
        max_x = math.max(max_x, point.X)
        min_y = math.min(min_y, point.Y)
        max_y = math.max(max_y, point.Y)
    end
    local w, h 
    if not ESP.UseBoundingBox then
                   local Size = HRP.Size.Y
                    local scale_factor = (Size * Cam.ViewportSize.Y) / (Pos.Z * 2)
                    w = (3 * scale_factor) * 0.7
                     h = (4.5 * scale_factor) * 0.9
    else
     w = max_x - min_x
     h = max_y - min_y
    end
                        if ESP.FadeOut.OnDistance then
                            Functions:FadeOutOnDist(Box, Dist)
                            Functions:FadeOutOnDist(Outline, Dist)
                            Functions:FadeOutOnDist(Name, Dist)
                            Functions:FadeOutOnDist(Distance, Dist)
                            Functions:FadeOutOnDist(Weapon, Dist)
                            Functions:FadeOutOnDist(Healthbar, Dist)
                            Functions:FadeOutOnDist(BehindHealthbar, Dist)
                            Functions:FadeOutOnDist(HealthText, Dist)
                            Functions:FadeOutOnDist(WeaponIcon, Dist)
                            Functions:FadeOutOnDist(LeftTop, Dist)
                            Functions:FadeOutOnDist(LeftSide, Dist)
                            Functions:FadeOutOnDist(BottomSide, Dist)
                            Functions:FadeOutOnDist(BottomDown, Dist)
                            Functions:FadeOutOnDist(RightTop, Dist)
                            Functions:FadeOutOnDist(RightSide, Dist)
                            Functions:FadeOutOnDist(BottomRightSide, Dist)
                            Functions:FadeOutOnDist(BottomRightDown, Dist)
                            Functions:FadeOutOnDist(Chams, Dist)
                            Functions:FadeOutOnDist(Flag1, Dist)
                            Functions:FadeOutOnDist(Flag2, Dist)
                        end

                        if ESP.TeamCheck and plr ~= lplayer and ((lplayer.Team ~= plr.Team and plr.Team) or (not lplayer.Team and not plr.Team)) and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Humanoid") then

                            do 
                                Chams.Adornee = plr.Character
                                Chams.Enabled = ESP.Drawing.Chams.Enabled
                                Chams.FillColor = ESP.Drawing.Chams.FillRGB
                                Chams.OutlineColor = ESP.Drawing.Chams.OutlineRGB
                                do 
                                    if ESP.Drawing.Chams.Thermal then
                                        local breathe_effect = math.atan(math.sin(tick() * 2)) * 2 / math.pi
                                        Chams.FillTransparency = ESP.Drawing.Chams.Fill_Transparency * breathe_effect * 0.01
                                        Chams.OutlineTransparency = ESP.Drawing.Chams.Outline_Transparency * breathe_effect * 0.01
                                    end
                                     if ESP.Drawing.Chams.HardFill then

                                        Chams.FillTransparency = 0
                                        Chams.OutlineTransparency = 0
                                    end
                                end

                                if ESP.Drawing.Chams.VisibleCheck then
                                    Chams.DepthMode = "Occluded"
                                else
                                    Chams.DepthMode = "AlwaysOnTop"
                                end

                            end;


                            do 
                                LeftTop.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                LeftTop.Position = UDim2.new(0, Pos.X - w / 2, 0, Pos.Y - h / 2)
                                LeftTop.Size = UDim2.new(0, w / 5, 0, 1)

                                LeftSide.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                LeftSide.Position = UDim2.new(0, Pos.X - w / 2, 0, Pos.Y - h / 2)
                                LeftSide.Size = UDim2.new(0, 1, 0, h / 5)

                                BottomSide.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                BottomSide.Position = UDim2.new(0, Pos.X - w / 2, 0, Pos.Y + h / 2)
                                BottomSide.Size = UDim2.new(0, 1, 0, h / 5)
                                BottomSide.AnchorPoint = Vector2.new(0, 5)

                                BottomDown.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                BottomDown.Position = UDim2.new(0, Pos.X - w / 2, 0, Pos.Y + h / 2)
                                BottomDown.Size = UDim2.new(0, w / 5, 0, 1)
                                BottomDown.AnchorPoint = Vector2.new(0, 1)

                                RightTop.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                RightTop.Position = UDim2.new(0, Pos.X + w / 2, 0, Pos.Y - h / 2)
                                RightTop.Size = UDim2.new(0, w / 5, 0, 1)
                                RightTop.AnchorPoint = Vector2.new(1, 0)

                                RightSide.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                RightSide.Position = UDim2.new(0, Pos.X + w / 2 - 1, 0, Pos.Y - h / 2)
                                RightSide.Size = UDim2.new(0, 1, 0, h / 5)
                                RightSide.AnchorPoint = Vector2.new(0, 0)

                                BottomRightSide.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                BottomRightSide.Position = UDim2.new(0, Pos.X + w / 2, 0, Pos.Y + h / 2)
                                BottomRightSide.Size = UDim2.new(0, 1, 0, h / 5)
                                BottomRightSide.AnchorPoint = Vector2.new(1, 1)

                                BottomRightDown.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                BottomRightDown.Position = UDim2.new(0, Pos.X + w / 2, 0, Pos.Y + h / 2)
                                BottomRightDown.Size = UDim2.new(0, w / 5, 0, 1)
                                BottomRightDown.AnchorPoint = Vector2.new(1, 1)                                                            
                            end
do 
    local screen_w = camera.ViewportSize.X
    local screen_h = camera.ViewportSize.Y

    local is_on_screen = Pos.X >= 0 and Pos.Y >= 0 and Pos.X <= screen_w and Pos.Y <= screen_h

    Box.Position = UDim2.new(0, Pos.X - w / 2, 0, Pos.Y - h / 2)
    Box.Size = UDim2.new(0, w, 0, h)
    Box.Visible = ESP.Drawing.Boxes.Full.Enabled and is_on_screen

    BoxImage.Position = Box.Position
    BoxImage.Size = Box.Size
    BoxImage.Visible = ESP.Drawing.Boxes.ImageFill and is_on_screen
    BoxImage.ImageTransparency = ESP.Drawing.Boxes.Filled.Transparency

    if ESP.Drawing.Boxes.Filled.Enabled then
        if ESP.Drawing.Boxes.ImageFill then
            Box.BackgroundTransparency = 1
        else
            Box.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            Box.BackgroundTransparency = ESP.Drawing.Boxes.GradientFill and ESP.Drawing.Boxes.Filled.Transparency or 1
        end
        Box.BorderSizePixel = 1
    else
        Box.BackgroundTransparency = 1
    end

    RotationAngle = RotationAngle + (tick() - Tick) * ESP.Drawing.Boxes.RotationSpeed * math.cos(math.pi / 4 * tick() - math.pi / 2)
    if ESP.Drawing.Boxes.Animate then
        Gradient1.Rotation = RotationAngle
        Gradient2.Rotation = RotationAngle
    else
        Gradient1.Rotation = -45
        Gradient2.Rotation = -45
    end
    Tick = tick()
end

                            do  
                                local health = Humanoid.Health / Humanoid.MaxHealth;
                                Healthbar.Visible = ESP.Drawing.Healthbar.Enabled;
                                Healthbar.Position = UDim2.new(0, Pos.X - w / 2 - 6, 0, Pos.Y - h / 2 + h * (1 - health))  
                                Healthbar.Size = UDim2.new(0, ESP.Drawing.Healthbar.Width, 0, h * health)  

                                BehindHealthbar.Visible = ESP.Drawing.Healthbar.Enabled;
                                BehindHealthbar.Position = UDim2.new(0, Pos.X - w / 2 - 6, 0, Pos.Y - h / 2)  
                                BehindHealthbar.Size = UDim2.new(0, ESP.Drawing.Healthbar.Width, 0, h)

                                do
                                    if ESP.Drawing.Healthbar.HealthText then
                                        local healthPercentage = math.floor(Humanoid.Health / Humanoid.MaxHealth * 100)
                                        HealthText.Position = UDim2.new(0, Pos.X - w / 2 - 6, 0, Pos.Y - h / 2 + h * (1 - healthPercentage / 100) + 3)
                                        HealthText.Text = tostring(healthPercentage)
                                        HealthText.Visible = Humanoid.Health < Humanoid.MaxHealth
                                        if ESP.Drawing.Healthbar.Lerp then
                                            local color = health >= 0.75 and Color3.fromRGB(0, 255, 0) or health >= 0.5 and Color3.fromRGB(255, 255, 0) or health >= 0.25 and Color3.fromRGB(255, 170, 0) or Color3.fromRGB(255, 0, 0)
                                            HealthText.TextColor3 = color
                                        else
                                            HealthText.TextColor3 = ESP.Drawing.Healthbar.HealthTextRGB
                                        end
                                    end                        
                                end
                            end
do
    Name.Visible = ESP.Drawing.Names.Enabled
    if ESP.Options.Friendcheck and lplayer:IsFriendsWith(plr.UserId) then
        Name.Text = string.format('%s', plr.Name)
    else
        Name.Text = string.format('%s', plr.Name)
    end
    Name.Position = UDim2.new(0, Pos.X, 0, Pos.Y - h / 2 - 9)
end

do
    if ESP.Drawing.Distances.Enabled then
        if ESP.Drawing.Distances.Position == "Bottom" then

            Weapon.Position = UDim2.new(0, Pos.X, 0, Pos.Y + h / 2 + 18)
            WeaponIcon.Position = UDim2.new(0, Pos.X - 21, 0, Pos.Y + h / 2 + 15)
            Distance.Position = UDim2.new(0, Pos.X, 0, Pos.Y + h / 2 + 7)
            Distance.Text = string.format("%d meters", math.floor(Dist))
            Distance.Visible = true  
        elseif ESP.Drawing.Distances.Position == "Text" then
            Weapon.Position = UDim2.new(0, Pos.X, 0, Pos.Y + h / 2 + 8)
            WeaponIcon.Position = UDim2.new(0, Pos.X - 21, 0, Pos.Y + h / 2 + 5)
            Distance.Visible = false
            if ESP.Options.Friendcheck and lplayer:IsFriendsWith(plr.UserId) then
                Name.Text = string.format('%s [%d]', plr.Name, math.floor(Dist))
            else
                Name.Text = string.format('%s [%d]', plr.Name, math.floor(Dist))
            end
            Name.Visible = ESP.Drawing.Names.Enabled
        end
    end
end

                            end

                            do 
                                Weapon.Text = "none"
                                Weapon.Visible = ESP.Drawing.Weapons.Enabled
                            end                            
                        else
                            HideESP();
                        end
                    else
                        HideESP();
                    end
                else
                    HideESP();
                end
            end)
        end
        coroutine.wrap(Updater)();
    end
    do 
        for _, v in pairs(game:GetService("Players"):GetPlayers()) do
            if v.Name ~= lplayer.Name then
                coroutine.wrap(render_esp_for_player)(v)
            end      
        end

        game:GetService("Players").PlayerAdded:Connect(function(v)
            coroutine.wrap(render_esp_for_player)(v)
        end);
    end;
end;
ESP = ESP or {}
ESP.Objects = ESP.Objects or {}

function update_player_esp(player)
    ESP = ESP or {}
ESP.Objects = ESP.Objects or {}

    local esp_object = ESP.Objects[player]
    if not esp_object then return end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end

    local is_teammate = ESP.TeamCheck and player.Team == Players.LocalPlayer.Team
    local is_friend = ESP.Options.Friendcheck and is_player_friend(player)
    local highlight = ESP.Options.Highlight

    local base_color = ESP.Options.HighlightRGB

    if is_teammate and ESP.Options.Teamcheck then
        base_color = ESP.Options.TeamcheckRGB
    elseif is_friend then
        base_color = ESP.Options.FriendcheckRGB
    end

    if esp_object.box then
        esp_object.box.Visible = ESP.Drawing.Boxes.Full.Enabled
        esp_object.box.Color = base_color
    end

    if esp_object.name then
        esp_object.name.Visible = ESP.Drawing.Names.Enabled
        esp_object.name.Color = ESP.Drawing.Names.RGB
    end

    if esp_object.distance then
        esp_object.distance.Visible = ESP.Drawing.Distances.Enabled
        esp_object.distance.Color = ESP.Drawing.Distances.RGB
        esp_object.distance.Position = ESP.Drawing.Distances.Position
    end

    if esp_object.chams then
        esp_object.chams.Enabled = ESP.Drawing.Chams.Enabled
        esp_object.chams.FillColor = ESP.Drawing.Chams.FillRGB
        esp_object.chams.OutlineColor = ESP.Drawing.Chams.OutlineRGB
        esp_object.chams.Thermal = ESP.Drawing.Chams.Thermal
        esp_object.chams.VisibleCheck = ESP.Drawing.Chams.VisibleCheck
    end

    if esp_object.flags then
        esp_object.flags.Visible = ESP.Drawing.Flags.Enabled
    end

    if esp_object.healthbar then
        esp_object.healthbar.Visible = ESP.Drawing.Healthbar.Enabled
        esp_object.healthbar.Lerp = ESP.Drawing.Healthbar.Lerp
        esp_object.healthbar.HealthTextVisible = ESP.Drawing.Healthbar.HealthText
        esp_object.healthbar.HealthTextColor = ESP.Drawing.Healthbar.HealthTextRGB
        esp_object.healthbar.Width = ESP.Drawing.Healthbar.Width
        esp_object.healthbar.Gradient = ESP.Drawing.Healthbar.Gradient
        esp_object.healthbar.GradientColors = {
            ESP.Drawing.Healthbar.GradientRGB1,
            ESP.Drawing.Healthbar.GradientRGB2,
            ESP.Drawing.Healthbar.GradientRGB3
        }
    end

    if esp_object.weapon then
        esp_object.weapon.Visible = ESP.Drawing.Weapons.Enabled
        esp_object.weapon.Outlined = ESP.Drawing.Weapons.Outlined
        esp_object.weapon.Color = ESP.Drawing.Weapons.WeaponTextRGB
    end
end

function rebuild_esp()
    local existing_esp = game:GetService("CoreGui"):FindFirstChild("ESPHolder")
    if existing_esp then
        existing_esp:Destroy()
    end

    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game:GetService("Players").LocalPlayer and player.Character then
            local root = player.Character:FindFirstChild("HumanoidRootPart")
            if root then
                local cham_glow = root:FindFirstChild("ChamGlow")
                if cham_glow then
                    cham_glow:Destroy()
                end
            end
        end
    end

    task.wait(0.05)

    local screen_gui = Functions:Create("ScreenGui", {
        Parent = CoreGui,
        Name = "ESPHolder",
    })

    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game:GetService("Players").LocalPlayer then
            coroutine.wrap(render_esp_for_player)(player)
        end
    end

    game:GetService("Players").PlayerAdded:Connect(function(v)
        coroutine.wrap(render_esp_for_player)(v)
    end)
end

function refresh_esp_visuals()
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game:GetService("Players").LocalPlayer then
            update_player_esp(player) 
        end
    end
end

local ESPGroup = Tabs.Visual:AddLeftGroupbox('ESP')

ESPGroup:AddToggle('ESPUseBoundingBox', {
    Text = 'Use Bounding Box',
    Default = false,
    Callback = function(Value)
        ESP.UseBoundingBox = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddSlider('ESPMaxDistance', {
    Text = 'Max Distance',
    Default = 1000,
    Min = 100,
    Max = 100000,
    Rounding = 0,
    Callback = function(Value)
        ESP.MaxDistance = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddSlider('ESPFontSize', {
    Text = 'Font Size',
    Default = 13,
    Min = 8,
    Max = 24,
    Rounding = 0,
    Callback = function(Value)
        ESP.FontSize = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPFadeOutOnDistance', {
    Text = 'Fade Out On Distance',
    Default = false,
    Callback = function(Value)
        ESP.FadeOut.OnDistance = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPFadeOutOnDeath', {
    Text = 'Fade Out On Death',
    Default = false,
    Callback = function(Value)
        ESP.FadeOut.OnDeath = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPFadeOutOnLeave', {
    Text = 'Fade Out On Leave',
    Default = false,
    Callback = function(Value)
        ESP.FadeOut.OnLeave = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPOptionsTeamcheck', {
    Text = 'Team Check Option',
    Default = false,
    Callback = function(Value)
        ESP.Options.Teamcheck = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPOptionsTeamcheckRGB', {
    Default = Color3.fromRGB(0, 255, 0),
    Title = 'Team Check RGB',
    Callback = function(Value)
        ESP.Options.TeamcheckRGB = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPOptionsFriendcheck', {
    Text = 'Friend Check',
    Default = false,
    Callback = function(Value)
        ESP.Options.Friendcheck = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPOptionsFriendcheckRGB', {
    Default = Color3.fromRGB(0, 255, 0),
    Title = 'Friend Check RGB',
    Callback = function(Value)
        ESP.Options.FriendcheckRGB = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPOptionsHighlight', {
    Text = 'Highlight',
    Default = false,
    Callback = function(Value)
        ESP.Options.Highlight = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPOptionsHighlightRGB', {
    Default = Color3.fromRGB(255, 0, 0),
    Title = 'Highlight RGB',
    Callback = function(Value)
        ESP.Options.HighlightRGB = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingChamsEnabled', {
    Text = 'Chams Enabled',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Chams.Enabled = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingChamsThermal', {
    Text = 'Chams Thermal',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Chams.Thermal = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingChamsFillRGB', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Chams Fill RGB',
    Callback = function(Value)
        ESP.Drawing.Chams.FillRGB = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddSlider('ESPDrawingChamsFillTransparency', {
    Text = 'Chams Fill Transparency',
    Default = 100,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        ESP.Drawing.Chams.Fill_Transparency = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingChamsHardFill', {
    Text = 'Chams Hard Fill',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Chams.HardFill = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingChamsOutlineRGB', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Chams Outline RGB',
    Callback = function(Value)
        ESP.Drawing.Chams.OutlineRGB = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddSlider('ESPDrawingChamsOutlineTransparency', {
    Text = 'Chams Outline Transparency',
    Default = 100,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        ESP.Drawing.Chams.Outline_Transparency = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingChamsVisibleCheck', {
    Text = 'Chams Visible Check',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Chams.VisibleCheck = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingNamesEnabled', {
    Text = 'Names Enabled',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Names.Enabled = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingNamesRGB', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Names RGB',
    Callback = function(Value)
        ESP.Drawing.Names.RGB = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingFlagsEnabled', {
    Text = 'Flags Enabled',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Flags.Enabled = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingDistancesEnabled', {
    Text = 'Distances Enabled',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Distances.Enabled = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingDistancesRGB', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Distances RGB',
    Callback = function(Value)
        ESP.Drawing.Distances.RGB = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddDropdown('ESPDrawingDistancesPosition', {
    Values = {'Text', 'Bottom'},
    Default = 1,
    Multi = false,
    Text = 'Distances Position',
    Callback = function(Value)
        ESP.Drawing.Distances.Position = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingWeaponsEnabled', {
    Text = 'Weapons Enabled',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Weapons.Enabled = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingWeaponsWeaponTextRGB', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Weapons Text RGB',
    Callback = function(Value)
        ESP.Drawing.Weapons.WeaponTextRGB = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingWeaponsOutlined', {
    Text = 'Weapons Outlined',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Weapons.Outlined = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingWeaponsGradient', {
    Text = 'Weapons Gradient',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Weapons.Gradient = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingWeaponsGradientRGB1', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Weapons Gradient RGB1',
    Callback = function(Value)
        ESP.Drawing.Weapons.GradientRGB1 = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingWeaponsGradientRGB2', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Weapons Gradient RGB2',
    Callback = function(Value)
        ESP.Drawing.Weapons.GradientRGB2 = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingHealthbarEnabled', {
    Text = 'Healthbar Enabled',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Healthbar.Enabled = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingHealthbarHealthText', {
    Text = 'Health Text',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Healthbar.HealthText = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingHealthbarHealthTextRGB', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Health Text RGB',
    Callback = function(Value)
        ESP.Drawing.Healthbar.HealthTextRGB = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingHealthbarLerp', {
    Text = 'Health Lerp',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Healthbar.Lerp = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddSlider('ESPDrawingHealthbarWidth', {
    Text = 'Healthbar Width',
    Default = 2.5,
    Min = 1,
    Max = 5,
    Rounding = 1,
    Callback = function(Value)
        ESP.Drawing.Healthbar.Width = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingHealthbarGradient', {
    Text = 'Healthbar Gradient',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Healthbar.Gradient = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingHealthbarGradientRGB1', {
    Default = Color3.fromRGB(200, 0, 0),
    Title = 'Healthbar Gradient RGB1',
    Callback = function(Value)
        ESP.Drawing.Healthbar.GradientRGB1 = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingHealthbarGradientRGB2', {
    Default = Color3.fromRGB(220, 220, 220),
    Title = 'Healthbar Gradient RGB2',
    Callback = function(Value)
        ESP.Drawing.Healthbar.GradientRGB2 = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingHealthbarGradientRGB3', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Healthbar Gradient RGB3',
    Callback = function(Value)
        ESP.Drawing.Healthbar.GradientRGB3 = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingBoxesAnimate', {
    Text = 'Boxes Animate',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Boxes.Animate = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddSlider('ESPDrawingBoxesRotationSpeed', {
    Text = 'Boxes Rotation Speed',
    Default = 300,
    Min = 100,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        ESP.Drawing.Boxes.RotationSpeed = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingBoxesImageFill', {
    Text = 'Boxes Image Fill',
    Default = false,  -- Assuming default false, adjust if needed
    Callback = function(Value)
        ESP.Drawing.Boxes.ImageFill = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingBoxesGradient', {
    Text = 'Boxes Gradient',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Boxes.Gradient = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingBoxesGradientRGB1', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Boxes Gradient RGB1',
    Callback = function(Value)
        ESP.Drawing.Boxes.GradientRGB1 = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingBoxesGradientRGB2', {
    Default = Color3.fromRGB(0, 0, 0),
    Title = 'Boxes Gradient RGB2',
    Callback = function(Value)
        ESP.Drawing.Boxes.GradientRGB2 = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingBoxesGradientFill', {
    Text = 'Boxes Gradient Fill',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Boxes.GradientFill = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingBoxesGradientFillRGB1', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Boxes Gradient Fill RGB1',
    Callback = function(Value)
        ESP.Drawing.Boxes.GradientFillRGB1 = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingBoxesGradientFillRGB2', {
    Default = Color3.fromRGB(0, 0, 0),
    Title = 'Boxes Gradient Fill RGB2',
    Callback = function(Value)
        ESP.Drawing.Boxes.GradientFillRGB2 = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingBoxesFilledEnabled', {
    Text = 'Boxes Filled Enabled',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Boxes.Filled.Enabled = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingBoxesFilledRGB', {
    Default = Color3.fromRGB(0, 0, 0),
    Title = 'Boxes Filled RGB',
    Callback = function(Value)
        ESP.Drawing.Boxes.Filled.RGB = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddSlider('ESPDrawingBoxesFilledTransparency', {
    Text = 'Boxes Filled Transparency',
    Default = 0.75,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        ESP.Drawing.Boxes.Filled.Transparency = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingBoxesFullEnabled', {
    Text = 'Boxes Full Enabled',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Boxes.Full.Enabled = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingBoxesFullRGB', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Boxes Full RGB',
    Callback = function(Value)
        ESP.Drawing.Boxes.Full.RGB = Value
        refresh_esp_visuals()
    end
})

ESPGroup:AddToggle('ESPDrawingBoxesCornerEnabled', {
    Text = 'Boxes Corner Enabled',
    Default = false,
    Callback = function(Value)
        ESP.Drawing.Boxes.Corner.Enabled = Value
        refresh_esp_visuals()
    end
}):AddColorPicker('ESPDrawingBoxesCornerRGB', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Boxes Corner RGB',
    Callback = function(Value)
        ESP.Drawing.Boxes.Corner.RGB = Value
        refresh_esp_visuals()
    end
})]]
if isDaHood then 


-- UI Setup (sửa để phù hợp với lib của bạn, giả sử sử dụng Tabs.Misc:AddLeftGroupbox('AutoBuy'))
local AutoBuyGroup = Tabs.Misc:AddLeftGroupbox('AutoBuy')

AutoBuyGroup:AddDropdown('SelectedGun', {
    Values = {'[Rifle]', '[LMG]', '[AK47]', '[AUG]', '[AR]', '[Double-Barrel SG]', '[Drum-Shotgun]', '[DrumGun]', '[Glock]', '[P90]', '[RPG]', '[Revolver]', '[Silencer]', '[SilencerAR]', '[Shotgun]', '[SMG]', '[TacticalShotgun]', '[Taser]'},
    Default = '[Rifle]',
    Multi = false,
    Text = 'Select Gun',
    Callback = function(Value)
        SelectedGun = Value
    end
})

AutoBuyGroup:AddButton('Buy Selected Gun', function()
    BuyingSingle = true
end)

AutoBuyGroup:AddToggle('BuyAmmo', {
    Text = 'Buy Ammo',
    Default = false,
    Callback = function(Value)
        BuyingAmmo = Value
    end
})

AutoBuyGroup:AddToggle('AutoBuyGunAmmo', {
    Text = 'Autobuy Gun + Ammo',
    Default = false,
    Callback = function(Value)
        headshots.AutoLoadout.Enabled = Value
    end
})

AutoBuyGroup:AddDropdown('AutoLoadoutGun', {
    Values = {'[Rifle]', '[LMG]', '[AK47]', '[AUG]', '[AR]', '[Double-Barrel SG]', '[Drum-Shotgun]', '[DrumGun]', '[Glock]', '[P90]', '[RPG]', '[Revolver]', '[Silencer]', '[SilencerAR]', '[Shotgun]', '[SMG]', '[TacticalShotgun]', '[Taser]'},
    Default = '[Rifle]',
    Multi = false,
    Text = 'Auto Gun',
    Callback = function(Value)
        headshots.AutoLoadout.Gun = Value
    end
})

AutoBuyGroup:AddToggle('AutoArmor', {
    Text = 'Auto Armor',
    Default = false,
    Callback = function(Value)
        headshots.AutoArmor.Enabled = Value
    end
})
end
coroutine.wrap(function()
local lighting = game:GetService("Lighting")
local LightingService = game:GetService("Lighting")
local originalAmbient = LightingService.Ambient
local originalOutdoorAmbient = LightingService.OutdoorAmbient
local originalFogColor = LightingService.FogColor
local originalFogStart = LightingService.FogStart
local originalFogEnd = LightingService.FogEnd
local originalBrightness = LightingService.Brightness
local originalClockTime = LightingService.ClockTime
local originalGlobalShadows = LightingService.GlobalShadows
local originalEnvironmentDiffuseScale = LightingService.EnvironmentDiffuseScale
local originalEnvironmentSpecularScale = LightingService.EnvironmentSpecularScale
local originalExposureCompensation = LightingService.ExposureCompensation
local originalColorShiftBottom = LightingService.ColorShift_Bottom
local originalColorShiftTop = LightingService.ColorShift_Top
local originalGeographicLatitude = LightingService.GeographicLatitude
local nebulaThemeColor = Color3.fromRGB(173, 216, 230)
local Visuals = {}
local WorldGroup = Tabs.Visual:AddRightGroupbox('World')
WorldGroup:AddToggle('CustomAmbient', {
    Text = 'Custom Ambient',
    Default = false,
    Callback = function(Value)
        LightingService.Ambient = Value and AmbientColor or originalAmbient
    end
}):AddColorPicker('AmbientColor', {
    Default = originalAmbient,
    Title = 'Ambient Color',
    Callback = function(Value)
        AmbientColor = Value
        if Toggles.CustomAmbient.Value then
            LightingService.Ambient = Value
        end
    end
})

WorldGroup:AddToggle('CustomOutdoorAmbient', {
    Text = 'Custom Outdoor Ambient',
    Default = false,
    Callback = function(Value)
        LightingService.OutdoorAmbient = Value and OutdoorAmbientColor or originalOutdoorAmbient
    end
}):AddColorPicker('OutdoorAmbientColor', {
    Default = originalOutdoorAmbient,
    Title = 'Outdoor Ambient Color',
    Callback = function(Value)
        OutdoorAmbientColor = Value
        if Toggles.CustomOutdoorAmbient.Value then
            LightingService.OutdoorAmbient = Value
        end
    end
})

WorldGroup:AddToggle('CustomFog', {
    Text = 'Custom Fog',
    Default = false,
    Callback = function(Value)
        if Value then
            LightingService.FogColor = FogColor
            LightingService.FogStart = FogStart
            LightingService.FogEnd = FogEnd
        else
            LightingService.FogColor = originalFogColor
            LightingService.FogStart = originalFogStart
            LightingService.FogEnd = originalFogEnd
        end
    end
}):AddColorPicker('FogColor', {
    Default = originalFogColor,
    Title = 'Fog Color',
    Callback = function(Value)
        FogColor = Value
        if Toggles.CustomFog.Value then
            LightingService.FogColor = Value
        end
    end
})

WorldGroup:AddSlider('FogStart', {
    Text = 'Fog Start',
    Min = 0,
    Max = 1000,
    Default = originalFogStart,
    Rounding = 1,
    Callback = function(Value)
        FogStart = Value
        if Toggles.CustomFog.Value then
            LightingService.FogStart = Value
        end
    end
})

WorldGroup:AddSlider('FogEnd', {
    Text = 'Fog End',
    Min = 0,
    Max = 1000,
    Default = originalFogEnd,
    Rounding = 1,
    Callback = function(Value)
        FogEnd = Value
        if Toggles.CustomFog.Value then
            LightingService.FogEnd = Value
        end
    end
})

WorldGroup:AddToggle('CustomBrightness', {
    Text = 'Custom Brightness',
    Default = false,
    Callback = function(Value)
        LightingService.Brightness = Value and BrightnessValue or originalBrightness
    end
})

WorldGroup:AddSlider('BrightnessValue', {
    Text = 'Brightness',
    Min = 0,
    Max = 10,
    Default = originalBrightness,
    Rounding = 1,
    Callback = function(Value)
        BrightnessValue = Value
        if Toggles.CustomBrightness.Value then
            LightingService.Brightness = Value
        end
    end
})

WorldGroup:AddToggle('CustomClockTime', {
    Text = 'Custom Clock Time',
    Default = false,
    Callback = function(Value)
        LightingService.ClockTime = Value and ClockTimeValue or originalClockTime
    end
})

WorldGroup:AddSlider('ClockTimeValue', {
    Text = 'Clock Time',
    Min = 0,
    Max = 24,
    Default = originalClockTime,
    Rounding = 1,
    Callback = function(Value)
        ClockTimeValue = Value
        if Toggles.CustomClockTime.Value then
            LightingService.ClockTime = Value
        end
    end
})

WorldGroup:AddToggle('GlobalShadows', {
    Text = 'Global Shadows',
    Default = originalGlobalShadows,
    Callback = function(Value)
        LightingService.GlobalShadows = Value
    end
})

WorldGroup:AddToggle('CustomEnvironmentDiffuse', {
    Text = 'Custom Environment Diffuse',
    Default = false,
    Callback = function(Value)
        LightingService.EnvironmentDiffuseScale = Value and EnvironmentDiffuseValue or originalEnvironmentDiffuseScale
    end
})

WorldGroup:AddSlider('EnvironmentDiffuseValue', {
    Text = 'Environment Diffuse Scale',
    Min = 0,
    Max = 1,
    Default = originalEnvironmentDiffuseScale,
    Rounding = 2,
    Callback = function(Value)
        EnvironmentDiffuseValue = Value
        if Toggles.CustomEnvironmentDiffuse.Value then
            LightingService.EnvironmentDiffuseScale = Value
        end
    end
})

WorldGroup:AddToggle('CustomEnvironmentSpecular', {
    Text = 'Custom Environment Specular',
    Default = false,
    Callback = function(Value)
        LightingService.EnvironmentSpecularScale = Value and EnvironmentSpecularValue or originalEnvironmentSpecularScale
    end
})

WorldGroup:AddSlider('EnvironmentSpecularValue', {
    Text = 'Environment Specular Scale',
    Min = 0,
    Max = 1,
    Default = originalEnvironmentSpecularScale,
    Rounding = 2,
    Callback = function(Value)
        EnvironmentSpecularValue = Value
        if Toggles.CustomEnvironmentSpecular.Value then
            LightingService.EnvironmentSpecularScale = Value
        end
    end
})

WorldGroup:AddToggle('CustomExposure', {
    Text = 'Custom Exposure',
    Default = false,
    Callback = function(Value)
        LightingService.ExposureCompensation = Value and ExposureValue or originalExposureCompensation
    end
})

WorldGroup:AddSlider('ExposureValue', {
    Text = 'Exposure Compensation',
    Min = -3,
    Max = 3,
    Default = originalExposureCompensation,
    Rounding = 1,
    Callback = function(Value)
        ExposureValue = Value
        if Toggles.CustomExposure.Value then
            LightingService.ExposureCompensation = Value
        end
    end
})

WorldGroup:AddToggle('CustomColorShiftBottom', {
    Text = 'Custom Color Shift Bottom',
    Default = false,
    Callback = function(Value)
        LightingService.ColorShift_Bottom = Value and ColorShiftBottomColor or originalColorShiftBottom
    end
}):AddColorPicker('ColorShiftBottomColor', {
    Default = originalColorShiftBottom,
    Title = 'Color Shift Bottom Color',
    Callback = function(Value)
        ColorShiftBottomColor = Value
        if Toggles.CustomColorShiftBottom.Value then
            LightingService.ColorShift_Bottom = Value
        end
    end
})

WorldGroup:AddToggle('CustomColorShiftTop', {
    Text = 'Custom Color Shift Top',
    Default = false,
    Callback = function(Value)
        LightingService.ColorShift_Top = Value and ColorShiftTopColor or originalColorShiftTop
    end
}):AddColorPicker('ColorShiftTopColor', {
    Default = originalColorShiftTop,
    Title = 'Color Shift Top Color',
    Callback = function(Value)
        ColorShiftTopColor = Value
        if Toggles.CustomColorShiftTop.Value then
            LightingService.ColorShift_Top = Value
        end
    end
})

WorldGroup:AddToggle('CustomGeographicLatitude', {
    Text = 'Custom Geographic Latitude',
    Default = false,
    Callback = function(Value)
        LightingService.GeographicLatitude = Value and GeographicLatitudeValue or originalGeographicLatitude
    end
})

WorldGroup:AddSlider('GeographicLatitudeValue', {
    Text = 'Geographic Latitude',
    Min = -90,
    Max = 90,
    Default = originalGeographicLatitude,
    Rounding = 1,
    Callback = function(Value)
        GeographicLatitudeValue = Value
        if Toggles.CustomGeographicLatitude.Value then
            LightingService.GeographicLatitude = Value
        end
    end
})


WorldGroup:AddToggle('NebulaTheme', {
    Text = 'Nebula Theme',
    Default = false,
    Callback = function(Value)
        if Value then
            local b = Instance.new("BloomEffect", LightingService)
            b.Intensity = 0.7
            b.Size = 24
            b.Threshold = 1
            b.Name = "NebulaBloom"
            local c = Instance.new("ColorCorrectionEffect", LightingService)
            c.Saturation = 0.5
            c.Contrast = 0.2
            c.TintColor = nebulaThemeColor
            c.Name = "NebulaColorCorrection"
            local a = Instance.new("Atmosphere", LightingService)
            a.Density = 0.4
            a.Offset = 0.25
            a.Glare = 1
            a.Haze = 2
            a.Color = nebulaThemeColor
            a.Decay = Color3.fromRGB(173, 216, 230)
            a.Name = "NebulaAtmosphere"
            LightingService.Ambient = nebulaThemeColor
            LightingService.OutdoorAmbient = nebulaThemeColor
            LightingService.FogStart = 100
            LightingService.FogEnd = 500
            LightingService.FogColor = nebulaThemeColor
        else
            for _, name in pairs({"NebulaBloom", "NebulaColorCorrection", "NebulaAtmosphere"}) do
                local obj = LightingService:FindFirstChild(name)
                if obj then obj:Destroy() end
            end
            LightingService.Ambient = originalAmbient
            LightingService.OutdoorAmbient = originalOutdoorAmbient
            LightingService.FogStart = originalFogStart
            LightingService.FogEnd = originalFogEnd
            LightingService.FogColor = originalFogColor
        end
    end
}):AddColorPicker('NebulaColor', {
    Default = Color3.fromRGB(173, 216, 230),
    Title = 'Nebula Color',
    Callback = function(Value)
        nebulaThemeColor = Value
        if Toggles.NebulaTheme.Value then
            local nc = LightingService:FindFirstChild("NebulaColorCorrection")
            if nc then nc.TintColor = Value end
            local na = LightingService:FindFirstChild("NebulaAtmosphere")
            if na then na.Color = Value end
            LightingService.Ambient = Value
            LightingService.OutdoorAmbient = Value
            LightingService.FogColor = Value
        end
    end
})
local SelectedSkybox = "Snow"
local LightingSettings = {
    DefaultSkyboxBk = lighting.Sky.SkyboxBk,
    DefaultSkyboxDn = lighting.Sky.SkyboxDn,
    DefaultSkyboxFt = lighting.Sky.SkyboxFt,
    DefaultSkyboxLf = lighting.Sky.SkyboxLf,
    DefaultSkyboxRt = lighting.Sky.SkyboxRt,
    DefaultSkyboxUp = lighting.Sky.SkyboxUp,
}

local DefaultSky = lighting:FindFirstChildOfClass("Sky")
local LightingSettings = {}
if DefaultSky then
    LightingSettings.DefaultSkyboxBk = DefaultSky.SkyboxBk
    LightingSettings.DefaultSkyboxDn = DefaultSky.SkyboxDn
    LightingSettings.DefaultSkyboxFt = DefaultSky.SkyboxFt
    LightingSettings.DefaultSkyboxLf = DefaultSky.SkyboxLf
    LightingSettings.DefaultSkyboxRt = DefaultSky.SkyboxRt
    LightingSettings.DefaultSkyboxUp = DefaultSky.SkyboxUp
end
local customSkyInstance = nil
local SkyboxAssets = {
    ["Black Storm"] = {
        Bk = "rbxassetid://15502511288",
        Dn = "rbxassetid://15502508460",
        Ft = "rbxassetid://15502510289",
        Lf = "rbxassetid://15502507918",
        Rt = "rbxassetid://15502509398",
        Up = "rbxassetid://15502511911"
    },
    ["Snow"] = {
        Bk = "http://www.roblox.com/asset/?id=155657655",
        Dn = "http://www.roblox.com/asset/?id=155674246",
        Ft = "http://www.roblox.com/asset/?id=155657609",
        Lf = "http://www.roblox.com/asset/?id=155657671",
        Rt = "http://www.roblox.com/asset/?id=155657619",
        Up = "http://www.roblox.com/asset/?id=155674931"
    },
    ["Blue Space"] = {
        Bk = "rbxassetid://15536110634",
        Dn = "rbxassetid://15536112543",
        Ft = "rbxassetid://15536116141",
        Lf = "rbxassetid://15536114370",
        Rt = "rbxassetid://15536118762",
        Up = "rbxassetid://15536117282"
    },
    ["Realistic"] = {
        Bk = "rbxassetid://653719502",
        Dn = "rbxassetid://653718790",
        Ft = "rbxassetid://653719067",
        Lf = "rbxassetid://653719190",
        Rt = "rbxassetid://653718931",
        Up = "rbxassetid://653719321"
    },
    ["Stormy"] = {
        Bk = "http://www.roblox.com/asset/?id=18703245834",
        Dn = "http://www.roblox.com/asset/?id=18703243349",
        Ft = "http://www.roblox.com/asset/?id=18703240532",
        Lf = "http://www.roblox.com/asset/?id=18703237556",
        Rt = "http://www.roblox.com/asset/?id=18703235430",
        Up = "http://www.roblox.com/asset/?id=18703232671"
    },
    ["Pink"] = {
        Bk = "rbxassetid://12216109205",
        Dn = "rbxassetid://12216109875",
        Ft = "rbxassetid://12216109489",
        Lf = "rbxassetid://12216110170",
        Rt = "rbxassetid://12216110471",
        Up = "rbxassetid://12216108877"
    },
    ["Sunset"] = {
        Bk = "rbxassetid://600830446",
        Dn = "rbxassetid://600831635",
        Ft = "rbxassetid://600832720",
        Lf = "rbxassetid://600886090",
        Rt = "rbxassetid://600833862",
        Up = "rbxassetid://600835177"
    },
    ["Arctic"] = {
        Bk = "http://www.roblox.com/asset/?id=225469390",
        Dn = "http://www.roblox.com/asset/?id=225469395",
        Ft = "http://www.roblox.com/asset/?id=225469403",
        Lf = "http://www.roblox.com/asset/?id=225469450",
        Rt = "http://www.roblox.com/asset/?id=225469471",
        Up = "http://www.roblox.com/asset/?id=225469481"
    },
    ["Space"] = {
        Bk = "http://www.roblox.com/asset/?id=166509999",
        Dn = "http://www.roblox.com/asset/?id=166510057",
        Ft = "http://www.roblox.com/asset/?id=166510116",
        Lf = "http://www.roblox.com/asset/?id=166510092",
        Rt = "http://www.roblox.com/asset/?id=166510131",
        Up = "http://www.roblox.com/asset/?id=166510114"
    },
    ["Roblox Default"] = {
        Bk = "rbxasset://textures/sky/sky512_bk.tex",
        Dn = "rbxasset://textures/sky/sky512_dn.tex",
        Ft = "rbxasset://textures/sky/sky512_ft.tex",
        Lf = "rbxasset://textures/sky/sky512_lf.tex",
        Rt = "rbxasset://textures/sky/sky512_rt.tex",
        Up = "rbxasset://textures/sky/sky512_up.tex"
    },
    ["Red Night"] = {
        Bk = "http://www.roblox.com/asset/?id=401664839",
        Dn = "http://www.roblox.com/asset/?id=401664862",
        Ft = "http://www.roblox.com/asset/?id=401664960",
        Lf = "http://www.roblox.com/asset/?id=401664881",
        Rt = "http://www.roblox.com/asset/?id=401664901",
        Up = "http://www.roblox.com/asset/?id=401664936"
    },
    ["Deep Space 1"] = {
        Bk = "http://www.roblox.com/asset/?id=149397692",
        Dn = "http://www.roblox.com/asset/?id=149397686",
        Ft = "http://www.roblox.com/asset/?id=149397697",
        Lf = "http://www.roblox.com/asset/?id=149397684",
        Rt = "http://www.roblox.com/asset/?id=149397688",
        Up = "http://www.roblox.com/asset/?id=149397702"
    },
    ["Pink Skies"] = {
        Bk = "http://www.roblox.com/asset/?id=151165214",
        Dn = "http://www.roblox.com/asset/?id=151165197",
        Ft = "http://www.roblox.com/asset/?id=151165224",
        Lf = "http://www.roblox.com/asset/?id=151165191",
        Rt = "http://www.roblox.com/asset/?id=151165206",
        Up = "http://www.roblox.com/asset/?id=151165227"
    },
    ["Purple Sunset"] = {
        Bk = "rbxassetid://264908339",
        Dn = "rbxassetid://264907909",
        Ft = "rbxassetid://264909420",
        Lf = "rbxassetid://264909758",
        Rt = "rbxassetid://264908886",
        Up = "rbxassetid://264907379"
    },
    ["Blue Night"] = {
        Bk = "http://www.roblox.com/asset/?id=12064107",
        Dn = "http://www.roblox.com/asset/?id=12064152",
        Ft = "http://www.roblox.com/asset/?id=12064121",
        Lf = "http://www.roblox.com/asset/?id=12063984",
        Rt = "http://www.roblox.com/asset/?id=12064115",
        Up = "http://www.roblox.com/asset/?id=12064131"
    },
    ["Blossom Daylight"] = {
        Bk = "http://www.roblox.com/asset/?id=271042516",
        Dn = "http://www.roblox.com/asset/?id=271077243",
        Ft = "http://www.roblox.com/asset/?id=271042556",
        Lf = "http://www.roblox.com/asset/?id=271042310",
        Rt = "http://www.roblox.com/asset/?id=271042467",
        Up = "http://www.roblox.com/asset/?id=271077958"
    },
    ["Blue Nebula"] = {
        Bk = "http://www.roblox.com/asset?id=135207744",
        Dn = "http://www.roblox.com/asset?id=135207662",
        Ft = "http://www.roblox.com/asset?id=135207770",
        Lf = "http://www.roblox.com/asset?id=135207615",
        Rt = "http://www.roblox.com/asset?id=135207695",
        Up = "http://www.roblox.com/asset?id=135207794"
    },
    ["Blue Planet"] = {
        Bk = "rbxassetid://218955819",
        Dn = "rbxassetid://218953419",
        Ft = "rbxassetid://218954524",
        Lf = "rbxassetid://218958493",
        Rt = "rbxassetid://218957134",
        Up = "rbxassetid://218950090"
    },
    ["Deep Space 2"] = {
        Bk = "http://www.roblox.com/asset/?id=159248188",
        Dn = "http://www.roblox.com/asset/?id=159248183",
        Ft = "http://www.roblox.com/asset/?id=159248187",
        Lf = "http://www.roblox.com/asset/?id=159248173",
        Rt = "http://www.roblox.com/asset/?id=159248192",
        Up = "http://www.roblox.com/asset/?id=159248176"
    },
    ["Summer"] = {
        Bk = "rbxassetid://16648590964",
        Dn = "rbxassetid://16648617436",
        Ft = "rbxassetid://16648595424",
        Lf = "rbxassetid://16648566370",
        Rt = "rbxassetid://16648577071",
        Up = "rbxassetid://16648598180"
    },
    ["Galaxy"] = {
        Bk = "rbxassetid://15983968922",
        Dn = "rbxassetid://15983966825",
        Ft = "rbxassetid://15983965025",
        Lf = "rbxassetid://15983967420",
        Rt = "rbxassetid://15983966246",
        Up = "rbxassetid://15983964246"
    },
    ["Stylized"] = {
        Bk = "rbxassetid://18351376859",
        Dn = "rbxassetid://18351374919",
        Ft = "rbxassetid://18351376800",
        Lf = "rbxassetid://18351376469",
        Rt = "rbxassetid://18351376457",
        Up = "rbxassetid://18351377189"
    },
    ["Minecraft"] = {
        Bk = "rbxassetid://8735166756",
        Dn = "http://www.roblox.com/asset/?id=8735166707",
        Ft = "http://www.roblox.com/asset/?id=8735231668",
        Lf = "http://www.roblox.com/asset/?id=8735166755",
        Rt = "http://www.roblox.com/asset/?id=8735166751",
        Up = "http://www.roblox.com/asset/?id=8735166729"
    },
    ["Sunset 2"] = {
        Bk = "http://www.roblox.com/asset/?id=151165214",
        Dn = "http://www.roblox.com/asset/?id=151165197",
        Ft = "http://www.roblox.com/asset/?id=151165224",
        Lf = "http://www.roblox.com/asset/?id=151165191",
        Rt = "http://www.roblox.com/asset/?id=151165206",
        Up = "http://www.roblox.com/asset/?id=151165227"
    },
    ["Cloudy Rain"] = {
        Bk = "http://www.roblox.com/asset/?id=4498828382",
        Dn = "http://www.roblox.com/asset/?id=4498828812",
        Ft = "http://www.roblox.com/asset/?id=4498829917",
        Lf = "http://www.roblox.com/asset/?id=4498830911",
        Rt = "http://www.roblox.com/asset/?id=4498830417",
        Up = "http://www.roblox.com/asset/?id=4498831746"
    },
    ["Black Cloudy Rain"] = {
        Bk = "http://www.roblox.com/asset/?id=149679669",
        Dn = "http://www.roblox.com/asset/?id=149681979",
        Ft = "http://www.roblox.com/asset/?id=149679690",
        Lf = "http://www.roblox.com/asset/?id=149679709",
        Rt = "http://www.roblox.com/asset/?id=149679722",
        Up = "http://www.roblox.com/asset/?id=149680199"
    }
}
local function applyCustomSkybox(name)
    if customSkyInstance then
        customSkyInstance:Destroy()
    end
    customSkyInstance = Instance.new("Sky")
    local sky = SkyboxAssets[name]
    customSkyInstance.SkyboxBk = sky.Bk
    customSkyInstance.SkyboxDn = sky.Dn
    customSkyInstance.SkyboxFt = sky.Ft
    customSkyInstance.SkyboxLf = sky.Lf
    customSkyInstance.SkyboxRt = sky.Rt
    customSkyInstance.SkyboxUp = sky.Up
    customSkyInstance.Name = "CustomSky"
    customSkyInstance.Parent = lighting
end
local function restoreDefaultSkybox()
    if customSkyInstance then
        customSkyInstance:Destroy()
        customSkyInstance = nil
    end
    if DefaultSky then
        DefaultSky.SkyboxBk = LightingSettings.DefaultSkyboxBk
        DefaultSky.SkyboxDn = LightingSettings.DefaultSkyboxDn
        DefaultSky.SkyboxFt = LightingSettings.DefaultSkyboxFt
        DefaultSky.SkyboxLf = LightingSettings.DefaultSkyboxLf
        DefaultSky.SkyboxRt = LightingSettings.DefaultSkyboxRt
        DefaultSky.SkyboxUp = LightingSettings.DefaultSkyboxUp
        DefaultSky.Parent = lighting
    end
end

WorldGroup:AddToggle('CustomSkyboxEnabled', {
    Text = 'Custom Skybox',
    Default = false,
    Callback = function(Value)
        if Value then
            applyCustomSkybox(SelectedSkybox)
        else
            restoreDefaultSkybox()
        end
    end
})

WorldGroup:AddDropdown('SkyboxSelected', {
    Values = {"Black Storm", "Snow", "Blue Space", "Realistic", "Stormy", "Pink", "Sunset", "Arctic", "Space", "Roblox Default", "Red Night", "Deep Space 1", "Pink Skies", "Purple Sunset", "Blue Night", "Blossom Daylight", "Blue Nebula", "Blue Planet", "Deep Space 2", "Summer", "Galaxy", "Stylized", "Minecraft", "Sunset 2", "Cloudy Rain", "Black Cloudy Rain"},
    Default = "Snow",
    Multi = false,
    Text = 'Skybox',
    Callback = function(Value)
        SelectedSkybox = Value
        if Toggles.CustomSkyboxEnabled.Value then
            applyCustomSkybox(SelectedSkybox)
        end
    end
})
end)()
-- UI Settings Setup
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
MenuGroup:AddToggle("KeybindMenuOpen", { Default = Library.KeybindFrame.Visible, Text = "Open Keybind Menu", Callback = function(value) Library.KeybindFrame.Visible = value end})
MenuGroup:AddToggle("ShowCustomCursor", {Text = "Custom Cursor", Default = true, Callback = function(Value) Library.ShowCustomCursor = Value end})
MenuGroup:AddDivider()
MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })
MenuGroup:AddButton("Unload", function() Library:Unload() end)
getgenv().vu = game:GetService("VirtualUser")
getgenv().isAntiAfkEnabled = false
getgenv().antiAfkConnection = nil

MenuGroup:AddToggle('AntiAFKToggle', {
    Text = 'Anti-AFK',
    Default = false,
    Tooltip = 'Prevent AFK timeout',
    Callback = function(state)
        getgenv().isAntiAfkEnabled = state
        if getgenv().isAntiAfkEnabled then
            getgenv().antiAfkConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
                getgenv().vu:CaptureController()
                getgenv().vu:ClickButton2(Vector2.new())
            end)
        else
            if getgenv().antiAfkConnection then
                getgenv().antiAfkConnection:Disconnect()
                getgenv().antiAfkConnection = nil
            end
        end
    end,
    Disabled = false,
    Visible = true
})

MenuGroup:AddButton({
    Text = 'Copy Job ID',
    Func = function()
        setclipboard(game.JobId)
    end,
    Tooltip = 'Copy the current server Job ID to clipboard',
    DoubleClick = false,
    Disabled = false,
    Visible = true
})
MenuGroup:AddButton({
    Text = 'Copy JS Join Script',
    Func = function()
        local jsScript = 'Roblox.GameLauncher.joinGameInstance(' .. game.PlaceId .. ', "' .. game.JobId .. '")'
        setclipboard(jsScript)
    end,
    Tooltip = 'Copy the join script for the current server',
    DoubleClick = false,
    Disabled = false,
    Visible = true
})
MenuGroup:AddInput('JobIdInput', {
    Default = '',
    Numeric = false,
    Finished = true,
    Text = '..JobId..',
    Tooltip = 'Enter a Job ID to join a specific server',
    Placeholder = 'Enter Job ID here',
    ClearTextOnFocus = true,
    Callback = function(Value)
        game:GetService('TeleportService'):TeleportToPlaceInstance(game.PlaceId, Value, game:GetService('Players').LocalPlayer)
    end,
    Disabled = false,
    Visible = true
})
MenuGroup:AddButton({
    Text = 'Rejoin Server',
    Func = function()
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)
    end,
    Tooltip = 'Rejoin the current server',
    DoubleClick = false,
    Disabled = false,
    Visible = true
})

coroutine.wrap(function()
Library:SetWatermarkVisibility(true)
getgenv().matcha = {}
getgenv().matcha.WatermarkEnabled = true
getgenv().matcha.WatermarkShowFPS = true
getgenv().matcha.WatermarkShowGameName = false
getgenv().matcha.WatermarkShowUptime = false
getgenv().matcha.WatermarkShowExecutor = false
getgenv().matcha.WatermarkShowPing = true
local Stats = game:GetService("Stats")
-- Modified Watermark Logic
local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60
local StartTime = tick()

local function getExecutor()
    if syn then return "Synapse X" end
    if secure_call then return "ScriptWare" end
    if identifyexecutor then return identifyexecutor() end
    return "Unknown"
end

local MarketplaceService = game:GetService("MarketplaceService")
local function getGameName(placeId)
    local success, result = pcall(function()
        return MarketplaceService:GetProductInfo(placeId).Name
    end)
    return success and result or "Unknown Game"
end

local function updateWatermark()
    FrameCounter += 1
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end

    local Ping = math.floor(Stats.Network.ServerStatsItem["Data Ping"]:GetValue())
    local Executor = getExecutor()
    local Uptime = math.floor(tick() - StartTime)
    local UptimeFormatted = string.format("%02d:%02d", math.floor(Uptime / 60), Uptime % 60)
    local GameName = getGameName(game.PlaceId)

    local watermarkParts = {"NotHub"}
    
    if getgenv().matcha.WatermarkShowExecutor then
        table.insert(watermarkParts, Executor)
    end
    if getgenv().matcha.WatermarkShowGameName then
        table.insert(watermarkParts, string.format("%s (%d)", GameName, game.PlaceId))
    end
    if getgenv().matcha.WatermarkShowUptime then
        table.insert(watermarkParts, string.format("Uptime: %s", UptimeFormatted))
    end
    if getgenv().matcha.WatermarkShowFPS then
        table.insert(watermarkParts, string.format("FPS %d", math.floor(FPS)))
    end
    if getgenv().matcha.WatermarkShowPing then
        table.insert(watermarkParts, string.format("%d ms", Ping))
    end

    Library:SetWatermark(table.concat(watermarkParts, " | "))
    Library:SetWatermarkVisibility(getgenv().matcha.WatermarkEnabled)
end

local WatermarkConnection = RunService.RenderStepped:Connect(updateWatermark)


-- Watermark Customization UI
local WatermarkGroup = Tabs['UI Settings']:AddRightGroupbox('Watermark')

WatermarkGroup:AddToggle('WatermarkEnabled', {
    Text = 'Enabled',
    Default = true,
    Callback = function(Value)
        getgenv().matcha.WatermarkEnabled = Value
    end
})

WatermarkGroup:AddToggle('WatermarkShowFPS', {
    Text = 'Show FPS',
    Default = true,
    Callback = function(Value)
        getgenv().matcha.WatermarkShowFPS = Value
    end
})

WatermarkGroup:AddToggle('WatermarkShowGameName', {
    Text = 'Show Game Name',
    Default = false,
    Callback = function(Value)
        getgenv().matcha.WatermarkShowGameName = Value
    end
})

WatermarkGroup:AddToggle('WatermarkShowUptime', {
    Text = 'Show Uptime',
    Default = false,
    Callback = function(Value)
        getgenv().matcha.WatermarkShowUptime = Value
    end
})

WatermarkGroup:AddToggle('WatermarkShowExecutor', {
    Text = 'Show Executor',
    Default = false,
    Callback = function(Value)
        getgenv().matcha.WatermarkShowExecutor = Value
    end
})

WatermarkGroup:AddToggle('WatermarkShowPing', {
    Text = 'Show Ping',
    Default = true,
    Callback = function(Value)
        getgenv().matcha.WatermarkShowPing = Value
    end
})

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder('matchacc')
SaveManager:SetFolder('matchacc/dahood')

SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])

SaveManager:LoadAutoloadConfig()
Library:OnUnload(function()
    --WatermarkConnection:Disconnect()
    print('Unloaded!')
    Library.Unloaded = true
end)
end)()
game.Players.LocalPlayer.Character.Humanoid.Health = 0
coroutine.wrap(function()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer

-- Danh sách owner
local owners = {
    "anhchangm52",
    "anhaycogihontoi",
    "zazzvaqe",
    "anhchangm5",
    "dao_beo"
    
}

-- Biến điều khiển
local isFrozen = false
local isOrbiting = false
local orbitConnection = nil
local orbitDistance = 5

-- Teleport tới owner
function x1y2z3(owner)
    if owner and owner.Character and owner.Character:FindFirstChild("HumanoidRootPart") then
        localPlayer.Character:SetPrimaryPartCFrame(owner.Character.HumanoidRootPart.CFrame)
    end
end

-- Bắt đầu orbit quanh owner
local function startOrbit(owner)
    if isOrbiting or not owner then return end
    isOrbiting = true

    orbitConnection = RunService.RenderStepped:Connect(function()
        local char = localPlayer.Character
        local oChar = owner.Character
        if char and oChar and oChar:FindFirstChild("HumanoidRootPart") then
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local ohrp = oChar.HumanoidRootPart

            if hrp then
                local t = tick() * 2
                local offset = Vector3.new(math.cos(t) * orbitDistance, 0, math.sin(t) * orbitDistance)
                hrp.CFrame = CFrame.new(ohrp.Position + offset, ohrp.Position)
            end
        end
    end)
end

-- Dừng orbit
local function stopOrbit()
    isOrbiting = false
    if orbitConnection then
        orbitConnection:Disconnect()
        orbitConnection = nil
    end
end

-- Freeze
local function freezePlayer()
    isFrozen = true
    local char = localPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        char.HumanoidRootPart.Anchored = true
    end
end

-- Unfreeze
local function unfreezePlayer()
    isFrozen = false
    local char = localPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        char.HumanoidRootPart.Anchored = false
    end
end

-- Kết nối với owner
function a1b2c3(ownerName)
    local owner

    for _, player in ipairs(Players:GetPlayers()) do
        if player.Name == ownerName then
            owner = player
            break
        end
    end

    if owner then
        owner.Chatted:Connect(function(message)
            -- Kick
            if message == ".k" then
                localPlayer:Kick("Admins Has Kicked You.")

            -- Bring
            elseif message == ".b" then
                x1y2z3(owner)

            -- Freeze
            elseif message == "/fr" then
                freezePlayer()

            -- Unfreeze
            elseif message == ".unfr" then
                unfreezePlayer()

            -- Orbit người dùng không phải owner
            elseif message == ".o" then
                if not table.find(owners, localPlayer.Name) then
                    startOrbit(owner)
                end

            -- Dừng orbit
            elseif message == ".uno" then
                stopOrbit()
            end
        end)
    end
end

-- Đăng ký cho tất cả owner
for _, ownerName in ipairs(owners) do
    a1b2c3(ownerName)
end
end)()
end)
if not success then

end
